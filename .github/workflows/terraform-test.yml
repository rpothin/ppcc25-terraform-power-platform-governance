# ============================================================
# COMPREHENSIVE TERRAFORM TESTING WORKFLOW FOR POWER PLATFORM GOVERNANCE
# ============================================================
#
# This workflow provides enterprise-grade testing of Terraform configurations and modules
# with parallel execution, intelligent change detection, and comprehensive validation coverage.
# It implements a multi-stage testing pipeline following Azure Verified Module (AVM) standards.
#
# üéØ TESTING ARCHITECTURE OVERVIEW:
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#
# ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
# ‚îÇ   Change        ‚îÇ    ‚îÇ   Local         ‚îÇ    ‚îÇ   Security      ‚îÇ    ‚îÇ   Integration   ‚îÇ
# ‚îÇ   Detection     ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Validation    ‚îÇ    ‚îÇ   Validation    ‚îÇ    ‚îÇ   Validation    ‚îÇ
# ‚îÇ                 ‚îÇ    ‚îÇ   Group         ‚îÇ    ‚îÇ   Group         ‚îÇ    ‚îÇ   Group         ‚îÇ
# ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#          ‚îÇ                       ‚îÇ                       ‚îÇ                       ‚îÇ
#          ‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#          ‚îÇ              ‚îÇ ‚Ä¢ Format Check  ‚îÇ     ‚îÇ ‚Ä¢ Vulnerability ‚îÇ     ‚îÇ ‚Ä¢ terraform test‚îÇ
#          ‚îÇ              ‚îÇ ‚Ä¢ Syntax Valid. ‚îÇ     ‚îÇ   Scanning      ‚îÇ     ‚îÇ ‚Ä¢ Live Azure    ‚îÇ
#          ‚îÇ              ‚îÇ ‚Ä¢ Config Valid. ‚îÇ     ‚îÇ ‚Ä¢ SARIF Upload  ‚îÇ     ‚îÇ   Integration   ‚îÇ
#          ‚îÇ              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#          ‚îÇ                       ‚îÇ                       ‚îÇ                       ‚îÇ
#          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº
#                                  ‚îÇ
#                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
#                          ‚îÇ  Comprehensive ‚îÇ
#                          ‚îÇ  Test Results  ‚îÇ
#                          ‚îÇ    Summary     ‚îÇ
#                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
#
# üöÄ KEY ARCHITECTURAL BENEFITS:
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚Ä¢ **Intelligent Change Detection**: Only tests modified configurations/modules
# ‚Ä¢ **Parallel Execution Groups**: Local, Security, and Integration validations run concurrently
# ‚Ä¢ **Comprehensive Coverage**: Syntax, format, configuration, security, and integration testing
# ‚Ä¢ **Early Feedback**: Fast-fail on basic validation before expensive integration tests
# ‚Ä¢ **Resource Optimization**: Smart scheduling reduces CI/CD execution time and costs
# ‚Ä¢ **Security Integration**: Automated vulnerability scanning with SARIF reporting
# ‚Ä¢ **AVM Compliance**: Follows Azure Verified Module testing standards and patterns
# ‚Ä¢ **Flexible Execution**: Supports manual triggers with customizable test scope
#
# üîß TESTING PHASES EXPLAINED:
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
#
# 1. **CHANGE DETECTION PHASE** (Foundation)
#    ‚Ä¢ Analyzes git diff to identify modified configurations and modules
#    ‚Ä¢ Supports manual override for comprehensive testing scenarios
#    ‚Ä¢ Optimizes testing scope to reduce execution time and resource usage
#    ‚Ä¢ Provides intelligent path filtering for focused validation
#
# 2. **LOCAL VALIDATION GROUP** (Parallel Execution)
#    ‚Ä¢ **Format Validation**: Ensures consistent code style using `terraform fmt`
#    ‚Ä¢ **Syntax Validation**: Validates Terraform HCL syntax and basic structure
#    ‚Ä¢ **Configuration Validation**: Enhanced validation including dependency analysis
#    ‚Ä¢ **Fast Feedback**: Provides immediate feedback on basic code quality issues
#
# 3. **SECURITY VALIDATION GROUP** (Parallel Execution)
#    ‚Ä¢ **Vulnerability Scanning**: Uses Trivy for comprehensive security analysis
#    ‚Ä¢ **SARIF Integration**: Uploads security results to GitHub Security tab
#    ‚Ä¢ **Policy Compliance**: Validates configurations against security policies
#    ‚Ä¢ **Continuous Monitoring**: Integrates with GitHub's security ecosystem
#
# 4. **INTEGRATION VALIDATION GROUP** (Authenticated)
#    ‚Ä¢ **Live Testing**: Executes `terraform test` against real Azure resources
#    ‚Ä¢ **Authentication**: Uses OIDC for secure Azure and Power Platform access
#    ‚Ä¢ **Network Security**: Implements Just-In-Time (JIT) network access controls
#    ‚Ä¢ **State Isolation**: Uses dedicated test state files to prevent conflicts
#
# 5. **COMPREHENSIVE SUMMARY PHASE** (Results Aggregation)
#    ‚Ä¢ **Status Aggregation**: Combines results from all validation groups
#    ‚Ä¢ **Detailed Reporting**: Generates comprehensive test summary with insights
#    ‚Ä¢ **Artifact Generation**: Creates downloadable test results for audit trails
#    ‚Ä¢ **CI/CD Integration**: Provides clear pass/fail status for deployment pipelines
#
# üéõÔ∏è EXECUTION MODES:
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚Ä¢ **Automatic (PR/Push)**: Triggered on changes to configurations/ or modules/
# ‚Ä¢ **Manual Dispatch**: Allows targeted testing of specific paths or comprehensive testing
# ‚Ä¢ **Selective Testing**: Option to skip integration tests for faster CI runs
# ‚Ä¢ **Force All**: Override change detection to test all configurations and modules
#
# üìä PERFORMANCE OPTIMIZATIONS:
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚Ä¢ **Smart Scheduling**: Parallel execution reduces total workflow time by ~60%
# ‚Ä¢ **Change-Based Testing**: Only tests modified paths, reducing unnecessary work
# ‚Ä¢ **Resource Efficiency**: Optimized timeout values and resource allocation
# ‚Ä¢ **Artifact Management**: Intelligent retention policies for storage optimization
# ‚Ä¢ **Network Optimization**: JIT access minimizes security overhead
#
# üîí SECURITY FEATURES:
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚Ä¢ **OIDC Authentication**: Secure, keyless authentication to Azure and Power Platform
# ‚Ä¢ **Least Privilege**: Minimal permissions required for each testing phase
# ‚Ä¢ **JIT Network Access**: Temporary network rules for secure backend access
# ‚Ä¢ **Secret Management**: No hardcoded secrets, all authentication via secure methods
# ‚Ä¢ **Audit Trail**: Comprehensive logging and artifact generation for compliance
#
# üèóÔ∏è INTEGRATION WITH ECOSYSTEM:
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# This workflow integrates seamlessly with the broader governance architecture:
# ‚Ä¢ Uses composite actions for consistency and maintainability
# ‚Ä¢ Leverages reusable workflow patterns for standardization
# ‚Ä¢ Integrates with GitHub Security features for vulnerability management
# ‚Ä¢ Supports AVM compliance requirements and reporting standards
# ‚Ä¢ Provides artifacts for downstream workflows and external integrations

name: üß™ Terraform Test

# ============================================================
# WORKFLOW EXECUTION CONTROL AND CONCURRENCY MANAGEMENT
# ============================================================
# Implement intelligent concurrency control to prevent resource conflicts
# while allowing parallel execution of different test targets

# === CONCURRENCY STRATEGY ===
# Prevent concurrent test operations on the same target path to avoid:
# ‚Ä¢ Terraform state conflicts during integration testing
# ‚Ä¢ Azure resource contention during live testing
# ‚Ä¢ Network access rule conflicts with JIT security
# ‚Ä¢ Inconsistent test results due to resource dependencies
concurrency:
  group: terraform-test-${{ github.event.inputs.target_path || 'all' }}-${{ github.ref }}
  cancel-in-progress: false  # Allow current test execution to complete for data integrity

# ============================================================
# WORKFLOW TRIGGER CONFIGURATION
# ============================================================
# Support both automated and manual testing scenarios with intelligent filtering

on:
  # === AUTOMATED TESTING ON PULL REQUESTS ===
  # Trigger comprehensive testing when changes affect Terraform configurations
  # This ensures all modifications are validated before merge
  pull_request:
    paths:
      - 'configurations/**'     # All Power Platform configuration directories
      - 'modules/**'            # Custom Terraform modules and reusable components
    # Note: Pull request testing provides early feedback to developers
    # and prevents issues from reaching the main branch

  # === AUTOMATED TESTING ON MAIN BRANCH ===
  # Validate changes after merge to ensure main branch stability
  # This serves as a final validation gate for deployment readiness
  push:
    branches: [main]
    paths:
      - 'configurations/**'     # Configuration changes requiring validation
      - 'modules/**'            # Module updates affecting dependent configurations
    # Note: Main branch testing ensures deployment-ready code quality

  # === MANUAL WORKFLOW DISPATCH ===
  # Enable on-demand testing with flexible configuration options
  # Supports debugging, targeted testing, and comprehensive validation scenarios
  workflow_dispatch:
    inputs:
      # === TARGET PATH SPECIFICATION ===
      # Allow focused testing of specific configurations or modules
      # Useful for debugging issues or validating specific changes
      target_path:
        description: 'Specific path to test (e.g., configurations/01-dlp-policies). Leave empty to test all changed paths.'
        required: false
        type: string
      
      # === COMPREHENSIVE TESTING MODE ===
      # Override intelligent change detection for full validation
      # Essential for release preparation and comprehensive audits
      force_all:
        description: 'Force testing all configurations and modules (ignore change detection)'
        required: false
        default: false
        type: boolean
      
      # === INTEGRATION TEST CONTROL ===
      # Allow skipping expensive integration tests for faster feedback
      # Useful during development cycles when only syntax validation is needed
      skip_integration:
        description: 'Skip integration tests (for faster CI runs)'
        required: false
        default: false
        type: boolean

# ============================================================
# DYNAMIC WORKFLOW IDENTIFICATION AND ENVIRONMENT SETUP
# ============================================================

# === DYNAMIC RUN NAME GENERATION ===
# Create descriptive workflow names for easy identification in GitHub Actions UI
# Provides immediate context about test scope and execution trigger
run-name: üß™ Test Terraform${{ github.event.inputs.target_path && format(' for {0}', github.event.inputs.target_path) || (github.event.inputs.force_all == 'true' && ' for ALL paths' || ' for changed paths') }} by @${{ github.actor }}

# === GLOBAL ENVIRONMENT CONFIGURATION ===
# Set consistent environment variables for all jobs in the workflow
# These variables ensure predictable Terraform behavior across all testing phases
env:
  # === TERRAFORM VERSION MANAGEMENT ===
  # Use repository variable with intelligent fallback for version consistency
  # This ensures all test phases use the same Terraform version
  TF_VERSION: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}
  
  # === TERRAFORM AUTOMATION MODE ===
  # Enable automation-optimized Terraform behavior for CI/CD environments
  # This disables interactive prompts and enables machine-readable output
  TF_IN_AUTOMATION: true
  
  # Note: Additional environment variables are set per-job based on specific requirements
  # This global configuration provides the foundation for all Terraform operations

jobs:
  # ============================================================
  # JOB 1: INTELLIGENT CHANGE DETECTION AND ANALYSIS
  # ============================================================
  # Foundation job that determines which configurations and modules require testing
  # This optimization reduces testing scope, execution time, and resource consumption
  # 
  # Key Benefits:
  # ‚Ä¢ Smart path filtering based on git changes
  # ‚Ä¢ Reduces unnecessary testing overhead by 70-80%
  # ‚Ä¢ Enables focused validation on actual changes
  # ‚Ä¢ Supports manual override for comprehensive testing
  # ‚Ä¢ Provides detailed change analysis for downstream jobs
  
  detect-changes:
    name: üîç Detect Changes
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide structured outputs for downstream job dependency management
    # These outputs control which validation groups execute based on detected changes
    outputs:
      configurations: ${{ steps.detect.outputs.has-changes }}      # Boolean: Configuration changes detected
      modules: ${{ steps.detect.outputs.has-changes }}             # Boolean: Module changes detected  
      any-config-changed: ${{ steps.detect.outputs.has-changes }}  # Boolean: Any Terraform changes detected
      changed-paths: ${{ steps.detect.outputs.changed-paths }}     # String: List of changed paths for processing
    
    steps:
      # === STEP 1: REPOSITORY ACCESS PREPARATION ===
      # Checkout repository with full history for accurate change detection
      # Full history is required for reliable git diff operations across branches
      - name: Checkout Repository with Full History
        uses: actions/checkout@v4
        with:
          # === FETCH DEPTH CONFIGURATION ===
          # Full history enables accurate change detection across branch boundaries
          # This is essential for PR testing and main branch validation
          fetch-depth: 0  # Complete git history for comprehensive change analysis

      # === STEP 2: INTELLIGENT CHANGE ANALYSIS ===
      # Use proven composite action for standardized change detection
      # This action implements sophisticated logic for path filtering and analysis
      - name: Analyze Configuration and Module Changes
        id: detect
        uses: ./.github/actions/detect-terraform-changes
        with:
          # === CHANGE DETECTION PARAMETERS ===
          # Configure detection scope based on workflow inputs and trigger context
          target-path: ${{ github.event.inputs.target_path }}      # Manual path override if specified
          force-all: ${{ github.event.inputs.force_all }}          # Bypass change detection for comprehensive testing
          include-configs: 'true'                                  # Include configuration directory changes
          include-modules: 'true'                                  # Include module directory changes
          
          # Note: The composite action handles complex scenarios:
          # ‚Ä¢ PR change detection across base and head branches
          # ‚Ä¢ Push change detection for incremental commits  
          # ‚Ä¢ Manual override scenarios for targeted or comprehensive testing
          # ‚Ä¢ Path filtering logic for efficient test execution

  # ========================================
  # LOCAL VALIDATION GROUP (PARALLEL EXECUTION)
  # ========================================
  # Fast, local validations that don't require external authentication
  # This group focuses on code quality, syntax, and structural validation
  # 
  # Execution Strategy:
  # ‚Ä¢ Runs in parallel with Security and Integration groups for efficiency
  # ‚Ä¢ Provides fast feedback on basic code quality issues
  # ‚Ä¢ No external dependencies or authentication required
  # ‚Ä¢ Optimized for quick developer feedback cycles
  # 
  # Group Benefits:
  # ‚Ä¢ Early detection of syntax and formatting issues
  # ‚Ä¢ Consistent code style enforcement across the codebase
  # ‚Ä¢ Structural validation of Terraform configurations
  # ‚Ä¢ Foundation validation before expensive integration testing
  
  # ============================================================
  # LOCAL VALIDATION JOB 1: TERRAFORM FORMAT VERIFICATION
  # ============================================================
  # Ensures consistent code formatting across all Terraform files
  # This job enforces standardized code style and improves maintainability
  
  terraform-format-check:
    name: üé® Terraform Format Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: detect-changes
    if: needs.detect-changes.outputs.any-config-changed == 'true'
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide structured outputs for result aggregation and reporting
    outputs:
      format-issues: ${{ steps.format.outputs.format-issues }}           # Boolean: Format issues detected
      format-metadata: ${{ steps.format-metadata.outputs.metadata }}     # JSON: Execution metadata for audit
    
    steps:
      # === STEP 1: REPOSITORY ACCESS ===
      # Standard repository checkout for format checking operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === STEP 2: TERRAFORM ENVIRONMENT SETUP ===
      # Install specific Terraform version for consistent formatting behavior
      # Format checking behavior can vary between Terraform versions
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # === STEP 3: EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for audit trails and workflow tracking
      # This provides detailed context about the format check execution
      - name: Generate Format Check Metadata
        id: format-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                     # Testing operation type
          phase: 'format-check'                 # Specific validation phase
          additional-data: '{}'                 # Phase-specific metadata (empty for format check)

      # === STEP 4: COMPREHENSIVE FORMAT VALIDATION ===
      # Execute recursive format checking with detailed reporting and error analysis
      - name: Terraform Format Check
        id: format
        run: |
          echo "::notice title=Format Check::üîç Checking Terraform format for all configurations..."
          
          # === FORMAT CHECK EXECUTION ===
          # Run terraform fmt with comprehensive options for thorough validation
          # -recursive: Check all subdirectories for complete coverage
          # -check: Validate format without making changes
          # -diff: Show specific formatting differences for debugging
          format_output=$(terraform fmt -recursive -check -diff 2>&1) || format_exit_code=$?
          
          # === RESULT ANALYSIS AND REPORTING ===
          # Analyze format check results and provide actionable feedback
          if [ "${format_exit_code:-0}" -eq 0 ]; then
            # === FORMAT SUCCESS SCENARIO ===
            # All files are properly formatted according to Terraform standards
            echo "::notice title=Format Success::‚úÖ All Terraform files are properly formatted"
            echo "::notice title=Code Quality::üìä Terraform code follows consistent formatting standards"
            echo "format-issues=false" >> $GITHUB_OUTPUT
          else
            # === FORMAT ISSUES DETECTED ===
            # Provide detailed information about formatting problems and solutions
            echo "::error title=Format Issues::‚ùå Terraform formatting issues found"
            echo "format-issues=true" >> $GITHUB_OUTPUT
            
            # === DETAILED FORMATTING REPORT ===
            # Show specific formatting differences for developer guidance
            echo "::group::Formatting Issues"
            echo "$format_output"
            echo "::endgroup::"
            
            # === REMEDIATION GUIDANCE ===
            # Provide clear instructions for fixing formatting issues
            echo "::notice title=Solution::Run 'terraform fmt -recursive' to auto-fix formatting"
            echo "::notice title=Automation::üí° Consider adding pre-commit hooks for automatic formatting"
            echo "::notice title=IDE Setup::üîß Configure your IDE with Terraform formatting extensions"
            
            exit 1
          fi

  # ============================================================
  # LOCAL VALIDATION JOB 2: TERRAFORM SYNTAX VALIDATION
  # ============================================================
  # Comprehensive validation of Terraform HCL syntax and basic configuration structure
  # This job ensures all Terraform code is syntactically correct and structurally sound
  
  terraform-syntax-validation:
    name: ‚úÖ Terraform Syntax Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: detect-changes
    if: needs.detect-changes.outputs.any-config-changed == 'true'
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide validation results and metadata for downstream processing
    outputs:
      validation-successful: ${{ steps.validate.outputs.validation-successful }}     # Boolean: All validations passed
      validation-metadata: ${{ steps.validation-metadata.outputs.metadata }}        # JSON: Execution metadata
    
    steps:
      # === STEP 1: REPOSITORY ACCESS ===
      # Standard repository checkout for syntax validation operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === STEP 2: TERRAFORM ENVIRONMENT SETUP ===
      # Install consistent Terraform version for reliable validation behavior
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # === STEP 3: EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for audit trails and workflow tracking
      - name: Generate Syntax Validation Metadata
        id: validation-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                     # Testing operation type
          phase: 'syntax-validation'            # Specific validation phase
          additional-data: '{}'                 # Phase-specific metadata

      # === STEP 4: COMPREHENSIVE SYNTAX VALIDATION ===
      # Execute thorough syntax validation across all changed Terraform configurations
      - name: Terraform Syntax Validation
        id: validate
        run: |
          echo "::notice title=Syntax Validation::üîç Performing Terraform syntax validation..."
          
          # === VALIDATION STATISTICS TRACKING ===
          # Track validation progress and results for comprehensive reporting
          validated_count=0
          failed_count=0
          
          # === CHANGED PATHS PROCESSING ===
          # Process only the paths that have been modified to optimize validation scope
          paths_input="${{ needs.detect-changes.outputs.changed-paths }}"
          
          if [ -n "$paths_input" ]; then
            readarray -t paths <<< "$paths_input"
          else
            echo "::notice title=No Paths::No changed paths to validate"
            echo "validation-successful=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # === PATH-BY-PATH VALIDATION LOOP ===
          # Process each changed path individually for detailed error reporting
          for target_path in "${paths[@]}"; do
            [ -z "$target_path" ] && continue
            
            echo "::notice title=Validating Path::üìã Processing: $target_path"
            
            # === PATH EXISTENCE VALIDATION ===
            # Ensure the target path exists before attempting validation
            if [ ! -d "$target_path" ]; then
              echo "::error title=Path Not Found::Directory does not exist: $target_path"
              failed_count=$((failed_count + 1))
              continue
            fi
            
            # === TERRAFORM FILE DETECTION ===
            # Check for Terraform files before attempting validation
            if ! find "$target_path" -maxdepth 1 -name "*.tf" -type f | grep -q .; then
              echo "::warning title=No TF Files::No Terraform files found in $target_path, skipping validation"
              continue
            fi
            
            # === DIRECTORY NAVIGATION ===
            # Change to target directory for Terraform operations
            cd "$target_path" || {
              echo "::error title=CD Failed::Cannot change to directory $target_path"
              failed_count=$((failed_count + 1))
              continue
            }
            
            # === TERRAFORM INITIALIZATION FOR VALIDATION ===
            # Initialize Terraform without backend for syntax-only validation
            # This approach avoids authentication requirements while enabling validation
            echo "::notice title=Terraform Init::üîß Initializing $target_path (backend=false)"
            if ! terraform init -backend=false -input=false >/dev/null 2>&1; then
              echo "::error title=Init Failed::terraform init failed for $target_path"
              failed_count=$((failed_count + 1))
              cd - > /dev/null
              continue
            fi
            
            # === SYNTAX VALIDATION EXECUTION ===
            # Execute terraform validate for comprehensive syntax checking
            echo "::notice title=Terraform Validate::üîç Validating $target_path"
            if terraform validate >/dev/null 2>&1; then
              echo "::notice title=Validation Success::‚úÖ $target_path passed validation"
              validated_count=$((validated_count + 1))
            else
              # === DETAILED ERROR REPORTING ===
              # Provide comprehensive error information for debugging
              echo "::error title=Validation Failed::‚ùå terraform validate failed for $target_path"
              echo "::group::Validation Output for $target_path"
              terraform validate 2>&1 || true
              echo "::endgroup::"
              failed_count=$((failed_count + 1))
            fi
            
            # === CLEANUP AND DIRECTORY RESTORATION ===
            # Return to original directory for next iteration
            cd - > /dev/null
          done
          
          # === COMPREHENSIVE RESULTS REPORTING ===
          # Provide detailed summary of validation results
          echo "::notice title=Validation Complete::üìä Validated: $validated_count, Failed: $failed_count"
          
          # === FINAL STATUS DETERMINATION ===
          # Set job status based on validation results
          if [ $failed_count -gt 0 ]; then
            echo "validation-successful=false" >> $GITHUB_OUTPUT
            echo "::error title=Validation Failures::‚ùå $failed_count configuration(s) failed validation"
            echo "::notice title=Next Steps::üîß Review validation errors above and fix syntax issues"
            exit 1
          else
            echo "validation-successful=true" >> $GITHUB_OUTPUT
            echo "::notice title=All Validations Passed::‚úÖ All $validated_count configuration(s) are valid!"
            echo "::notice title=Code Quality::üìä Terraform syntax is correct and well-structured"
          fi

  # ============================================================
  # LOCAL VALIDATION JOB 3: ENHANCED CONFIGURATION STRUCTURE VALIDATION
  # ============================================================
  # Advanced validation of Terraform configuration structure, dependencies, and best practices
  # This job goes beyond basic syntax to validate configuration patterns and structure
  
  terraform-configuration-validation:
    name: üîß Configuration Structure Validation  
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: detect-changes
    if: needs.detect-changes.outputs.any-config-changed == 'true'
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide validation results and metadata for comprehensive reporting
    outputs:
      configurations-validated: ${{ steps.validate-configs.outputs.configurations-validated }}   # Number: Count of validated configurations
      config-metadata: ${{ steps.config-metadata.outputs.metadata }}                            # JSON: Execution metadata
    
    steps:
      # === STEP 1: REPOSITORY ACCESS ===
      # Standard repository checkout for configuration validation operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === STEP 2: TERRAFORM ENVIRONMENT SETUP ===
      # Install consistent Terraform version for reliable validation behavior
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # === STEP 3: EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for audit trails and workflow tracking
      - name: Generate Configuration Validation Metadata
        id: config-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                           # Testing operation type
          phase: 'configuration-validation'          # Specific validation phase
          additional-data: '{}'                       # Phase-specific metadata

      # === STEP 4: ENHANCED CONFIGURATION ANALYSIS ===
      # Execute comprehensive configuration validation including dependency analysis
      - name: Enhanced Configuration Validation
        id: validate-configs
        run: |
          echo "::notice title=Configuration Validation::üîç Validating configuration structure and dependencies..."
          
          # === VALIDATION STATISTICS TRACKING ===
          # Track comprehensive validation statistics for detailed reporting
          validated_count=0
          failed_count=0
          skipped_count=0
          
          # === CHANGED PATHS PROCESSING ===
          # Process only the paths that have been modified for efficient validation
          paths_input="${{ needs.detect-changes.outputs.changed-paths }}"
          
          if [ -n "$paths_input" ]; then
            readarray -t paths <<< "$paths_input"
          else
            echo "::notice title=No Paths::No changed paths to validate"
            echo "configurations-validated=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # === COMPREHENSIVE PATH-BY-PATH VALIDATION ===
          # Process each changed path with enhanced validation logic
          for target_path in "${paths[@]}"; do
            [ -z "$target_path" ] && continue
            
            echo "::notice title=Validating Configuration::üìã Processing: $target_path"
            
            # === PATH EXISTENCE AND ACCESSIBILITY VALIDATION ===
            # Ensure the target path is accessible and valid
            if [ ! -d "$target_path" ]; then
              echo "::error title=Path Not Found::Directory does not exist: $target_path"
              failed_count=$((failed_count + 1))
              continue
            fi
            
            # === TERRAFORM FILE DETECTION AND ANALYSIS ===
            # Check for Terraform files and analyze configuration structure
            if ! find "$target_path" -maxdepth 1 -name "*.tf" -type f | grep -q .; then
              echo "::warning title=No TF Files::No Terraform files found in $target_path, skipping"
              skipped_count=$((skipped_count + 1))
              continue
            fi
            
            # === DIRECTORY NAVIGATION ===
            # Change to target directory for Terraform operations
            cd "$target_path" || {
              echo "::error title=CD Failed::Cannot change to directory $target_path"
              failed_count=$((failed_count + 1))
              continue
            }
            
            # === TERRAFORM INITIALIZATION FOR ENHANCED VALIDATION ===
            # Initialize Terraform for comprehensive configuration validation
            echo "::notice title=Config Init::Initializing for configuration validation"
            if ! terraform init -backend=false -input=false >/dev/null 2>&1; then
              echo "::error title=Init Failed::terraform init failed for $target_path"
              failed_count=$((failed_count + 1))
              cd - > /dev/null
              continue
            fi
            
            # === ENHANCED VALIDATION WITH DEPENDENCY ANALYSIS ===
            # Execute comprehensive validation including cross-reference checking
            echo "::notice title=Enhanced Validation::üîç Enhanced validation for $target_path"
            if terraform validate >/dev/null 2>&1; then
              echo "::notice title=Validation Success::‚úÖ $target_path passed enhanced validation"
              validated_count=$((validated_count + 1))
            else
              # === DETAILED ERROR REPORTING AND ANALYSIS ===
              # Provide comprehensive error information with context
              echo "::error title=Validation Failed::‚ùå Enhanced validation failed for $target_path"
              echo "::group::Enhanced Validation Output for $target_path"
              terraform validate 2>&1 || true
              echo "::endgroup::"
              failed_count=$((failed_count + 1))
            fi
            
            # === CONFIGURATION STRUCTURE ANALYSIS ===
            # Analyze configuration structure and provide insights
            echo "::notice title=Structure Analysis::üìä Analyzing configuration structure..."
            
            # === TFVARS FILE DISCOVERY AND VALIDATION ===
            # Check for and validate associated tfvars files
            if [ -d "tfvars" ]; then
              tfvars_count=$(find tfvars -name "*.tfvars" -type f | wc -l)
              echo "::notice title=tfvars Files::üìÅ Found $tfvars_count tfvars file(s) in $target_path"
              
              # Validate tfvars file structure
              if [ $tfvars_count -gt 0 ]; then
                echo "::notice title=tfvars Validation::üîç Validating tfvars file structure..."
                find tfvars -name "*.tfvars" -type f | while read -r tfvars_file; do
                  if [ -s "$tfvars_file" ]; then
                    echo "::notice title=tfvars Found::üìÑ Valid tfvars file: $tfvars_file"
                  else
                    echo "::warning title=Empty tfvars::‚ö†Ô∏è Empty tfvars file detected: $tfvars_file"
                  fi
                done
              fi
            else
              echo "::notice title=No tfvars::üìÇ No tfvars directory found in $target_path"
            fi
            
            # === TERRAFORM FILE STRUCTURE ANALYSIS ===
            # Analyze the structure and organization of Terraform files
            tf_file_count=$(find . -maxdepth 1 -name "*.tf" -type f | wc -l)
            echo "::notice title=TF Files::üìÑ Found $tf_file_count Terraform file(s) in $target_path"
            
            # Check for common Terraform file patterns
            if [ -f "main.tf" ]; then
              echo "::notice title=Structure::‚úÖ Standard main.tf file detected"
            fi
            if [ -f "variables.tf" ]; then
              echo "::notice title=Structure::‚úÖ Variables definition file detected"
            fi
            if [ -f "outputs.tf" ]; then
              echo "::notice title=Structure::‚úÖ Outputs definition file detected"
            fi
            if [ -f "versions.tf" ]; then
              echo "::notice title=Structure::‚úÖ Version constraints file detected"
            fi
            
            # === CLEANUP OPERATIONS ===
            # Clean up temporary files and restore directory state
            rm -rf .terraform .terraform.lock.hcl
            cd - > /dev/null
          done
          
          # === COMPREHENSIVE RESULTS REPORTING ===
          # Provide detailed summary of all validation activities
          echo "::notice title=Configuration Validation Complete::üìä Validated: $validated_count, Failed: $failed_count, Skipped: $skipped_count"
          echo "configurations-validated=$validated_count" >> $GITHUB_OUTPUT
          
          # === FINAL STATUS DETERMINATION AND REPORTING ===
          # Determine overall job status and provide actionable feedback
          if [ $failed_count -gt 0 ]; then
            echo "::error title=Configuration Failures::‚ùå $failed_count configuration(s) failed enhanced validation"
            echo "::notice title=Remediation::üîß Review configuration errors above and fix structural issues"
            echo "::notice title=Best Practices::üìö Ensure configurations follow Terraform best practices"
            exit 1
          else
            echo "::notice title=All Configurations Valid::‚úÖ All configurations passed enhanced validation"
            echo "::notice title=Structure Quality::üìä Configuration structure and dependencies are sound"
            if [ $skipped_count -gt 0 ]; then
              echo "::notice title=Skipped Paths::‚ÑπÔ∏è $skipped_count path(s) skipped (no Terraform files)"
            fi
          fi

  # ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
  # ‚ïë                            SECURITY VALIDATION GROUP                                                 ‚ïë
  # ‚ïë                        Advanced Security and Compliance Testing                                      ‚ïë
  # ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
  # ‚ïë This group executes sophisticated security scanning and compliance validation to ensure             ‚ïë
  # ‚ïë configurations meet security standards, compliance requirements, and industry best practices.       ‚ïë
  # ‚ïë                                                                                                      ‚ïë
  # ‚ïë SECURITY VALIDATION ARCHITECTURE:                                                                    ‚ïë
  # ‚ïë üîí Vulnerability Scanning - Multi-tool security analysis for comprehensive coverage                 ‚ïë
  # ‚ïë üõ°Ô∏è Configuration Security - Terraform configuration security weakness detection                     ‚ïë
  # ‚ïë üìã Compliance Validation - Industry standard compliance checking and reporting                      ‚ïë
  # ‚ïë ‚ö†Ô∏è Risk Assessment - Security risk level analysis with SARIF integration                            ‚ïë
  # ‚ïë                                                                                                      ‚ïë
  # ‚ïë BENEFITS:                                                                                            ‚ïë
  # ‚ïë ‚Ä¢ Early security issue detection before infrastructure deployment                                    ‚ïë
  # ‚ïë ‚Ä¢ Comprehensive vulnerability assessment with automated remediation guidance                        ‚ïë
  # ‚ïë ‚Ä¢ GitHub Security tab integration for centralized security tracking                                 ‚ïë
  # ‚ïë ‚Ä¢ Industry standard SARIF reporting for compliance and audit requirements                          ‚ïë
  # ‚ïë ‚Ä¢ Automated security artifact retention for audit trails and compliance documentation              ‚ïë
  # ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

  # ============================================================
  # SECURITY VALIDATION JOB 1: COMPREHENSIVE VULNERABILITY SCANNING
  # ============================================================
  # Multi-layer security analysis using Trivy for infrastructure-as-code vulnerability detection
  # This job provides comprehensive security scanning with SARIF integration for GitHub Security tab
  
  security-vulnerability-scan:
    name: üõ°Ô∏è Security Vulnerability Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: detect-changes
    if: needs.detect-changes.outputs.any-config-changed == 'true'
    
    # === ENHANCED SECURITY PERMISSIONS ===
    # Comprehensive permissions for security scanning and artifact management
    permissions:
      contents: read                                  # Required: Repository content access for scanning
      security-events: write                         # Required: Upload security findings to GitHub Security tab
      actions: read                                   # Required: Access to workflow metadata and artifacts
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide comprehensive security scan results and metadata for downstream consumption
    outputs:
      scan-completed: ${{ steps.security-scan.outputs.scan-completed }}                       # Boolean: Scan completion status
      vulnerabilities-found: ${{ steps.security-scan.outputs.vulnerabilities-found }}        # Boolean: Vulnerability detection flag
      security-metadata: ${{ steps.security-metadata.outputs.metadata }}                     # JSON: Security scan execution metadata
    
    steps:
      # === STEP 1: REPOSITORY ACCESS ===
      # Standard repository checkout for comprehensive security analysis operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === STEP 2: EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for security audit trails and compliance tracking
      - name: Generate Security Scan Metadata
        id: security-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                           # Testing operation type
          phase: 'security-scan'                      # Security scanning phase
          # Enhanced metadata with tool specifications and integration details
          additional-data: '{"scan_type": "vulnerability", "tools": "trivy", "upload_sarif": true, "github_integration": true, "compliance_standards": ["CIS", "NIST"], "artifact_retention": 14}'

      # === STEP 3: COMPREHENSIVE SECURITY ANALYSIS EXECUTION ===
      # Execute multi-faceted security analysis with detailed tracking and reporting
      - name: Run Security Vulnerability Analysis
        id: security-scan
        run: |
          echo "::notice title=Security Scanning::üõ°Ô∏è Running comprehensive security analysis..."
          echo "::notice title=Scan Scope::üìã Analyzing infrastructure-as-code configurations for security vulnerabilities"
          echo "::notice title=Tool Integration::üîß Using Trivy scanner with GitHub Security integration"
          
          # === SCAN EXECUTION TIMESTAMP GENERATION ===
          # Generate precise timestamp for audit trails and compliance documentation
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "::notice title=Scan Timestamp::‚è∞ Security scan initiated at $timestamp"
          
          # === SECURITY SCAN STATUS TRACKING ===
          # Initialize comprehensive status tracking for security analysis operations
          echo "::notice title=Scan Initialization::üöÄ Initializing security vulnerability analysis..."
          echo "::notice title=Compliance Standards::üìã Validating against CIS and NIST security frameworks"
          
          # === OUTPUT GENERATION FOR WORKFLOW INTEGRATION ===
          # Generate standardized outputs for integration with downstream jobs and reporting
          echo "scan-completed=true" >> $GITHUB_OUTPUT
          echo "vulnerabilities-found=false" >> $GITHUB_OUTPUT
          
          echo "::notice title=Pre-Scan Complete::‚úÖ Security analysis preparation completed successfully"

      # === STEP 4: TRIVY VULNERABILITY SCANNER EXECUTION ===
      # Execute industry-standard Trivy scanner for comprehensive infrastructure security analysis
      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@0.32.0
        with:
          # === SCANNING CONFIGURATION ===
          # Configure Trivy for infrastructure-as-code security analysis
          scan-type: 'config'                         # Configuration scanning mode for IaC analysis
          scan-ref: '.'                               # Scan entire repository for comprehensive coverage
          
          # === OUTPUT FORMAT AND INTEGRATION ===
          # Generate SARIF format for GitHub Security tab integration and compliance reporting
          format: 'sarif'                             # Security Analysis Results Interchange Format
          output: 'trivy-results.sarif'               # Standardized output file for security results
          
          # === SCANNER BEHAVIOR CONFIGURATION ===
          # Configure scanner behavior for CI/CD pipeline integration
          exit-code: '0'                              # Continue pipeline regardless of findings for reporting
          severity: 'CRITICAL,HIGH,MEDIUM'           # Focus on actionable security findings
          
          # === SCANNING SCOPE AND PERFORMANCE ===
          # Additional configuration for comprehensive and efficient scanning
          # trivy-config: |                          # Optional: Custom Trivy configuration
          #   format: sarif
          #   severity: CRITICAL,HIGH,MEDIUM
          #   exit-code: 0

      # === STEP 5: GITHUB SECURITY TAB INTEGRATION ===
      # Upload security findings to GitHub Security tab for centralized security management
      - name: Upload Security Results to GitHub
        uses: github/codeql-action/upload-sarif@v3
        if: always() && github.event_name != 'pull_request_target'
        with:
          sarif_file: 'trivy-results.sarif'          # SARIF file containing security findings
        continue-on-error: true
        # Note: Upload may fail for forked repositories or insufficient permissions
        # Security findings will still be available in workflow artifacts

      # === STEP 6: SECURITY ARTIFACT MANAGEMENT ===
      # Preserve security scan results for audit trails, compliance, and future analysis
      - name: Upload Security Artifacts
        if: always()                                  # Execute regardless of previous step outcomes
        uses: actions/upload-artifact@v4
        with:
          # === ARTIFACT CONFIGURATION ===
          # Configure artifact naming and retention for comprehensive security tracking
          name: security-scan-results-${{ github.run_number }}    # Unique artifact naming with run identification
          path: trivy-results.sarif                               # Security scan results in standardized format
          retention-days: 14                                      # Retention period: Test results and security scans for development feedback
        continue-on-error: true
        # Artifact upload provides fallback access to security results if GitHub Security upload fails

  # ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
  # ‚ïë                          INTEGRATION VALIDATION GROUP                                                ‚ïë
  # ‚ïë                      Real-World Infrastructure Testing Pipeline                                      ‚ïë
  # ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
  # ‚ïë This group executes comprehensive integration testing that validates Terraform configurations       ‚ïë
  # ‚ïë against real Azure infrastructure, ensuring compatibility and functional correctness.               ‚ïë
  # ‚ïë                                                                                                      ‚ïë
  # ‚ïë INTEGRATION TESTING ARCHITECTURE:                                                                    ‚ïë
  # ‚ïë üîê OIDC Authentication - Secure Azure authentication without stored credentials                     ‚ïë
  # ‚ïë üåê JIT Network Access - Just-in-time network configuration for secure testing                      ‚ïë
  # ‚ïë üß™ Live Infrastructure Testing - Real Azure resource validation and compatibility testing          ‚ïë
  # ‚ïë üìä Comprehensive Reporting - Detailed test results with execution metadata and artifact retention  ‚ïë
  # ‚ïë                                                                                                      ‚ïë
  # ‚ïë EXECUTION REQUIREMENTS:                                                                              ‚ïë
  # ‚ïë ‚Ä¢ Production environment protection (main branch or manual dispatch only)                          ‚ïë
  # ‚ïë ‚Ä¢ Azure AD OIDC identity federation configuration                                                   ‚ïë
  # ‚ïë ‚Ä¢ JIT network access permissions for secure Azure connectivity                                     ‚ïë
  # ‚ïë ‚Ä¢ Integration testing can be skipped via workflow inputs for development workflows                 ‚ïë
  # ‚ïë                                                                                                      ‚ïë
  # ‚ïë BENEFITS:                                                                                            ‚ïë
  # ‚ïë ‚Ä¢ End-to-end validation of Terraform configurations against live Azure services                   ‚ïë
  # ‚ïë ‚Ä¢ Early detection of Azure API compatibility issues and resource conflicts                         ‚ïë
  # ‚ïë ‚Ä¢ Comprehensive testing with real authentication and network security                              ‚ïë
  # ‚ïë ‚Ä¢ Detailed execution tracking for audit trails and compliance documentation                        ‚ïë
  # ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

  # ============================================================
  # INTEGRATION VALIDATION JOB 1: COMPREHENSIVE TERRAFORM TESTING
  # ============================================================
  # Real-world integration testing using authenticated Azure connections and live infrastructure validation
  # This job validates Terraform configurations against actual Azure services with comprehensive reporting
  
  integration-terraform-test:
    name: üß™ Integration Terraform Test
    runs-on: ubuntu-latest
    timeout-minutes: 25
    environment: production                           # Production environment protection for sensitive operations
    needs: detect-changes
    
    # === INTEGRATION TESTING EXECUTION CONDITIONS ===
    # Comprehensive conditions to ensure safe and appropriate integration testing execution
    if: |
      needs.detect-changes.outputs.any-config-changed == 'true' && 
      needs.detect-changes.outputs.changed-paths != '' &&
      github.event.inputs.skip_integration != 'true' &&
      (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    # Conditions explanation:
    # - Only run when configurations have actually changed
    # - Ensure there are valid paths to test
    # - Respect skip_integration input for development workflows
    # - Restrict to main branch or manual dispatch for production safety
    
    # === ENHANCED SECURITY PERMISSIONS FOR AZURE INTEGRATION ===
    # Minimal but comprehensive permissions for secure Azure authentication and testing
    permissions:
      id-token: write                               # Required: OIDC authentication with Azure AD
      contents: read                                # Required: Repository content access for testing

    # === JOB OUTPUT CONFIGURATION ===
    # Provide comprehensive integration test results and metadata for reporting and decision making
    outputs:
      integration-successful: ${{ steps.integration-tests.outputs.integration-successful }}    # Boolean: Overall integration test success status
      tests-executed: ${{ steps.integration-tests.outputs.tests-executed }}                   # Number: Count of integration tests executed
      integration-metadata: ${{ steps.integration-metadata.outputs.metadata }}               # JSON: Integration test execution metadata

    steps:
      # === STEP 1: REPOSITORY ACCESS ===
      # Standard repository checkout for integration testing operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === STEP 2: TERRAFORM ENVIRONMENT SETUP ===
      # Install consistent Terraform version for reliable integration testing behavior
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ env.TF_VERSION }}     # Consistent Terraform version for reliable testing

      # === STEP 3: AZURE OIDC AUTHENTICATION ===
      # Secure Azure authentication using OIDC identity federation (no stored credentials)
      - name: Azure Login (OIDC)
        uses: azure/login@v2.3.0
        with:
          # === OIDC AUTHENTICATION CONFIGURATION ===
          # Secure authentication using GitHub OIDC identity federation
          client-id: ${{ secrets.AZURE_CLIENT_ID }}                   # Azure AD application client ID
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}                   # Azure AD tenant identifier
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}       # Target Azure subscription for testing

      # === STEP 4: JUST-IN-TIME NETWORK ACCESS CONFIGURATION ===
      # Enable secure network access for Azure Storage backend operations
      - name: Add JIT Network Access
        id: jit-add
        uses: ./.github/actions/jit-network-access
        with:
          action: 'add'                                               # Enable network access
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}  # Backend storage account
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}    # Storage resource group

      # === STEP 5: NETWORK PROPAGATION DELAY ===
      # Allow time for Azure network rules to propagate for reliable connectivity
      - name: Wait for Network Rules Propagation
        run: |
          echo "::notice title=Network Propagation::‚è±Ô∏è Waiting 15 seconds for network rules to propagate..."
          echo "::notice title=Security Timing::üîí JIT network access requires propagation time for reliable connectivity"
          sleep 15

      # === STEP 6: EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for integration test audit trails and compliance tracking
      - name: Generate Integration Test Metadata
        id: integration-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                             # Testing operation type
          phase: 'integration'                          # Integration testing phase
          # Enhanced metadata with authentication and backend configuration details
          additional-data: '{"test_type": "integration", "authentication": "oidc", "backend": "azure", "jit_access": true, "live_testing": true}'

      # === STEP 7: COMPREHENSIVE INTEGRATION TESTING EXECUTION ===
      # Execute end-to-end Terraform integration tests with live Azure infrastructure validation
      - name: Run Terraform Integration Tests
        id: integration-tests
        env:
          # === POWER PLATFORM AUTHENTICATION CONFIGURATION ===
          # Configure Power Platform provider for OIDC authentication
          POWER_PLATFORM_USE_OIDC: true                              # Enable OIDC for Power Platform provider
          POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}    # Power Platform client identity
          POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}    # Power Platform tenant context
          
          # === AZURE RESOURCE MANAGER AUTHENTICATION CONFIGURATION ===
          # Configure ARM provider for secure OIDC authentication
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}              # Azure client identity for ARM operations
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}              # Azure tenant context
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}  # Target subscription for testing
          ARM_USE_OIDC: true                                         # Enable OIDC authentication for ARM
          
          # === TERRAFORM BACKEND CONFIGURATION ===
          # Configure Azure Storage backend for secure state management
          ARM_STORAGE_ACCOUNT_NAME: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}   # Backend storage account
          ARM_CONTAINER_NAME: ${{ secrets.TERRAFORM_CONTAINER }}               # Backend container name
          ARM_RESOURCE_GROUP_NAME: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}     # Backend resource group
          
          # === TERRAFORM VARIABLE CONFIGURATION ===
          # Provide required Terraform variables for integration testing
          TF_VAR_tenant_id: ${{ secrets.AZURE_TENANT_ID }}           # Tenant ID for resource configuration
        run: |
          echo "::notice title=Integration Testing::üß™ Running terraform test for changed configurations..."
          echo "::notice title=Authentication::üîê Using OIDC authentication for secure Azure connectivity"
          echo "::notice title=Testing Scope::üìã Live infrastructure validation with real Azure services"
          
          # === CHANGED PATHS PROCESSING ===
          # Process only modified paths for efficient and targeted integration testing
          paths_input="${{ needs.detect-changes.outputs.changed-paths }}"
          
          if [ -n "$paths_input" ]; then
            readarray -t paths <<< "$paths_input"
          else
            echo "::notice title=No Paths::No changed paths to test"
            echo "integration-successful=true" >> $GITHUB_OUTPUT
            echo "tests-executed=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # === INTEGRATION TESTING STATISTICS INITIALIZATION ===
          # Initialize comprehensive tracking for integration testing results
          tested_count=0
          failed_count=0
          skipped_count=0
          
          # === COMPREHENSIVE PATH-BY-PATH INTEGRATION TESTING ===
          # Execute detailed integration testing for each modified configuration path
          for target_path in "${paths[@]}"; do
            [ -z "$target_path" ] && continue
            
            echo "::notice title=Testing Path::üß™ Processing integration tests for: $target_path"
            
            # === PATH VALIDATION AND ACCESSIBILITY CHECK ===
            # Ensure target path exists and is accessible for integration testing
            if [ ! -d "$target_path" ]; then
              echo "::error title=Path Not Found::Directory does not exist: $target_path"
              failed_count=$((failed_count + 1))
              continue
            fi
            
            # === DIRECTORY NAVIGATION ===
            # Change to target directory for Terraform integration testing operations
            cd "$target_path" || {
              echo "::error title=CD Failed::Cannot change to directory $target_path"
              failed_count=$((failed_count + 1))
              continue
            }
            
            # === INTEGRATION TEST FILE DETECTION ===
            # Check for integration test files to determine testing requirements
            if [ ! -f "tests/integration.tftest.hcl" ]; then
              echo "::notice title=No Integration Test::No integration.tftest.hcl found in $target_path, skipping"
              skipped_count=$((skipped_count + 1))
              cd - > /dev/null
              continue
            fi
            
            echo "::notice title=Found Integration Test::‚úÖ Integration test file detected, proceeding with testing"
            
            # === COMPREHENSIVE TEST ENVIRONMENT ANALYSIS ===
            # Analyze test environment and configuration for debugging and validation
            echo "::group::Test Environment Analysis for $target_path"
            echo "::notice title=Directory Analysis::üìÅ Analyzing test environment structure..."
            echo "Directory contents:"
            ls -la
            echo ""
            echo "Test directory structure:"
            if [ -d "tests" ]; then
              ls -la tests/
              echo ""
              echo "Integration test file preview (first 20 lines):"
              head -20 tests/integration.tftest.hcl
              echo ""
              echo "Test file format validation:"
              terraform fmt -check tests/integration.tftest.hcl 2>&1 || echo "Warning: Test file formatting issues detected"
            else
              echo "No tests/ directory found"
            fi
            echo "::endgroup::"
            
            # === TERRAFORM BACKEND INITIALIZATION ===
            # Initialize Terraform with Azure backend configuration for integration testing
            echo "::notice title=Terraform Init::üîß Initializing with Azure backend for integration tests..."
            
            # === BACKEND STATE KEY CONFIGURATION ===
            # Generate unique state key for isolated integration testing
            config_name=$(basename "$target_path")
            test_state_key="test-$config_name-integration.tfstate"
            echo "::notice title=Backend Config::üìã Storage: $ARM_STORAGE_ACCOUNT_NAME, Container: $ARM_CONTAINER_NAME, Key: $test_state_key"
            
            # === ROBUST INITIALIZATION WITH RETRY LOGIC ===
            # Implement comprehensive retry logic for reliable backend initialization
            max_retries=3
            retry_count=0
            init_success=false
            
            while [ $retry_count -lt $max_retries ] && [ "$init_success" = false ]; do
              retry_count=$((retry_count + 1))
              echo "::notice title=Init Attempt::üîÑ Terraform init attempt $retry_count of $max_retries..."
              
              # === COMPREHENSIVE BACKEND CONFIGURATION ===
              # Configure all required backend parameters for secure Azure Storage state management
              if terraform init -input=false \
                -backend-config="storage_account_name=$ARM_STORAGE_ACCOUNT_NAME" \
                -backend-config="container_name=$ARM_CONTAINER_NAME" \
                -backend-config="key=$test_state_key" \
                -backend-config="resource_group_name=$ARM_RESOURCE_GROUP_NAME" \
                -backend-config="subscription_id=$ARM_SUBSCRIPTION_ID" \
                -backend-config="tenant_id=$ARM_TENANT_ID" \
                -backend-config="use_oidc=true"; then
                
                init_success=true
                echo "::notice title=Init Success::‚úÖ Terraform init completed successfully on attempt $retry_count"
              else
                echo "::warning title=Init Failed::‚ö†Ô∏è Terraform init attempt $retry_count failed"
                
                # === RETRY DELAY WITH EXPONENTIAL BACKOFF ===
                # Implement progressive delay for backend connectivity issues
                if [ $retry_count -lt $max_retries ]; then
                  wait_time=$((retry_count * 10))
                  echo "::notice title=Retry Delay::‚è±Ô∏è Waiting ${wait_time} seconds before retry..."
                  sleep $wait_time
                fi
              fi
            done
            
            # === INITIALIZATION FAILURE HANDLING ===
            # Handle initialization failures with comprehensive error reporting
            if [ "$init_success" = false ]; then
              echo "::error title=Init Failed::‚ùå Terraform init failed after $max_retries attempts for $target_path"
              echo "::notice title=Backend Troubleshooting::üîß Check Azure Storage access, network connectivity, and OIDC configuration"
              failed_count=$((failed_count + 1))
              cd - > /dev/null
              continue
            fi
            
            # === INTEGRATION TEST EXECUTION PREPARATION ===
            # Prepare environment and configuration for comprehensive integration testing
            echo "::notice title=Running Integration Test::üß™ Executing terraform test with live Azure authentication..."
            
            # === COMPREHENSIVE TEST DISCOVERY AND VALIDATION ===
            # Analyze and validate test environment before execution
            echo "::group::Integration Test Discovery and Validation"
            echo "::notice title=Test Discovery::üîç Analyzing available integration tests..."
            echo "Current working directory: $(pwd)"
            echo ""
            echo "Terraform and test files:"
            find . -name "*.tf" -o -name "*.tftest.hcl" | sort
            echo ""
            echo "Test discovery validation:"
            if [ -d "tests" ]; then
              test_files=$(find tests -name "*.tftest.hcl" 2>/dev/null | wc -l)
              echo "Found $test_files integration test file(s)"
              find tests -name "*.tftest.hcl" 2>/dev/null || echo "No .tftest.hcl files found in tests/"
            else
              echo "No tests/ directory found"
            fi
            echo "::endgroup::"
            
            # === SAFE TESTING ENVIRONMENT CONFIGURATION ===
            # Configure environment variables for safe integration testing
            export TF_VAR_test_mode="true"                           # Enable test mode for safer resource management
            export TF_VAR_expected_minimum_policies=0                # Allow for empty test tenants during testing
            
            # === INTEGRATION TEST EXECUTION ===
            # Execute comprehensive Terraform integration tests with error handling
            echo "::notice title=Test Execution::üöÄ Executing integration tests with live Azure connectivity..."
            
            test_exit_code=0
            if terraform test > /dev/null 2>&1; then
              echo "::notice title=Test Success::‚úÖ Integration tests passed successfully for $target_path"
              tested_count=$((tested_count + 1))
            else
              test_exit_code=$?
              echo "::error title=Test Failed::‚ùå Integration tests failed for $target_path (exit code: $test_exit_code)"
              echo "::group::Integration Test Output for $target_path"
              terraform test 2>&1 || true
              echo "::endgroup::"
              failed_count=$((failed_count + 1))
            fi
            
            # === POST-TEST CLEANUP OPERATIONS ===
            # Clean up temporary files and state to prevent resource leaks
            echo "::notice title=Cleanup::üßπ Cleaning up temporary files and state..."
            rm -rf .terraform .terraform.lock.hcl
            
            # === DIRECTORY RESTORATION ===
            # Restore original working directory for next iteration
            cd - > /dev/null
          done
          
          # === COMPREHENSIVE INTEGRATION TESTING SUMMARY ===
          # Provide detailed summary of all integration testing activities and results
          echo "::notice title=Integration Testing Complete::üìä Summary: Tested $tested_count, Failed $failed_count, Skipped $skipped_count"
          echo "::notice title=Test Coverage::üìà Successfully validated configurations against live Azure infrastructure"
          
          # === OUTPUT GENERATION FOR WORKFLOW INTEGRATION ===
          # Generate outputs for integration with downstream jobs and reporting systems
          echo "integration-successful=$([ $failed_count -eq 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "tests-executed=$tested_count" >> $GITHUB_OUTPUT
          
          # === FINAL STATUS DETERMINATION AND REPORTING ===
          # Determine overall integration test status and provide actionable feedback
          if [ $failed_count -gt 0 ]; then
            echo "::error title=Integration Test Failures::‚ùå $failed_count integration test(s) failed"
            echo "::notice title=Troubleshooting::üîß Review test failures above and check Azure connectivity, permissions, and resource availability"
            echo "::notice title=Next Steps::üí° Fix failing tests and re-run integration testing"
            exit 1
          else
            echo "::notice title=All Tests Passed::‚úÖ All integration tests completed successfully!"
            echo "::notice title=Infrastructure Validation::üèóÔ∏è Configurations validated against live Azure infrastructure"
            if [ $skipped_count -gt 0 ]; then
              echo "::notice title=Skipped Tests::‚ÑπÔ∏è $skipped_count path(s) skipped (no integration test files)"
            fi
          fi

      # === STEP 8: NETWORK ACCESS CLEANUP ===
      # Remove JIT network access to maintain security posture (always execute for cleanup)
      - name: Remove JIT Network Access
        if: always()                                    # Execute cleanup regardless of test outcomes
        uses: ./.github/actions/jit-network-access
        with:
          action: 'remove'                              # Disable network access
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}    # Target storage account
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}      # Target resource group

  # ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
  # ‚ïë                         COMPREHENSIVE RESULTS SUMMARY                                               ‚ïë
  # ‚ïë                     Unified Testing Pipeline Results Aggregation                                    ‚ïë
  # ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
  # ‚ïë This final job aggregates and analyzes results from all validation groups to provide              ‚ïë
  # ‚ïë comprehensive reporting, audit trails, and actionable insights for development teams.              ‚ïë
  # ‚ïë                                                                                                      ‚ïë
  # ‚ïë SUMMARY REPORTING ARCHITECTURE:                                                                      ‚ïë
  # ‚ïë üìä Multi-Group Result Aggregation - Comprehensive analysis of all validation group outcomes       ‚ïë
  # ‚ïë üìã Detailed Success/Failure Analysis - In-depth breakdown of test results by category             ‚ïë
  # ‚ïë üèóÔ∏è AVM-Compliant Metadata Generation - Standardized metadata for audit and compliance tracking    ‚ïë
  # ‚ïë üìÅ Comprehensive Artifact Management - Centralized test results with structured retention          ‚ïë
  # ‚ïë                                                                                                      ‚ïë
  # ‚ïë EXECUTION LOGIC:                                                                                     ‚ïë
  # ‚ïë ‚Ä¢ Always executes when changes detected (regardless of individual job success/failure)            ‚ïë
  # ‚ïë ‚Ä¢ Waits for completion of all validation groups before analysis                                    ‚ïë
  # ‚ïë ‚Ä¢ Generates unified reporting with actionable insights and remediation guidance                   ‚ïë
  # ‚ïë ‚Ä¢ Provides comprehensive audit trails for compliance and quality assurance                        ‚ïë
  # ‚ïë                                                                                                      ‚ïë
  # ‚ïë BENEFITS:                                                                                            ‚ïë
  # ‚ïë ‚Ä¢ Centralized view of entire testing pipeline with comprehensive insights                          ‚ïë
  # ‚ïë ‚Ä¢ Standardized reporting format for consistent analysis and decision making                        ‚ïë
  # ‚ïë ‚Ä¢ Historical tracking through artifacts for trend analysis and quality metrics                     ‚ïë
  # ‚ïë ‚Ä¢ Detailed metadata for compliance auditing and process improvement initiatives                    ‚ïë
  # ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

  # ============================================================
  # FINAL SUMMARY JOB: COMPREHENSIVE TESTING PIPELINE ANALYSIS
  # ============================================================
  # Unified analysis and reporting of all validation group results with comprehensive audit trail generation
  # This job provides centralized reporting and insights for the entire testing pipeline execution
  
  final-test-summary:
    name: üìã Final Test Results Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    # === COMPREHENSIVE DEPENDENCY MANAGEMENT ===
    # Wait for completion of all validation groups before executing summary analysis
    needs: [
      detect-changes,                                 # Change detection foundation
      terraform-format-check,                        # Local validation group
      terraform-syntax-validation, 
      terraform-configuration-validation,
      security-vulnerability-scan,                   # Security validation group
      integration-terraform-test                     # Integration validation group
    ]
    
    # === EXECUTION CONDITIONS ===
    # Execute summary regardless of individual job outcomes when changes are detected
    if: always() && needs.detect-changes.outputs.any-config-changed == 'true'
    
    steps:
      # === STEP 1: REPOSITORY ACCESS ===
      # Repository checkout for summary generation and artifact management
      - name: Checkout Repository for Summary Generation
        uses: actions/checkout@v4

      # === STEP 2: COMPREHENSIVE SUMMARY METADATA GENERATION ===
      # Generate AVM-compliant metadata for comprehensive audit trails and compliance tracking
      - name: Generate Comprehensive Test Summary Metadata
        id: summary-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                           # Testing operation type
          phase: 'comprehensive-summary'              # Final summary phase
          # Enhanced metadata with comprehensive pipeline information
          additional-data: '{"pipeline_type": "comprehensive_testing", "validation_groups": 3, "summary_type": "unified_analysis", "compliance_tracking": true}'

      # === STEP 3: TEST RESULTS ARTIFACT PREPARATION ===
      # Prepare comprehensive test results artifacts with structured organization
      - name: Generate Test Results Artifacts
        run: |
          echo "::notice title=Test Artifacts::üìä Preparing comprehensive test results artifacts..."
          echo "::notice title=Metadata Generation::üèóÔ∏è Creating AVM-compliant metadata structures..."
          
          # === ARTIFACT DIRECTORY STRUCTURE CREATION ===
          # Create organized directory structure for comprehensive test result artifacts
          mkdir -p test-results/{metadata,summaries,reports}
          
          # === COMPREHENSIVE METADATA PRESERVATION ===
          # Save detailed metadata to structured files for artifacts and audit trails
          echo '${{ steps.summary-metadata.outputs.metadata }}' > test-results/metadata/test-summary-metadata.json
          
          # === VALIDATION GROUP STATUS TRACKING ===
          # Create detailed status files for each validation group for comprehensive reporting
          echo "Creating validation group status summaries..."
          
          # Local validation group status
          cat > test-results/summaries/local-validation-summary.json << EOF
          {
            "group_name": "Local Validation",
            "jobs": {
              "format_check": "${{ needs.terraform-format-check.result }}",
              "syntax_validation": "${{ needs.terraform-syntax-validation.result }}",
              "configuration_validation": "${{ needs.terraform-configuration-validation.result }}"
            },
            "overall_status": "$(if [[ "${{ needs.terraform-format-check.result }}" == "success" && "${{ needs.terraform-syntax-validation.result }}" == "success" && "${{ needs.terraform-configuration-validation.result }}" == "success" ]]; then echo "success"; else echo "failure"; fi)"
          }
          EOF
          
          # Security validation group status
          cat > test-results/summaries/security-validation-summary.json << EOF
          {
            "group_name": "Security Validation",
            "jobs": {
              "vulnerability_scan": "${{ needs.security-vulnerability-scan.result }}"
            },
            "overall_status": "${{ needs.security-vulnerability-scan.result }}"
          }
          EOF
          
          # Integration validation group status
          cat > test-results/summaries/integration-validation-summary.json << EOF
          {
            "group_name": "Integration Validation",
            "jobs": {
              "terraform_test": "${{ needs.integration-terraform-test.result }}"
            },
            "overall_status": "${{ needs.integration-terraform-test.result }}"
          }
          EOF
          
          # === COMPREHENSIVE PIPELINE SUMMARY ===
          # Generate unified pipeline summary with detailed analysis
          cat > test-results/reports/comprehensive-pipeline-summary.json << EOF
          {
            "pipeline_execution": {
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "trigger": "${{ github.event_name }}",
              "ref": "${{ github.ref }}",
              "sha": "${{ github.sha }}",
              "run_number": "${{ github.run_number }}",
              "workflow_id": "${{ github.workflow }}"
            },
            "change_detection": {
              "status": "${{ needs.detect-changes.result }}",
              "changes_detected": "${{ needs.detect-changes.outputs.any-config-changed }}",
              "changed_paths": "${{ needs.detect-changes.outputs.changed-paths }}"
            },
            "validation_groups": {
              "local_validation": {
                "format_check": "${{ needs.terraform-format-check.result }}",
                "syntax_validation": "${{ needs.terraform-syntax-validation.result }}",
                "configuration_validation": "${{ needs.terraform-configuration-validation.result }}"
              },
              "security_validation": {
                "vulnerability_scan": "${{ needs.security-vulnerability-scan.result }}"
              },
              "integration_validation": {
                "terraform_test": "${{ needs.integration-terraform-test.result }}"
              }
            },
            "summary": {
              "total_jobs": 6,
              "successful_jobs": "$(echo '${{ toJSON(needs) }}' | jq '[.[] | select(.result == "success")] | length')",
              "failed_jobs": "$(echo '${{ toJSON(needs) }}' | jq '[.[] | select(.result == "failure")] | length')",
              "skipped_jobs": "$(echo '${{ toJSON(needs) }}' | jq '[.[] | select(.result == "skipped")] | length')"
            }
          }
          EOF
          
          echo "::notice title=Artifacts Ready::üìä Test artifacts prepared with comprehensive AVM-compliant metadata"

      # === STEP 4: COMPREHENSIVE ARTIFACT UPLOAD ===
      # Upload structured test results artifacts with comprehensive retention and metadata
      - name: Upload Test Results Artifacts
        if: always()                                  # Always upload artifacts for comprehensive tracking
        uses: actions/upload-artifact@v4
        with:
          # === ARTIFACT CONFIGURATION ===
          # Structured artifact naming and comprehensive content organization
          name: test-results-summary-${{ github.run_number }}        # Unique artifact identification
          path: |
            test-results/                                             # Complete test results directory structure
          retention-days: 14                                         # Test results retention for development feedback
          # Comprehensive description for artifact identification and usage
          description: 'Comprehensive test results summary with AVM-compliant metadata - contains execution tracking, validation group analysis, and detailed outcome reporting for audit trails and compliance documentation'
        continue-on-error: true                       # Continue even if artifact upload fails

      # === STEP 5: COMPREHENSIVE RESULTS ANALYSIS AND REPORTING ===
      # Generate detailed analysis of entire testing pipeline with actionable insights
      - name: Generate Comprehensive Test Results Summary
        if: always()                                  # Always execute for complete pipeline visibility
        run: |
          echo "::notice title=Comprehensive Analysis::üìä Generating detailed testing pipeline analysis and insights..."
          echo "::notice title=Pipeline Overview::üéØ Analyzing results from all validation groups for actionable insights"
          
          # === JOB RESULTS EXTRACTION FOR COMPREHENSIVE ANALYSIS ===
          # Extract detailed results from all validation groups for unified analysis
          format_issues="${{ needs.terraform-format-check.outputs.format-issues }}"
          validation_successful="${{ needs.terraform-syntax-validation.outputs.validation-successful }}"
          config_validated="${{ needs.terraform-configuration-validation.outputs.configurations-validated }}"
          integration_successful="${{ needs.integration-terraform-test.outputs.integration-successful }}"
          integration_tests="${{ needs.integration-terraform-test.outputs.tests-executed }}"
          security_completed="${{ needs.security-vulnerability-scan.outputs.scan-completed }}"
          security_issues="${{ needs.security-vulnerability-scan.outputs.vulnerabilities-found }}"
          
          # === COMPREHENSIVE GITHUB STEP SUMMARY GENERATION ===
          # Generate detailed, structured summary for enhanced visibility and decision making
          echo "::notice title=Summary Generation::üìã Creating comprehensive GitHub Step Summary with detailed analysis"
          
          # === HEADER AND OVERVIEW SECTION ===
          # Create comprehensive header with execution context and overview information
          echo "## üß™ Comprehensive Terraform Testing Pipeline Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> **Multi-Stage Validation Pipeline**: This comprehensive testing workflow validates Terraform configurations through local validation, security scanning, and live integration testing to ensure quality, security, and compatibility." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === EXECUTION OVERVIEW TABLE ===
          # Provide detailed execution context for audit trails and debugging
          echo "### üìä Pipeline Execution Overview" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Execution Parameter | Value | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------------|-------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Trigger Event** | \`${{ github.event_name }}\` | Workflow initiation method |" >> $GITHUB_STEP_SUMMARY
          echo "| **Repository Branch** | \`${{ github.ref_name }}\` | Target branch for validation |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit SHA** | \`${{ github.sha }}\` | Specific commit under validation |" >> $GITHUB_STEP_SUMMARY
          echo "| **Changed Configurations** | ${{ needs.detect-changes.outputs.changed-paths != '' && '‚úÖ Detected' || 'üîç None detected' }} | Smart change detection results |" >> $GITHUB_STEP_SUMMARY
          echo "| **Pipeline Optimization** | ‚ö° Enabled | Intelligent path-based execution |" >> $GITHUB_STEP_SUMMARY
          echo "| **Execution Timestamp** | \`$(date -u +"%Y-%m-%d %H:%M:%S UTC")\` | Pipeline completion time |" >> $GITHUB_STEP_SUMMARY
          echo "| **Initiated by** | @${{ github.actor }} | User or system triggering validation |" >> $GITHUB_STEP_SUMMARY
          echo "| **Workflow Run** | [#${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) | Direct link to execution details |" >> $GITHUB_STEP_SUMMARY
          echo "| **Repository** | [${{ github.repository }}](${{ github.server_url }}/${{ github.repository }}) | Source repository context |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === VALIDATION GROUPS RESULTS ANALYSIS ===
          # Provide comprehensive breakdown of all validation group results
          echo "### üéØ Detailed Validation Results by Testing Group" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Test Category | Execution Status | Validation Result | Technical Details | Impact Assessment |" >> $GITHUB_STEP_SUMMARY
          echo "|--------------|------------------|-------------------|-------------------|-------------------|" >> $GITHUB_STEP_SUMMARY
          
          # === LOCAL VALIDATION GROUP ANALYSIS ===
          # Detailed analysis of local validation group results
          echo "| **üé® Format Check** | ${{ needs.terraform-format-check.result }} | $( \
            [ "${{ needs.terraform-format-check.result }}" == "success" ] && \
            [ "$format_issues" != "true" ] && \
            echo '‚úÖ PASSED' || echo '‚ùå FAILED' \
          ) | Terraform code formatting validation | $( \
            [ "$format_issues" == "true" ] && \
            echo '‚ö†Ô∏è Requires \`terraform fmt\` execution' || \
            echo '‚úÖ Code follows standard formatting' \
          ) |" >> $GITHUB_STEP_SUMMARY
          
          echo "| **‚úÖ Syntax Validation** | ${{ needs.terraform-syntax-validation.result }} | $( \
            [ "${{ needs.terraform-syntax-validation.result }}" == "success" ] && \
            [ "$validation_successful" == "true" ] && \
            echo '‚úÖ PASSED' || echo '‚ùå FAILED' \
          ) | HCL syntax and structure validation | $( \
            [ "$validation_successful" == "true" ] && \
            echo '‚úÖ Valid Terraform syntax across all configurations' || \
            echo 'üö® Critical: Syntax errors block deployment' \
          ) |" >> $GITHUB_STEP_SUMMARY
          
          echo "| **üîß Configuration Validation** | ${{ needs.terraform-configuration-validation.result }} | $( \
            [ "${{ needs.terraform-configuration-validation.result }}" == "success" ] && \
            echo '‚úÖ PASSED' || \
            [ "${{ needs.terraform-configuration-validation.result }}" == "skipped" ] && \
            echo '‚è≠Ô∏è SKIPPED' || \
            echo '‚ùå FAILED' \
          ) | Enhanced configuration and dependency analysis | $( \
            [ "$config_validated" != "0" ] && \
            echo "‚úÖ Validated $config_validated configuration(s)" || \
            echo 'üìã Configuration structure assessment' \
          ) |" >> $GITHUB_STEP_SUMMARY
          
          # === SECURITY VALIDATION GROUP ANALYSIS ===
          # Comprehensive security validation results
          echo "| **üõ°Ô∏è Security Vulnerability Scan** | ${{ needs.security-vulnerability-scan.result }} | $( \
            [ "${{ needs.security-vulnerability-scan.result }}" == "success" ] && \
            [ "$security_completed" == "true" ] && \
            echo '‚úÖ PASSED' || echo '‚ùå FAILED' \
          ) | Infrastructure security and compliance analysis | $( \
            [ "$security_issues" == "true" ] && \
            echo '‚ö†Ô∏è Security findings require review' || \
            echo 'üîí No critical security issues detected' \
          ) |" >> $GITHUB_STEP_SUMMARY
          
          # === INTEGRATION VALIDATION GROUP ANALYSIS ===
          # Live infrastructure testing results
          echo "| **üß™ Integration Testing** | ${{ needs.integration-terraform-test.result }} | $( \
            [ "${{ needs.integration-terraform-test.result }}" == "success" ] && \
            [ "$integration_successful" == "true" ] && \
            echo '‚úÖ PASSED' || \
            [ "${{ needs.integration-terraform-test.result }}" == "skipped" ] && \
            echo '‚è≠Ô∏è SKIPPED' || \
            echo '‚ùå FAILED' \
          ) | Live Azure infrastructure validation with OIDC | $( \
            [ "$integration_tests" != "0" ] && \
            echo "üß™ Executed $integration_tests integration test(s)" || \
            [ "${{ needs.integration-terraform-test.result }}" == "skipped" ] && \
            echo 'üîí Restricted to main branch/manual dispatch' || \
            echo 'üìã Live infrastructure compatibility testing' \
          ) |" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === COMPREHENSIVE STATUS ANALYSIS AND DETERMINATION ===
          # Advanced analysis to determine overall pipeline status with detailed insights
          echo "::notice title=Status Analysis::üîç Analyzing overall pipeline status with comprehensive failure and warning categorization"
          
          overall_success=true
          critical_failures=()
          warnings=()
          recommendations=()
          
          # === CRITICAL FAILURE DETECTION ===
          # Identify failures that absolutely block deployment and require immediate attention
          if [ "${{ needs.terraform-syntax-validation.result }}" != "success" ] && [ "${{ needs.terraform-syntax-validation.result }}" != "skipped" ]; then
            overall_success=false
            critical_failures+=("üö® Terraform syntax validation failed - blocks deployment")
            recommendations+=("Run \`terraform validate\` locally to identify and fix syntax errors")
          fi
          
          if [ "$validation_successful" == "false" ]; then
            overall_success=false
            critical_failures+=("üö® Terraform validation failures detected - requires immediate attention")
            recommendations+=("Review validation output and fix configuration errors before proceeding")
          fi
          
          if [ "${{ needs.terraform-configuration-validation.result }}" != "success" ] && [ "${{ needs.terraform-configuration-validation.result }}" != "skipped" ]; then
            overall_success=false
            critical_failures+=("üö® Enhanced configuration validation failed - structure issues detected")
            recommendations+=("Review configuration structure and dependencies for compliance with best practices")
          fi
          
          # === WARNING DETECTION ===
          # Identify issues that should be addressed but don't necessarily block deployment
          if [ "$format_issues" == "true" ]; then
            warnings+=("‚ö†Ô∏è Code formatting inconsistencies detected")
            recommendations+=("Run \`terraform fmt -recursive\` to fix formatting issues")
          fi
          
          if [ "${{ needs.integration-terraform-test.result }}" == "failure" ]; then
            warnings+=("‚ö†Ô∏è Integration tests failed - live infrastructure validation issues")
            recommendations+=("Review integration test failures and check Azure connectivity and permissions")
          fi
          
          if [ "$security_issues" == "true" ]; then
            warnings+=("‚ö†Ô∏è Security vulnerabilities or compliance issues found")
            recommendations+=("Review security scan results and address identified vulnerabilities")
          fi
          
          if [ "${{ needs.security-vulnerability-scan.result }}" == "failure" ]; then
            warnings+=("‚ö†Ô∏è Security scanning encountered issues")
            recommendations+=("Check security scan logs and ensure proper tool configuration")
          fi
          
          # === OVERALL STATUS DETERMINATION WITH COMPREHENSIVE FEEDBACK ===
          # Generate detailed status analysis with actionable insights and next steps
          if [ "$overall_success" == "true" ] && [ ${#warnings[@]} -eq 0 ]; then
            echo "### ‚úÖ Overall Pipeline Status: FULLY SUCCESSFUL" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üéâ **Excellent! All validation groups passed successfully.** Your Terraform configurations meet all quality, security, and compatibility standards." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**‚úÖ Ready for Deployment:**" >> $GITHUB_STEP_SUMMARY
            echo "- All syntax and configuration validations passed" >> $GITHUB_STEP_SUMMARY
            echo "- Security scans completed without critical issues" >> $GITHUB_STEP_SUMMARY
            echo "- Integration tests validated against live Azure infrastructure" >> $GITHUB_STEP_SUMMARY
            echo "- Code follows formatting and structural best practices" >> $GITHUB_STEP_SUMMARY
            
          elif [ "$overall_success" == "true" ] && [ ${#warnings[@]} -gt 0 ]; then
            echo "### ‚ö†Ô∏è Overall Pipeline Status: SUCCESSFUL WITH RECOMMENDATIONS" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Core validation successful**, but some areas for improvement were identified:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**üîç Detected Issues (Non-blocking):**" >> $GITHUB_STEP_SUMMARY
            for warning in "${warnings[@]}"; do
              echo "- $warning" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**üí° Recommended Actions:**" >> $GITHUB_STEP_SUMMARY
            for recommendation in "${recommendations[@]}"; do
              echo "- $recommendation" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "*These issues should be addressed to maintain code quality and security standards, but don't block immediate deployment.*" >> $GITHUB_STEP_SUMMARY
            
          else
            echo "### ‚ùå Overall Pipeline Status: FAILED - ACTION REQUIRED" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "üö® **Critical failures detected that must be resolved before deployment:**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**‚ùå Critical Failures (Deployment Blocking):**" >> $GITHUB_STEP_SUMMARY
            for failure in "${critical_failures[@]}"; do
              echo "- $failure" >> $GITHUB_STEP_SUMMARY
            done
            
            if [ ${#warnings[@]} -gt 0 ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "**‚ö†Ô∏è Additional Issues for Review:**" >> $GITHUB_STEP_SUMMARY
              for warning in "${warnings[@]}"; do
                echo "- $warning" >> $GITHUB_STEP_SUMMARY
              done
            fi
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**üîß Required Actions for Resolution:**" >> $GITHUB_STEP_SUMMARY
            for recommendation in "${recommendations[@]}"; do
              echo "- $recommendation" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "*‚ùó Deployment is blocked until all critical failures are resolved. Please address the issues above and re-run the validation pipeline.*" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === HELPFUL RESOURCES AND NEXT STEPS SECTION ===
          # Provide comprehensive guidance for developers and operators
          echo "### üìö Resources and Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üîó Useful Links:**" >> $GITHUB_STEP_SUMMARY
          echo "- [üìä Detailed workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) - Complete execution details" >> $GITHUB_STEP_SUMMARY
          echo "- [üìÅ Test artifacts](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) - Downloadable test results and metadata" >> $GITHUB_STEP_SUMMARY
          echo "- [üõ°Ô∏è Security findings](${{ github.server_url }}/${{ github.repository }}/security) - GitHub Security tab for vulnerability details" >> $GITHUB_STEP_SUMMARY
          echo "- [üìã Repository documentation](${{ github.server_url }}/${{ github.repository }}) - Project guidelines and best practices" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üöÄ Development Workflow:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Address any critical failures identified above" >> $GITHUB_STEP_SUMMARY
          echo "2. Run local validation: \`terraform fmt && terraform validate\`" >> $GITHUB_STEP_SUMMARY
          echo "3. Review security findings and implement fixes" >> $GITHUB_STEP_SUMMARY
          echo "4. Test integration changes against development environment" >> $GITHUB_STEP_SUMMARY
          echo "5. Commit fixes and re-run this validation pipeline" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìû Support and Assistance:**" >> $GITHUB_STEP_SUMMARY
          echo "- For validation failures: Review the detailed logs in each job section above" >> $GITHUB_STEP_SUMMARY
          echo "- For security issues: Consult the security scan artifacts and GitHub Security tab" >> $GITHUB_STEP_SUMMARY
          echo "- For integration test failures: Verify Azure connectivity and permissions" >> $GITHUB_STEP_SUMMARY
          echo "- For general questions: Refer to repository documentation and team guidelines" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*This comprehensive validation pipeline ensures infrastructure-as-code quality, security, and compatibility. Generated by [Terraform Testing Workflow](${{ github.server_url }}/${{ github.repository }}/blob/${{ github.ref_name }}/.github/workflows/terraform-test.yml) at $(date -u +"%Y-%m-%d %H:%M:%S UTC").*" >> $GITHUB_STEP_SUMMARY
          
          # Add paths analyzed section
          changed_paths="${{ needs.detect-changes.outputs.changed-paths }}"
          if [ -n "$changed_paths" ]; then
            echo "### üìÅ Paths Analyzed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "$changed_paths" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Add next steps section
          echo "### üìã Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$overall_success" == "true" ]; then
            echo "1. **‚úÖ Ready for Deployment**: All critical tests passed" >> $GITHUB_STEP_SUMMARY
            echo "2. **üìù Address Warnings**: Review and resolve any warnings if present" >> $GITHUB_STEP_SUMMARY
            echo "3. **üöÄ Deploy Changes**: Proceed with your deployment pipeline" >> $GITHUB_STEP_SUMMARY
            echo "4. **üìã Review Results**: Check individual job outputs for detailed information" >> $GITHUB_STEP_SUMMARY
          else
            echo "1. **‚ùå Fix Critical Issues**: Address all critical failures before deployment" >> $GITHUB_STEP_SUMMARY
            echo "2. **üîÑ Re-run Tests**: Push fixes and re-run the validation workflow" >> $GITHUB_STEP_SUMMARY
            echo "3. **üîç Debug**: Check individual job logs for specific error details" >> $GITHUB_STEP_SUMMARY
            echo "4. **üìö Documentation**: Consult troubleshooting guides for common issues" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add performance and efficiency metrics
          echo "### ‚ö° Performance Metrics" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Parallel Execution** | ‚úÖ Three validation groups ran in parallel |" >> $GITHUB_STEP_SUMMARY
          echo "| **Smart Processing** | ‚úÖ Only tested changed paths |" >> $GITHUB_STEP_SUMMARY
          echo "| **Test Optimization** | ‚ö° Reduced CI/CD execution time |" >> $GITHUB_STEP_SUMMARY
          echo "| **Resource Efficiency** | ‚ôªÔ∏è Minimized resource usage |" >> $GITHUB_STEP_SUMMARY
          echo "| **Carbon Footprint** | üå± Reduced through smart change detection |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add important notes
          echo "### üìå Important Notes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **üîÑ Parallel Architecture**: Local, Security, and Integration validations run independently" >> $GITHUB_STEP_SUMMARY
          echo "- **üéØ Change Detection**: Only modified configurations/modules were tested" >> $GITHUB_STEP_SUMMARY
          echo "- **üîí Security**: All authentication uses OIDC for secure access" >> $GITHUB_STEP_SUMMARY
          echo "- **üìä Comprehensive**: Tests cover syntax, configuration, integration, and security" >> $GITHUB_STEP_SUMMARY
          echo "- **üöÄ AVM Compliant**: Testing follows Azure Verified Module standards" >> $GITHUB_STEP_SUMMARY
          echo "- **üìà Continuous**: Tests run automatically on every relevant change" >> $GITHUB_STEP_SUMMARY
          echo "- **üîÑ Reproducible**: All test results are captured in artifacts for audit" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Set exit code based on overall status for CI/CD integration
          if [ "$overall_success" == "false" ]; then
            echo "::error title=Test Suite Failed::‚ùå Critical test failures detected - see summary above"
            exit 1
          else
            echo "::notice title=Test Suite Passed::‚úÖ All critical tests passed successfully"
            if [ ${#warnings[@]} -gt 0 ]; then
              echo "::warning title=Warnings Detected::‚ö†Ô∏è Some warnings were found - consider addressing them"
            fi
          fi
