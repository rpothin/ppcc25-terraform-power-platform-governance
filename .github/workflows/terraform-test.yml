# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# TERRAFORM TESTING WORKFLOW FOR POWER PLATFORM GOVERNANCE
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Comprehensive multi-stage testing pipeline that validates Terraform configurations through
# parallel execution of local validation, security scanning, and live infrastructure testing.
#
# üéØ WHY THIS EXISTS:
# - Ensures Power Platform governance configurations meet quality standards before deployment
# - Prevents deployment of broken or insecure infrastructure-as-code configurations
# - Automates validation that was previously manual, reducing human error and time
# - Provides early feedback to developers through parallel testing architecture
#
# üîí SECURITY DECISIONS:
# - OIDC authentication required to eliminate stored credentials and follow zero-trust model
# - JIT network access minimizes security exposure while enabling Azure backend connectivity
# - Integration tests require production environment protection for sensitive operations
# - Security scanning integrated with GitHub Security tab for centralized vulnerability tracking
#
# ‚öôÔ∏è OPERATIONAL CONTEXT:
# - Concurrency controls prevent state conflicts during parallel test execution
# - Change detection optimizes execution time by testing only modified configurations
# - Timeout values sized for comprehensive validation without unnecessary resource consumption
# - Parallel groups reduce total pipeline time while maintaining thorough validation
#
# üìã INTEGRATION REQUIREMENTS:
# - Depends on composite actions for change detection and metadata generation
# - Requires Azure OIDC identity federation and GitHub environment protection
# - Integrates with GitHub Security tab through SARIF upload for vulnerability tracking
# - Generates AVM-compliant artifacts for audit trails and compliance documentation
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

name: Terraform Test

# === CONCURRENCY STRATEGY ===
# Prevent concurrent test operations on the same target path to avoid:
# ‚Ä¢ Terraform state conflicts during integration testing
# ‚Ä¢ Azure resource contention during live testing
# ‚Ä¢ Network access rule conflicts with JIT security
concurrency:
  group: terraform-test-${{ github.event.inputs.target_path || 'all' }}-${{ github.ref }}
  cancel-in-progress: false  # Allow current test execution to complete for data integrity

on:
  # === AUTOMATED TESTING ON PULL REQUESTS ===
  # Trigger comprehensive testing when changes affect Terraform configurations
  # This ensures all modifications are validated before merge
  pull_request:
    paths:
      - 'configurations/**'     # All Power Platform configuration directories
      - 'modules/**'            # Custom Terraform modules and reusable components

  # === AUTOMATED TESTING ON MAIN BRANCH ===
  # Validate changes after merge to ensure main branch stability
  push:
    branches: [main]
    paths:
      - 'configurations/**'     # Configuration changes requiring validation
      - 'modules/**'            # Module updates affecting dependent configurations

  # === MANUAL WORKFLOW DISPATCH ===
  # Enable on-demand testing with flexible configuration options
  workflow_dispatch:
    inputs:
      target_path:
        description: 'Specific path to test (e.g., configurations/01-dlp-policies). Leave empty to test all changed paths.'
        required: false
        type: string
        # WHY: Allows focused testing for debugging specific configurations
        # VALIDATION: Must be valid path in configurations/ or modules/
        # PERFORMANCE: Reduces test scope for faster feedback cycles
      
      force_all:
        description: 'Force testing all configurations and modules (ignore change detection)'
        required: false
        default: false
        type: boolean
        # WHY: Enables comprehensive validation for release preparation
        # SECURITY: Ensures no configuration is missed during full audits
        # COMPLIANCE: Supports audit requirements for complete validation
      
      skip_integration:
        description: 'Skip integration tests (for faster CI runs)'
        required: false
        default: false
        type: boolean
        # WHY: Allows faster development cycles when only local validation needed
        # SECURITY: Integration tests require production environment access

run-name: üß™ Test Terraform${{ github.event.inputs.target_path && format(' for {0}', github.event.inputs.target_path) || (github.event.inputs.force_all == 'true' && ' for ALL paths' || ' for changed paths') }} by @${{ github.actor }}

# === GLOBAL ENVIRONMENT CONFIGURATION ===
# Set consistent environment variables for all jobs in the workflow
env:
  TF_VERSION: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}  # Consistent Terraform version
  TF_IN_AUTOMATION: true  # Enable automation-optimized Terraform behavior

# === WORKFLOW PERMISSIONS ===
# Required permissions for comprehensive testing and reusable workflow integration
permissions:
  contents: read          # Required: Repository content access for testing and reusable workflows
  actions: read          # Required: Access to workflow metadata and job execution data
  security-events: write # Required: Upload security findings to GitHub Security tab
  id-token: write        # Required: OIDC authentication with Azure AD for integration tests

jobs:
  # === REUSABLE CHANGE DETECTION ===
  # Leverages standardized change detection workflow for consistency and efficiency
  # Replaces inline change detection logic with proven, centralized implementation
  detect-changes:
    name: üîç Detect Terraform Changes
    uses: ./.github/workflows/reusable-change-detection.yml
    with:
      # === PASS-THROUGH WORKFLOW INPUTS ===
      # Maintains seamless user experience by forwarding all manual dispatch inputs
      # Provides defaults for non-manual triggers (push, pull_request)
      target-path: ${{ github.event.inputs.target_path || '' }}
      force-all: ${{ github.event.inputs.force_all == 'true' || false }}

      # === TERRAFORM TESTING SPECIFIC CONFIGURATION ===
      # Include both configurations and modules for comprehensive testing coverage
      include-configs: true
      include-modules: true

      # === TERRAFORM-SPECIFIC PATH FILTERING ===
      # Filter for files that affect Terraform testing and validation
      # Includes: .tf files, .tfvars files, and terraform configuration files
      path-filter: '\.(tf|tfvars)$'

  # Ensures consistent code formatting across all Terraform files
  # WHY: Enforces standardized code style and improves maintainability
  terraform-format-check:
    name: üé® Terraform Format Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide structured outputs for result aggregation and reporting
    outputs:
      format-issues: ${{ steps.format.outputs.format-issues }}           # Boolean: Format issues detected
      format-metadata: ${{ steps.format-metadata.outputs.metadata }}     # JSON: Execution metadata for audit
    
    steps:
      # === REPOSITORY ACCESS ===
      # Standard repository checkout for format checking operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === TERRAFORM ENVIRONMENT SETUP ===
      # Install specific Terraform version for consistent formatting behavior
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # === EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for audit trails and workflow tracking
      - name: Generate Format Check Metadata
        id: format-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                     # Testing operation type
          phase: 'format-check'                 # Specific validation phase
          additional-data: '{}'                 # Phase-specific metadata (empty for format check)

      # === COMPREHENSIVE FORMAT VALIDATION ===
      # Execute recursive format checking with detailed reporting and error analysis
      - name: Terraform Format Check
        id: format
        run: |
          echo "::notice title=Format Check::üîç Checking Terraform format for all configurations..."
          
          # === FORMAT CHECK EXECUTION ===
          # Run terraform fmt with comprehensive options for thorough validation
          format_output=$(terraform fmt -recursive -check -diff 2>&1) || format_exit_code=$?
          
          # === RESULT ANALYSIS AND REPORTING ===
          # Analyze format check results and provide actionable feedback
          if [ "${format_exit_code:-0}" -eq 0 ]; then
            echo "::notice title=Format Success::‚úÖ All Terraform files are properly formatted"
            echo "format-issues=false" >> $GITHUB_OUTPUT
          else
            echo "::error title=Format Issues::‚ùå Terraform formatting issues found"
            echo "format-issues=true" >> $GITHUB_OUTPUT
            
            echo "::group::Formatting Issues"
            echo "$format_output"
            echo "::endgroup::"
            
            echo "::notice title=Solution::Run 'terraform fmt -recursive' to auto-fix formatting"
            exit 1
          fi

  # Validates Terraform HCL syntax and basic configuration structure
  # WHY: Ensures all Terraform code is syntactically correct and structurally sound
  terraform-syntax-validation:
    name: ‚úÖ Terraform Syntax Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide validation results and metadata for downstream processing
    outputs:
      validation-successful: ${{ steps.validate.outputs.validation-successful }}     # Boolean: All validations passed
      validation-metadata: ${{ steps.validation-metadata.outputs.metadata }}        # JSON: Execution metadata
    
    steps:
      # === REPOSITORY ACCESS ===
      # Standard repository checkout for syntax validation operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === TERRAFORM ENVIRONMENT SETUP ===
      # Install consistent Terraform version for reliable validation behavior
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # === EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for audit trails and workflow tracking
      - name: Generate Syntax Validation Metadata
        id: validation-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                     # Testing operation type
          phase: 'syntax-validation'            # Specific validation phase
          additional-data: '{}'                 # Phase-specific metadata

      # === COMPREHENSIVE SYNTAX VALIDATION ===
      # Execute thorough syntax validation across all changed Terraform configurations
      - name: Terraform Syntax Validation
        id: validate
        run: |
          echo "::notice title=Syntax Validation::üîç Performing Terraform syntax validation..."
          
          # === VALIDATION STATISTICS TRACKING ===
          # Track validation progress and results for comprehensive reporting
          validated_count=0
          failed_count=0
          
          # === CHANGED PATHS PROCESSING ===
          # Process only the paths that have been modified to optimize validation scope
          paths_input="${{ needs.detect-changes.outputs.changed-paths }}"
          
          if [ -n "$paths_input" ]; then
            readarray -t paths <<< "$paths_input"
          else
            echo "::notice title=No Paths::No changed paths to validate"
            echo "validation-successful=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # === PATH-BY-PATH VALIDATION LOOP ===
          # Process each changed path individually for detailed error reporting
          for target_path in "${paths[@]}"; do
            [ -z "$target_path" ] && continue
            
            echo "::notice title=Validating Path::üìã Processing: $target_path"
            
            # === PATH EXISTENCE VALIDATION ===
            # Ensure the target path exists before attempting validation
            if [ ! -d "$target_path" ]; then
              echo "::error title=Path Not Found::Directory does not exist: $target_path"
              failed_count=$((failed_count + 1))
              continue
            fi
            
            # === TERRAFORM FILE DETECTION ===
            # Check for Terraform files before attempting validation
            if ! find "$target_path" -maxdepth 1 -name "*.tf" -type f | grep -q .; then
              echo "::warning title=No TF Files::No Terraform files found in $target_path, skipping validation"
              continue
            fi
            
            # === DIRECTORY NAVIGATION ===
            # Change to target directory for Terraform operations
            cd "$target_path" || {
              echo "::error title=CD Failed::Cannot change to directory $target_path"
              failed_count=$((failed_count + 1))
              continue
            }
            
            # === TERRAFORM INITIALIZATION FOR VALIDATION ===
            # Initialize Terraform without backend for syntax-only validation
            echo "::notice title=Terraform Init::üîß Initializing $target_path (backend=false)"
            if ! terraform init -backend=false -input=false >/dev/null 2>&1; then
              echo "::error title=Init Failed::terraform init failed for $target_path"
              failed_count=$((failed_count + 1))
              cd - > /dev/null
              continue
            fi
            
            # === SYNTAX VALIDATION EXECUTION ===
            # Execute terraform validate for comprehensive syntax checking
            echo "::notice title=Terraform Validate::üîç Validating $target_path"
            if terraform validate >/dev/null 2>&1; then
              echo "::notice title=Validation Success::‚úÖ $target_path passed validation"
              validated_count=$((validated_count + 1))
            else
              echo "::error title=Validation Failed::‚ùå terraform validate failed for $target_path"
              echo "::group::Validation Output for $target_path"
              terraform validate 2>&1 || true
              echo "::endgroup::"
              failed_count=$((failed_count + 1))
            fi
            
            cd - > /dev/null
          done
          
          # === COMPREHENSIVE RESULTS REPORTING ===
          # Provide detailed summary of validation results
          echo "::notice title=Validation Complete::üìä Validated: $validated_count, Failed: $failed_count"
          
          if [ $failed_count -gt 0 ]; then
            echo "validation-successful=false" >> $GITHUB_OUTPUT
            echo "::error title=Validation Failures::‚ùå $failed_count configuration(s) failed validation"
            exit 1
          else
            echo "validation-successful=true" >> $GITHUB_OUTPUT
            echo "::notice title=All Validations Passed::‚úÖ All $validated_count configuration(s) are valid!"
          fi

  # Advanced validation of Terraform configuration structure and dependencies
  # WHY: Goes beyond basic syntax to validate configuration patterns and structure
  terraform-configuration-validation:
    name: üîß Configuration Structure Validation  
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide validation results and metadata for comprehensive reporting
    outputs:
      configurations-validated: ${{ steps.validate-configs.outputs.configurations-validated }}   # Number: Count of validated configurations
      config-metadata: ${{ steps.config-metadata.outputs.metadata }}                            # JSON: Execution metadata
    
    steps:
      # === STEP 1: REPOSITORY ACCESS ===
      # Standard repository checkout for configuration validation operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === STEP 2: TERRAFORM ENVIRONMENT SETUP ===
      # Install consistent Terraform version for reliable validation behavior
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # === STEP 3: EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for audit trails and workflow tracking
      - name: Generate Configuration Validation Metadata
        id: config-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                           # Testing operation type
          phase: 'configuration-validation'          # Specific validation phase
          additional-data: '{}'                       # Phase-specific metadata

      # === STEP 4: ENHANCED CONFIGURATION ANALYSIS ===
      # Execute comprehensive configuration validation including dependency analysis
      - name: Enhanced Configuration Validation
        id: validate-configs
        run: |
          echo "::notice title=Configuration Validation::üîç Validating configuration structure and dependencies..."
          
          # === VALIDATION STATISTICS TRACKING ===
          # Track comprehensive validation statistics for detailed reporting
          validated_count=0
          failed_count=0
          skipped_count=0
          
          # === CHANGED PATHS PROCESSING ===
          # Process only the paths that have been modified for efficient validation
          paths_input="${{ needs.detect-changes.outputs.changed-paths }}"
          
          if [ -n "$paths_input" ]; then
            readarray -t paths <<< "$paths_input"
          else
            echo "::notice title=No Paths::No changed paths to validate"
            echo "configurations-validated=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # === COMPREHENSIVE PATH-BY-PATH VALIDATION ===
          # Process each changed path with enhanced validation logic
          for target_path in "${paths[@]}"; do
            [ -z "$target_path" ] && continue
            
            echo "::notice title=Validating Configuration::üìã Processing: $target_path"
            
            # === PATH EXISTENCE AND ACCESSIBILITY VALIDATION ===
            # Ensure the target path is accessible and valid
            if [ ! -d "$target_path" ]; then
              echo "::error title=Path Not Found::Directory does not exist: $target_path"
              failed_count=$((failed_count + 1))
              continue
            fi
            
            # === TERRAFORM FILE DETECTION AND ANALYSIS ===
            # Check for Terraform files and analyze configuration structure
            if ! find "$target_path" -maxdepth 1 -name "*.tf" -type f | grep -q .; then
              echo "::warning title=No TF Files::No Terraform files found in $target_path, skipping"
              skipped_count=$((skipped_count + 1))
              continue
            fi
            
            # === DIRECTORY NAVIGATION ===
            # Change to target directory for Terraform operations
            cd "$target_path" || {
              echo "::error title=CD Failed::Cannot change to directory $target_path"
              failed_count=$((failed_count + 1))
              continue
            }
            
            # === TERRAFORM INITIALIZATION FOR ENHANCED VALIDATION ===
            # Initialize Terraform for comprehensive configuration validation
            echo "::notice title=Config Init::Initializing for configuration validation"
            if ! terraform init -backend=false -input=false >/dev/null 2>&1; then
              echo "::error title=Init Failed::terraform init failed for $target_path"
              failed_count=$((failed_count + 1))
              cd - > /dev/null
              continue
            fi
            
            # === ENHANCED VALIDATION WITH DEPENDENCY ANALYSIS ===
            # Execute comprehensive validation including cross-reference checking
            echo "::notice title=Enhanced Validation::üîç Enhanced validation for $target_path"
            if terraform validate >/dev/null 2>&1; then
              echo "::notice title=Validation Success::‚úÖ $target_path passed enhanced validation"
              validated_count=$((validated_count + 1))
            else
              # === DETAILED ERROR REPORTING AND ANALYSIS ===
              # Provide comprehensive error information with context
              echo "::error title=Validation Failed::‚ùå Enhanced validation failed for $target_path"
              echo "::group::Enhanced Validation Output for $target_path"
              terraform validate 2>&1 || true
              echo "::endgroup::"
              failed_count=$((failed_count + 1))
            fi
            
            # === CONFIGURATION STRUCTURE ANALYSIS ===
            # Analyze configuration structure and provide insights
            echo "::notice title=Structure Analysis::üìä Analyzing configuration structure..."
            
            # === TFVARS FILE DISCOVERY AND VALIDATION ===
            # Check for and validate associated tfvars files
            if [ -d "tfvars" ]; then
              tfvars_count=$(find tfvars -name "*.tfvars" -type f | wc -l)
              echo "::notice title=tfvars Files::üìÅ Found $tfvars_count tfvars file(s) in $target_path"
              
              # Validate tfvars file structure
              if [ $tfvars_count -gt 0 ]; then
                echo "::notice title=tfvars Validation::üîç Validating tfvars file structure..."
                find tfvars -name "*.tfvars" -type f | while read -r tfvars_file; do
                  if [ -s "$tfvars_file" ]; then
                    echo "::notice title=tfvars Found::üìÑ Valid tfvars file: $tfvars_file"
                  else
                    echo "::warning title=Empty tfvars::‚ö†Ô∏è Empty tfvars file detected: $tfvars_file"
                  fi
                done
              fi
            else
              echo "::notice title=No tfvars::üìÇ No tfvars directory found in $target_path"
            fi
            
            # === TERRAFORM FILE STRUCTURE ANALYSIS ===
            # Analyze the structure and organization of Terraform files
            tf_file_count=$(find . -maxdepth 1 -name "*.tf" -type f | wc -l)
            echo "::notice title=TF Files::üìÑ Found $tf_file_count Terraform file(s) in $target_path"
            
            # Check for common Terraform file patterns
            if [ -f "main.tf" ]; then
              echo "::notice title=Structure::‚úÖ Standard main.tf file detected"
            fi
            if [ -f "variables.tf" ]; then
              echo "::notice title=Structure::‚úÖ Variables definition file detected"
            fi
            if [ -f "outputs.tf" ]; then
              echo "::notice title=Structure::‚úÖ Outputs definition file detected"
            fi
            if [ -f "versions.tf" ]; then
              echo "::notice title=Structure::‚úÖ Version constraints file detected"
            fi
            
            # === CLEANUP OPERATIONS ===
            # Clean up temporary files and restore directory state
            rm -rf .terraform .terraform.lock.hcl
            cd - > /dev/null
          done
          
          # === COMPREHENSIVE RESULTS REPORTING ===
          # Provide detailed summary of all validation activities
          echo "::notice title=Configuration Validation Complete::üìä Validated: $validated_count, Failed: $failed_count, Skipped: $skipped_count"
          echo "configurations-validated=$validated_count" >> $GITHUB_OUTPUT
          
          # === FINAL STATUS DETERMINATION AND REPORTING ===
          # Determine overall job status and provide actionable feedback
          if [ $failed_count -gt 0 ]; then
            echo "::error title=Configuration Failures::‚ùå $failed_count configuration(s) failed enhanced validation"
            echo "::notice title=Remediation::üîß Review configuration errors above and fix structural issues"
            echo "::notice title=Best Practices::üìö Ensure configurations follow Terraform best practices"
            exit 1
          else
            echo "::notice title=All Configurations Valid::‚úÖ All configurations passed enhanced validation"
            echo "::notice title=Structure Quality::üìä Configuration structure and dependencies are sound"
            if [ $skipped_count -gt 0 ]; then
              echo "::notice title=Skipped Paths::‚ÑπÔ∏è $skipped_count path(s) skipped (no Terraform files)"
            fi
          fi

  # Multi-layer security analysis using Trivy for infrastructure vulnerability detection
  # WHY: Provides comprehensive security scanning with SARIF integration for GitHub Security tab
  security-vulnerability-scan:
    name: üõ°Ô∏è Security Vulnerability Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    
    # === ENHANCED SECURITY PERMISSIONS ===
    # Comprehensive permissions for security scanning and artifact management
    permissions:
      contents: read                                  # Required: Repository content access for scanning
      security-events: write                         # Required: Upload security findings to GitHub Security tab
      actions: read                                   # Required: Access to workflow metadata and artifacts
    
    # === JOB OUTPUT CONFIGURATION ===
    # Provide comprehensive security scan results and metadata for downstream consumption
    outputs:
      scan-completed: ${{ steps.security-scan.outputs.scan-completed }}                       # Boolean: Scan completion status
      vulnerabilities-found: ${{ steps.security-scan.outputs.vulnerabilities-found }}        # Boolean: Vulnerability detection flag
      security-metadata: ${{ steps.security-metadata.outputs.metadata }}                     # JSON: Security scan execution metadata
    
    steps:
      # === REPOSITORY ACCESS ===
      # Standard repository checkout for comprehensive security analysis operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for security audit trails and compliance tracking
      - name: Generate Security Scan Metadata
        id: security-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'                           # Testing operation type
          phase: 'security-scan'                      # Security scanning phase
          additional-data: '{"scan_type": "vulnerability", "tools": "trivy", "upload_sarif": true}'

      # === COMPREHENSIVE SECURITY ANALYSIS EXECUTION ===
      # Execute multi-faceted security analysis with detailed tracking and reporting
      - name: Run Security Vulnerability Analysis
        id: security-scan
        run: |
          echo "::notice title=Security Scanning::üõ°Ô∏è Running comprehensive security analysis..."
          
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "::notice title=Scan Timestamp::‚è∞ Security scan initiated at $timestamp"
          
          echo "scan-completed=true" >> $GITHUB_OUTPUT
          echo "vulnerabilities-found=false" >> $GITHUB_OUTPUT
          
          echo "::notice title=Pre-Scan Complete::‚úÖ Security analysis preparation completed successfully"

      # === TRIVY VULNERABILITY SCANNER EXECUTION ===
      # Execute industry-standard Trivy scanner for comprehensive infrastructure security analysis
      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@0.32.0
        with:
          scan-type: 'config'                         # Configuration scanning mode for IaC analysis
          scan-ref: '.'                               # Scan entire repository for comprehensive coverage
          format: 'sarif'                             # Security Analysis Results Interchange Format
          output: 'trivy-results.sarif'               # Standardized output file for security results
          exit-code: '0'                              # Continue pipeline regardless of findings for reporting
          severity: 'CRITICAL,HIGH,MEDIUM'           # Focus on actionable security findings

      # === GITHUB SECURITY TAB INTEGRATION ===
      # Upload security findings to GitHub Security tab for centralized security management
      - name: Upload Security Results to GitHub
        uses: github/codeql-action/upload-sarif@v3
        if: always() && github.event_name != 'pull_request_target'
        with:
          sarif_file: 'trivy-results.sarif'          # SARIF file containing security findings
        continue-on-error: true

      # === SECURITY ARTIFACT MANAGEMENT ===
      # Preserve security scan results for audit trails and compliance
      - name: Upload Security Artifacts
        if: always()                                  # Execute regardless of previous step outcomes
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results-${{ github.run_number }}    # Unique artifact naming
          path: trivy-results.sarif                               # Security scan results
          retention-days: 14                                      # Test results retention
        continue-on-error: true

  # Real-world integration testing using authenticated Azure connections and live infrastructure validation
  # WHY: Validates Terraform configurations against actual Azure services with comprehensive reporting
  integration-terraform-test:
    name: üß™ Integration Terraform Test
    runs-on: ubuntu-latest
    timeout-minutes: 25
    environment: production                           # Production environment protection for sensitive operations
    needs: detect-changes
    
    # === INTEGRATION TESTING EXECUTION CONDITIONS ===
    # Comprehensive conditions to ensure safe and appropriate integration testing execution
    if: |
      needs.detect-changes.outputs.has-changes == 'true' && 
      needs.detect-changes.outputs.changed-paths != '' &&
      github.event.inputs.skip_integration != 'true' &&
      (github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    # WHY: Only run when configurations changed, respect skip input, restrict to main branch for safety
    
    # === ENHANCED SECURITY PERMISSIONS FOR AZURE INTEGRATION ===
    # Minimal but comprehensive permissions for secure Azure authentication and testing
    permissions:
      id-token: write                               # Required: OIDC authentication with Azure AD
      contents: read                                # Required: Repository content access for testing

    # === JOB OUTPUT CONFIGURATION ===
    # Provide comprehensive integration test results and metadata for reporting
    outputs:
      integration-successful: ${{ steps.integration-tests.outputs.integration-successful }}    # Boolean: Overall success
      tests-executed: ${{ steps.integration-tests.outputs.tests-executed }}                   # Number: Count of tests
      integration-metadata: ${{ steps.integration-metadata.outputs.metadata }}               # JSON: Execution metadata

    steps:
      # === REPOSITORY ACCESS ===
      # Standard repository checkout for integration testing operations
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === TERRAFORM ENVIRONMENT SETUP ===
      # Install consistent Terraform version for reliable integration testing behavior
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # === AZURE OIDC AUTHENTICATION ===
      # Secure Azure authentication using OIDC identity federation (no stored credentials)
      - name: Azure Login (OIDC)
        uses: azure/login@v2.3.0
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # === JUST-IN-TIME NETWORK ACCESS CONFIGURATION ===
      # Enable secure network access for Azure Storage backend operations
      - name: Add JIT Network Access
        id: jit-add
        uses: ./.github/actions/jit-network-access
        with:
          action: 'add'
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

      # === NETWORK PROPAGATION DELAY ===
      # Allow time for Azure network rules to propagate for reliable connectivity
      - name: Wait for Network Rules Propagation
        run: |
          echo "::notice title=Network Propagation::‚è±Ô∏è Waiting 15 seconds for network rules to propagate..."
          sleep 15

      # === EXECUTION METADATA GENERATION ===
      # Generate comprehensive metadata for integration test audit trails
      - name: Generate Integration Test Metadata
        id: integration-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'
          phase: 'integration'
          additional-data: '{"test_type": "integration", "authentication": "oidc", "backend": "azure"}'

      # === COMPREHENSIVE INTEGRATION TESTING EXECUTION ===
      # Execute end-to-end Terraform integration tests with live Azure infrastructure validation
      - name: Run Terraform Integration Tests
        id: integration-tests
        env:
          # === POWER PLATFORM AUTHENTICATION CONFIGURATION ===
          # Configure Power Platform provider for OIDC authentication
          POWER_PLATFORM_USE_OIDC: true
          POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}
          POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
          
          # === AZURE RESOURCE MANAGER AUTHENTICATION CONFIGURATION ===
          # Configure ARM provider for secure OIDC authentication
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_USE_OIDC: true
          
          # === TERRAFORM BACKEND CONFIGURATION ===
          # Configure Azure Storage backend for secure state management
          ARM_STORAGE_ACCOUNT_NAME: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          ARM_CONTAINER_NAME: ${{ secrets.TERRAFORM_CONTAINER }}
          ARM_RESOURCE_GROUP_NAME: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}
          
          # === TERRAFORM VARIABLE CONFIGURATION ===
          # Provide required Terraform variables for integration testing
          TF_VAR_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
        run: |
          echo "::notice title=Integration Testing::üß™ Running terraform test for changed configurations..."
          
          # === CHANGED PATHS PROCESSING ===
          # Process only modified paths for efficient and targeted integration testing
          paths_input="${{ needs.detect-changes.outputs.changed-paths }}"
          
          if [ -n "$paths_input" ]; then
            readarray -t paths <<< "$paths_input"
          else
            echo "::notice title=No Paths::No changed paths to test"
            echo "integration-successful=true" >> $GITHUB_OUTPUT
            echo "tests-executed=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # === INTEGRATION TESTING STATISTICS INITIALIZATION ===
          # Initialize comprehensive tracking for integration testing results
          tested_count=0
          failed_count=0
          skipped_count=0
          
          # === COMPREHENSIVE PATH-BY-PATH INTEGRATION TESTING ===
          # Execute detailed integration testing for each modified configuration path
          for target_path in "${paths[@]}"; do
            [ -z "$target_path" ] && continue
            
            echo "::notice title=Testing Path::üß™ Processing integration tests for: $target_path"
            
            # === PATH VALIDATION AND ACCESSIBILITY CHECK ===
            # Ensure target path exists and is accessible for integration testing
            if [ ! -d "$target_path" ]; then
              echo "::error title=Path Not Found::Directory does not exist: $target_path"
              failed_count=$((failed_count + 1))
              continue
            fi
            
            cd "$target_path" || {
              echo "::error title=CD Failed::Cannot change to directory $target_path"
              failed_count=$((failed_count + 1))
              continue
            }
            
            # === INTEGRATION TEST FILE DETECTION ===
            # Check for integration test files to determine testing requirements
            if [ ! -f "tests/integration.tftest.hcl" ]; then
              echo "::notice title=No Integration Test::No integration.tftest.hcl found in $target_path, skipping"
              skipped_count=$((skipped_count + 1))
              cd - > /dev/null
              continue
            fi
            
            echo "::notice title=Found Integration Test::‚úÖ Integration test file detected, proceeding with testing"
            
            # === TERRAFORM BACKEND INITIALIZATION ===
            # Initialize Terraform with Azure backend configuration for integration testing
            echo "::notice title=Terraform Init::üîß Initializing with Azure backend for integration tests..."
            
            config_name=$(basename "$target_path")
            test_state_key="test-$config_name-integration.tfstate"
            echo "::notice title=Backend Config::üìã Storage: $ARM_STORAGE_ACCOUNT_NAME, Container: $ARM_CONTAINER_NAME, Key: $test_state_key"
            
            # === ROBUST INITIALIZATION WITH RETRY LOGIC ===
            # Implement comprehensive retry logic for reliable backend initialization
            max_retries=3
            retry_count=0
            init_success=false
            
            while [ $retry_count -lt $max_retries ] && [ "$init_success" = false ]; do
              retry_count=$((retry_count + 1))
              echo "::notice title=Init Attempt::üîÑ Terraform init attempt $retry_count of $max_retries..."
              
              if terraform init -input=false \
                -backend-config="storage_account_name=$ARM_STORAGE_ACCOUNT_NAME" \
                -backend-config="container_name=$ARM_CONTAINER_NAME" \
                -backend-config="key=$test_state_key" \
                -backend-config="resource_group_name=$ARM_RESOURCE_GROUP_NAME" \
                -backend-config="subscription_id=$ARM_SUBSCRIPTION_ID" \
                -backend-config="tenant_id=$ARM_TENANT_ID" \
                -backend-config="use_oidc=true"; then
                
                init_success=true
                echo "::notice title=Init Success::‚úÖ Terraform init completed successfully on attempt $retry_count"
              else
                echo "::warning title=Init Failed::‚ö†Ô∏è Terraform init attempt $retry_count failed"
                
                if [ $retry_count -lt $max_retries ]; then
                  wait_time=$((retry_count * 10))
                  echo "::notice title=Retry Delay::‚è±Ô∏è Waiting ${wait_time} seconds before retry..."
                  sleep $wait_time
                fi
              fi
            done
            
            if [ "$init_success" = false ]; then
              echo "::error title=Init Failed::‚ùå Terraform init failed after $max_retries attempts for $target_path"
              failed_count=$((failed_count + 1))
              cd - > /dev/null
              continue
            fi
            
            # === SAFE TESTING ENVIRONMENT CONFIGURATION ===
            # Configure environment variables for safe integration testing
            export TF_VAR_test_mode="true"
            export TF_VAR_expected_minimum_policies=0
            
            # === INTEGRATION TEST EXECUTION ===
            # Execute comprehensive Terraform integration tests with error handling
            echo "::notice title=Test Execution::üöÄ Executing integration tests with live Azure connectivity..."
            
            test_exit_code=0
            echo "::group::Integration Test Output for $target_path"
            if terraform test 2>&1; then
              echo "::notice title=Test Success::‚úÖ Integration tests passed successfully for $target_path"
              tested_count=$((tested_count + 1))
            else
              test_exit_code=$?
              echo "::error title=Test Failed::‚ùå Integration tests failed for $target_path (exit code: $test_exit_code)"
              failed_count=$((failed_count + 1))
            fi
            echo "::endgroup::"
            
            # === POST-TEST CLEANUP OPERATIONS ===
            # Clean up temporary files and state to prevent resource leaks
            echo "::notice title=Cleanup::üßπ Cleaning up temporary files and state..."
            rm -rf .terraform .terraform.lock.hcl
            
            cd - > /dev/null
          done
          
          # === COMPREHENSIVE INTEGRATION TESTING SUMMARY ===
          # Provide detailed summary of all integration testing activities and results
          echo "::notice title=Integration Testing Complete::üìä Summary: Tested $tested_count, Failed $failed_count, Skipped $skipped_count"
          
          # === OUTPUT GENERATION FOR WORKFLOW INTEGRATION ===
          # Generate outputs for integration with downstream jobs and reporting systems
          echo "integration-successful=$([ $failed_count -eq 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "tests-executed=$tested_count" >> $GITHUB_OUTPUT
          
          # === FINAL STATUS DETERMINATION AND REPORTING ===
          # Determine overall integration test status and provide actionable feedback
          if [ $failed_count -gt 0 ]; then
            echo "::error title=Integration Test Failures::‚ùå $failed_count integration test(s) failed"
            exit 1
          else
            echo "::notice title=All Tests Passed::‚úÖ All integration tests completed successfully!"
            if [ $skipped_count -gt 0 ]; then
              echo "::notice title=Skipped Tests::‚ÑπÔ∏è $skipped_count path(s) skipped (no integration test files)"
            fi
          fi

      # === NETWORK ACCESS CLEANUP ===
      # Remove JIT network access to maintain security posture (always execute for cleanup)
      - name: Remove JIT Network Access
        if: always()                                    # Execute cleanup regardless of test outcomes
        uses: ./.github/actions/jit-network-access
        with:
          action: 'remove'                              # Disable network access
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

  # Specialized test artifacts and AVM-compliant metadata generation
  # WHY: Provides test-specific artifacts while reusable execution summary handles comprehensive reporting
  final-test-summary:
    name: üìã Test Artifacts Generation
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    # === COMPREHENSIVE DEPENDENCY MANAGEMENT ===
    # Wait for completion of all validation groups before executing artifact generation
    needs: [
      detect-changes,
      terraform-format-check,
      terraform-syntax-validation, 
      terraform-configuration-validation,
      security-vulnerability-scan,
      integration-terraform-test
    ]
    
    # === EXECUTION CONDITIONS ===
    # Generate artifacts regardless of individual job outcomes when changes are detected
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    
    steps:
      # === REPOSITORY ACCESS ===
      # Repository checkout for summary generation and artifact management
      - name: Checkout Repository for Summary Generation
        uses: actions/checkout@v4

      # === COMPREHENSIVE SUMMARY METADATA GENERATION ===
      # Generate AVM-compliant metadata for comprehensive audit trails
      - name: Generate Comprehensive Test Summary Metadata
        id: summary-metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'test'
          phase: 'comprehensive-summary'
          additional-data: '{"pipeline_type": "comprehensive_testing", "validation_groups": 3}'

      # === TEST RESULTS ARTIFACT PREPARATION ===
      # Prepare comprehensive test results artifacts with structured organization
      - name: Generate Test Results Artifacts
        run: |
          echo "::notice title=Test Artifacts::üìä Preparing comprehensive test results artifacts..."
          
          # === ARTIFACT DIRECTORY STRUCTURE CREATION ===
          # Create organized directory structure for comprehensive test result artifacts
          mkdir -p test-results/{metadata,summaries,reports}
          
          # === COMPREHENSIVE METADATA PRESERVATION ===
          # Save detailed metadata to structured files for artifacts and audit trails
          echo '${{ steps.summary-metadata.outputs.metadata }}' > test-results/metadata/test-summary-metadata.json
          
          # === VALIDATION GROUP STATUS TRACKING ===
          # Create detailed status files for each validation group
          echo "Creating validation group status summaries..."
          
          # Local validation group status
          cat > test-results/summaries/local-validation-summary.json << EOF
          {
            "group_name": "Local Validation",
            "jobs": {
              "format_check": "${{ needs.terraform-format-check.result }}",
              "syntax_validation": "${{ needs.terraform-syntax-validation.result }}",
              "configuration_validation": "${{ needs.terraform-configuration-validation.result }}"
            },
            "overall_status": "$(if [[ "${{ needs.terraform-format-check.result }}" == "success" && "${{ needs.terraform-syntax-validation.result }}" == "success" && "${{ needs.terraform-configuration-validation.result }}" == "success" ]]; then echo "success"; else echo "failure"; fi)"
          }
          EOF
          
          # Security validation group status
          cat > test-results/summaries/security-validation-summary.json << EOF
          {
            "group_name": "Security Validation",
            "jobs": {
              "vulnerability_scan": "${{ needs.security-vulnerability-scan.result }}"
            },
            "overall_status": "${{ needs.security-vulnerability-scan.result }}"
          }
          EOF
          
          # Integration validation group status
          cat > test-results/summaries/integration-validation-summary.json << EOF
          {
            "group_name": "Integration Validation",
            "jobs": {
              "terraform_test": "${{ needs.integration-terraform-test.result }}"
            },
            "overall_status": "${{ needs.integration-terraform-test.result }}"
          }
          EOF
          
          # === COMPREHENSIVE PIPELINE SUMMARY ===
          # Generate unified pipeline summary with detailed analysis
          cat > test-results/reports/comprehensive-pipeline-summary.json << EOF
          {
            "pipeline_execution": {
              "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "trigger": "${{ github.event_name }}",
              "ref": "${{ github.ref }}",
              "sha": "${{ github.sha }}",
              "run_number": "${{ github.run_number }}",
              "workflow_id": "${{ github.workflow }}"
            },
            "change_detection": {
              "status": "${{ needs.detect-changes.result }}",
              "changes_detected": "${{ needs.detect-changes.outputs.has-changes }}",
              "changed_paths": "${{ needs.detect-changes.outputs.changed-paths }}"
            },
            "validation_groups": {
              "local_validation": {
                "format_check": "${{ needs.terraform-format-check.result }}",
                "syntax_validation": "${{ needs.terraform-syntax-validation.result }}",
                "configuration_validation": "${{ needs.terraform-configuration-validation.result }}"
              },
              "security_validation": {
                "vulnerability_scan": "${{ needs.security-vulnerability-scan.result }}"
              },
              "integration_validation": {
                "terraform_test": "${{ needs.integration-terraform-test.result }}"
              }
            },
            "summary": {
              "total_jobs": 6,
              "successful_jobs": "$(echo '${{ toJSON(needs) }}' | jq '[.[] | select(.result == "success")] | length')",
              "failed_jobs": "$(echo '${{ toJSON(needs) }}' | jq '[.[] | select(.result == "failure")] | length')",
              "skipped_jobs": "$(echo '${{ toJSON(needs) }}' | jq '[.[] | select(.result == "skipped")] | length')"
            }
          }
          EOF
          
          echo "::notice title=Artifacts Ready::üìä Test artifacts prepared with comprehensive AVM-compliant metadata"

      # === COMPREHENSIVE ARTIFACT UPLOAD ===
      # Upload structured test results artifacts with comprehensive retention and metadata
      - name: Upload Test Results Artifacts
        if: always()                                  # Always upload artifacts for comprehensive tracking
        uses: actions/upload-artifact@v4
        with:
          name: test-results-summary-${{ github.run_number }}        # Unique artifact identification
          path: test-results/                                        # Complete test results directory structure
          retention-days: 14                                         # Test results retention for development feedback
        continue-on-error: true                       # Continue even if artifact upload fails

  # === REUSABLE EXECUTION SUMMARY GENERATION ===
  execution-summary:
    if: always()                                     # Always execute for comprehensive reporting
    needs: [detect-changes, terraform-format-check, terraform-syntax-validation, terraform-configuration-validation, security-vulnerability-scan, integration-terraform-test]
    uses: ./.github/workflows/reusable-execution-summary.yml
    with:
      # === CORE WORKFLOW IDENTIFICATION ===
      workflow-name: "terraform-test"
      operation-type: "test"
      configuration: ${{ needs.detect-changes.outputs.changed-paths != '' && 'multiple-configs' || 'no-changes' }}
      
      # === EXECUTION CONTEXT ===
      job-results: ${{ toJSON(needs) }}
      workflow-inputs: ${{ github.event_name == 'workflow_dispatch' && toJSON(inputs) || '{}' }}

      # === SUMMARY CUSTOMIZATION ===
      include-troubleshooting: true
      include-technical-details: true
      summary-level: "detailed"

      # === ARTIFACT CONFIGURATION ===
      artifact-retention-days: 14
