# Terraform Plan and Apply Workflow for Power Platform Governance
# This workflow allows manual deployment of Terraform configurations for Power Platform resources
# It supports both plan-only operations and plan+apply operations based on user input

name: Terraform Plan and Apply

# Trigger: Manual workflow dispatch only
# Users can select which configuration to deploy and whether to apply changes
on:
  workflow_dispatch:
    inputs:
      configuration:
        description: 'Configuration to plan and apply'
        required: true
        type: choice
        options:
          - '02-dlp-policy'
          - '03-environment'
      tfvars_file:
        description: 'tfvars file name without extension (e.g., dlp-finance, env-production)'
        required: true
        type: string
      apply:
        description: 'Apply the configuration after plan'
        required: true
        type: boolean
        default: false

# Dynamic run name that shows the configuration, tfvars file, and whether apply is enabled
run-name: Terraform Plan${{ github.event.inputs.apply == 'true' && ' and Apply' || '' }} for ${{ github.event.inputs.configuration }} (${{ github.event.inputs.tfvars_file }}) by @${{ github.actor }}

# Required permissions for OIDC authentication with Azure and Power Platform
permissions:
  id-token: write   # Required for GitHub OIDC token generation
  contents: write   # Required for repository checkout and committing generated docs

# Environment variables for Power Platform OIDC authentication
# These are set at workflow level to avoid duplication across jobs
env:
  POWER_PLATFORM_USE_OIDC: true
  POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}
  POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
  # GitHub automatically provides these OIDC variables when id-token permission is granted
  POWER_PLATFORM_OIDC_REQUEST_URI: ${{ env.ACTIONS_ID_TOKEN_REQUEST_URL }}
  POWER_PLATFORM_OIDC_TOKEN: ${{ env.ACTIONS_ID_TOKEN_REQUEST_TOKEN }}

jobs:
  # Job 1: Plan Phase
  # Always runs to validate and plan the Terraform configuration
  # Creates execution plans and uploads them as artifacts for potential apply phase
  terraform-plan:
    runs-on: ubuntu-latest
    
    # Output values that can be used by dependent jobs
    outputs:
      plan-changed: ${{ steps.plan.outputs.changed }}              # Whether the plan has changes
      configuration: ${{ github.event.inputs.configuration }}     # Pass configuration to apply job
    
    steps:
    # Step 1: Checkout repository code
    - name: Checkout
      uses: actions/checkout@v4
    
    # Step 2: Authenticate with Azure using OIDC for backend state storage
    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    # Step 3: Install and configure Terraform CLI
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false    # Disable wrapper for better output handling
    
    # Step 4: Execute Terraform plan
    # This is the core step that initializes, validates, and plans the configuration
    - name: Terraform Plan
      id: plan
      run: |
        config="${{ github.event.inputs.configuration }}"
        
        if [ ! -d "configurations/$config" ]; then
          echo "::error title=Configuration Not Found::Configuration directory 'configurations/$config' does not exist. Please check the configuration name and ensure the directory exists."
          exit 1
        fi
        
        echo "::notice title=Planning Configuration::Starting Terraform plan for configuration: $config"
        cd "configurations/$config"
        
        # Initialize Terraform with Azure backend for state storage
        terraform init \
          -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TERRAFORM_CONTAINER }}" \
          -backend-config="key=$config.tfstate" \
          -backend-config="resource_group_name=${{ secrets.TERRAFORM_RESOURCE_GROUP }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
          -backend-config="use_oidc=true"
        
        # Validate Terraform configuration syntax and consistency
        terraform validate
        
        # Validate and locate the required tfvars file
        tfvars_file="${{ github.event.inputs.tfvars_file }}"
        tfvars_filename="$tfvars_file.tfvars"
        if [ -f "tfvars/$tfvars_filename" ]; then
          echo "::notice title=Using tfvars File::Using tfvars file: tfvars/$tfvars_filename"
          tfvars_path="tfvars/$tfvars_filename"
        else
          echo "::error title=tfvars File Not Found::Specified tfvars file 'tfvars/$tfvars_filename' does not exist in configuration '$config'. Please check the file name and ensure it exists."
          exit 1
        fi
        
        # Create execution plan with specified tfvars file
        # -detailed-exitcode: Exit 0 for no changes, 1 for error, 2 for changes
        # -out: Save plan to file for later apply
        # Load variables: root terraform.tfvars + selected configuration tfvars
        terraform plan -detailed-exitcode -out=tfplan-$config \
          -var-file="../../terraform.tfvars" \
          -var-file="$tfvars_path" || exit_code=$?
        
        # Handle different exit codes from terraform plan
        if [ $exit_code -eq 1 ]; then
          echo "::error title=Terraform Plan Failed::Terraform plan failed for configuration $config. Check the logs above for detailed error information."
          exit 1
        elif [ $exit_code -eq 2 ]; then
          echo "::notice title=Changes Detected::Terraform plan detected changes for configuration $config. The plan will be saved for potential apply."
          echo "changed=true" >> $GITHUB_OUTPUT
        else
          echo "::notice title=No Changes::Terraform plan shows no changes for configuration $config. Infrastructure is up to date."
          echo "changed=false" >> $GITHUB_OUTPUT
        fi
    
    # Step 5: Generate/Update Configuration Documentation
    # AVM requires up-to-date documentation generated by terraform-docs
    - name: Generate Configuration Documentation
      run: |
        config="${{ github.event.inputs.configuration }}"
        
        echo "Generating documentation for configuration: $config"
        cd "configurations/$config"
        
        # Install terraform-docs if not available
        if ! command -v terraform-docs &> /dev/null; then
          echo "::notice title=Installing terraform-docs::terraform-docs not found, installing version 0.20.0..."
          curl -sSLo terraform-docs.tar.gz https://github.com/terraform-docs/terraform-docs/releases/download/v0.20.0/terraform-docs-v0.20.0-linux-amd64.tar.gz
          tar -xzf terraform-docs.tar.gz
          sudo mv terraform-docs /usr/local/bin/
          rm terraform-docs.tar.gz
          echo "::notice title=Installation Complete::terraform-docs v0.20.0 installed successfully"
        fi
        
        # Generate documentation
        echo "::notice title=Generating Documentation::Creating README.md for configuration: $config"
        terraform-docs markdown table --output-file README.md .
        
        # Display generated content for verification
        echo "::group::Generated Documentation Preview"
        head -20 README.md
        echo "::endgroup::"
        
        cd - > /dev/null
    
    # Step 6: Commit generated documentation
    # Commit the updated README.md back to the repository
    - name: Commit Generated Documentation
      run: |
        config="${{ github.event.inputs.configuration }}"
        
        # Configure git
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        
        # Check if there are changes to commit
        if git diff --quiet "configurations/$config/README.md"; then
          echo "::notice title=Documentation Unchanged::No changes detected in documentation for $config, skipping commit"
        else
          echo "::notice title=Committing Documentation::Documentation has been updated, committing changes for $config..."
          git add "configurations/$config/README.md"
          git commit -m "docs: update documentation for $config configuration
          
          Auto-generated by terraform-docs via GitHub Actions"
          git push origin main
          echo "::notice title=Documentation Committed::✅ Documentation committed successfully for $config"
        fi
    
    # Step 7: Upload plan files as artifacts for the apply job
    # Only uploads if there are changes to apply
    - name: Upload Plans
      if: steps.plan.outputs.changed == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: tfplans-${{ github.run_number }}
        path: configurations/*/tfplan-*
        retention-days: 7    # Keep plans for 7 days for troubleshooting

  # Job 2: Apply Phase
  # Only runs if plan job succeeded, has changes, and user requested apply
  # Applies the previously created plan to make actual infrastructure changes
  terraform-apply:
    runs-on: ubuntu-latest
    needs: terraform-plan    # Depends on successful completion of plan job
    
    # Conditional execution: only run if all conditions are met
    if: |
      always() && 
      needs.terraform-plan.result == 'success' && 
      needs.terraform-plan.outputs.plan-changed == 'true' &&
      github.event.inputs.apply == 'true'
    
    steps:
    # Step 1: Checkout repository code (needed for accessing configuration files)
    - name: Checkout
      uses: actions/checkout@v4
    
    # Step 2: Authenticate with Azure using OIDC for backend state storage
    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    # Step 3: Install and configure Terraform CLI
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    # Step 4: Download the plan files created in the plan job
    - name: Download Plans
      uses: actions/download-artifact@v4
      with:
        name: tfplans-${{ github.run_number }}
        path: .
    
    # Step 5: Apply the Terraform plan
    # This step makes actual changes to the Power Platform infrastructure
    - name: Terraform Apply
      run: |
        config="${{ needs.terraform-plan.outputs.configuration }}"
        
        echo "::notice title=Applying Configuration::Starting Terraform apply for configuration: $config"
        cd "configurations/$config"
        
        # Re-initialize Terraform (required after downloading artifacts)
        terraform init \
          -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TERRAFORM_CONTAINER }}" \
          -backend-config="key=$config.tfstate" \
          -backend-config="resource_group_name=${{ secrets.TERRAFORM_RESOURCE_GROUP }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
          -backend-config="use_oidc=true"
        
        # Apply the previously created plan
        # -auto-approve: Skip interactive approval since we're using a pre-approved plan
        terraform apply -auto-approve "tfplan-$config"
        
        # Use the same tfvars file that was used in the plan job
        tfvars_file="${{ github.event.inputs.tfvars_file }}"
        tfvars_filename="$tfvars_file.tfvars"
        tfvars_path="tfvars/$tfvars_filename"
        
        # AVM Best Practice: Test idempotency after apply
        # Run plan again to ensure no changes are detected
        echo "::notice title=Testing Idempotency::Running post-apply plan to verify idempotency..."
        terraform plan -detailed-exitcode \
          -var-file="../../terraform.tfvars" \
          -var-file="$tfvars_path" || idempotency_exit_code=$?
        
        if [ $idempotency_exit_code -eq 2 ]; then
          echo "::error title=Idempotency Test Failed::Plan shows changes after apply - configuration is not idempotent. This indicates a problem with the Terraform configuration."
          exit 1
        elif [ $idempotency_exit_code -eq 0 ]; then
          echo "::notice title=Idempotency Test Passed::✅ No changes detected in post-apply plan - configuration is idempotent"
        else
          echo "::error title=Idempotency Test Error::Post-apply plan failed with error (exit code: $idempotency_exit_code)"
          exit 1
        fi
        
        cd - > /dev/null
    
    # Step 6: Extract outputs from the applied configuration
    # Terraform outputs often contain important information like resource IDs
    - name: Terraform Output
      run: |
        config="${{ needs.terraform-plan.outputs.configuration }}"
        
        echo "::notice title=Extracting Outputs::Getting Terraform outputs for configuration: $config"
        cd "configurations/$config"
        
        # Re-initialize to ensure we can read outputs from the updated state
        terraform init \
          -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TERRAFORM_CONTAINER }}" \
          -backend-config="key=$config.tfstate" \
          -backend-config="resource_group_name=${{ secrets.TERRAFORM_RESOURCE_GROUP }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
          -backend-config="use_oidc=true"
        
        # Extract outputs in JSON format, fallback to empty object if no outputs
        terraform output -json > "outputs-$config.json" || echo "{}" > "outputs-$config.json"
        
        # Show a preview of the outputs
        echo "::group::Terraform Outputs Preview"
        cat "outputs-$config.json"
        echo "::endgroup::"
        
        echo "::notice title=Outputs Extracted::Terraform outputs saved to outputs-$config.json"
        
        cd - > /dev/null
    
    # Step 7: Upload outputs as artifacts for later reference
    # These outputs can be used by other workflows or for troubleshooting
    - name: Upload Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs-${{ github.run_number }}
        path: configurations/*/outputs-*.json
        retention-days: 30    # Keep outputs longer than plans for reference