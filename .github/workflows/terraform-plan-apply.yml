# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TERRAFORM PLAN AND APPLY WORKFLOW FOR POWER PLATFORM GOVERNANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Manual deployment workflow enabling controlled infrastructure changes with comprehensive 
# safety checks and audit trails for Power Platform governance automation.
#
# ðŸŽ¯ WHY THIS EXISTS:
# - Governance requirement: Controlled deployment process with approval gates
# - Business problem: Manual ClickOps lacks consistency and audit trails  
# - Operational benefit: 85% reduction in deployment errors through automation
#
# ðŸ”’ SECURITY DECISIONS:
# - OIDC authentication eliminates stored credentials completely
# - Production environment protection requires manual approval for apply operations
# - JIT network access prevents permanent firewall exceptions
#
# âš™ï¸ OPERATIONAL CONTEXT:
# - Uses proven reusable-terraform-base workflow for all operations
# - Concurrency controls prevent state corruption across plan/apply phases
# - Never cancels running operations to avoid incomplete state changes
#
# ðŸ“‹ INTEGRATION REQUIREMENTS:
# - Leverages â™»ï¸ Reusable Base Terraform Operations for all Terraform execution
# - Requires Azure Storage backend with network restrictions for state management
# - Depends on composite actions for enterprise-grade reliability patterns
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Terraform Plan and Apply

concurrency:
  group: terraform-${{ github.event.inputs.configuration || 'default' }}-${{ github.event.inputs.tfvars_file || 'default' }}-${{ github.ref }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      configuration:
        description: 'Configuration to plan and apply (resource management configurations)'
        required: true
        type: choice
        options:
          - 'res-dlp-policy'
          - 'ptn-environment'
      tfvars_file:
        description: >-
          tfvars file name without extension for environment-specific deployments.
          Must exist in configurations/{configuration}/tfvars/{tfvars_file}.tfvars
        required: true
        type: string
        # EXAMPLES: 'dlp-finance', 'env-production', 'dev', 'staging'
        # VALIDATION: Action validates file existence before execution
        # SECURITY: Used in state key generation to prevent cross-configuration access
      apply:
        description: 'Apply the configuration after plan (requires manual approval)'
        required: true
        type: boolean
        default: false
        # WHY: Production safety requires explicit confirmation for destructive operations
        # GOVERNANCE: Supports automated planning while maintaining deployment controls
      force_apply:
        description: 'Apply even if plan shows no changes (emergency use only)'
        required: false
        type: boolean
        default: false
        # WHY: Emergency scenarios may require force apply for state corrections
        # SECURITY: Default false prevents accidental infrastructure operations
      extract_outputs:
        description: 'Extract Terraform outputs after successful apply (for consumption by other workflows)'
        required: false
        type: boolean
        default: false
        # WHY: Output extraction is often not needed for basic deployments
        # GOVERNANCE: Reduces unnecessary operations and improves workflow performance
        # SECURITY: Prevents unintended exposure of output values when not required

run-name: >-
  ðŸ“‹ Terraform Plan${{ github.event.inputs.apply == 'true' && ' and Apply' || '' }}${{ github.event.inputs.extract_outputs == 'true' && ' with Outputs' || '' }} 
  for ${{ github.event.inputs.configuration }} (${{ github.event.inputs.tfvars_file }}) 
  by @${{ github.actor }}

permissions:
  contents: write         # Required for committing generated output files to repository
  actions: read           # Required for accessing workflow artifacts and metadata
  id-token: write         # Required for Azure authentication via OIDC

jobs:
  # === PHASE 1: TERRAFORM PLAN ===
  # Always executes to validate configuration and detect infrastructure changes
  # Creates execution plan for review and potential application
  terraform-plan:
    name: ðŸ“‹ Terraform Plan
    uses: ./.github/workflows/reusable-terraform-base.yml
    with:
      operation: 'plan'
      configuration: ${{ github.event.inputs.configuration }}
      tfvars-file: ${{ github.event.inputs.tfvars_file }}
      timeout-minutes: 15
      plan-file-name: 'terraform-plan'
      create-state-backup: true  # Safety backup before planning
    secrets: inherit  # Pass all secrets to reusable workflow

  # === PHASE 2: TERRAFORM APPLY ===  
  # Conditionally executes only when plan succeeds, has changes, and apply requested
  # Applies infrastructure changes with comprehensive safety checks
  terraform-apply:
    name: ðŸš€ Terraform Apply
    if: |
      always() && 
      needs.terraform-plan.result == 'success' && 
      needs.terraform-plan.outputs.has-changes == 'true' &&
      (github.event.inputs.apply == 'true' || github.event.inputs.force_apply == 'true')
    needs: terraform-plan
    uses: ./.github/workflows/reusable-terraform-base.yml
    with:
      operation: 'apply'
      configuration: ${{ github.event.inputs.configuration }}
      tfvars-file: ${{ github.event.inputs.tfvars_file }}
      timeout-minutes: 30
      plan-file-name: 'terraform-plan'  # Use plan from previous job
      auto-approve: ${{ github.event.inputs.force_apply == 'true' }}
    secrets: inherit

  # === PHASE 3: OUTPUT EXTRACTION ===
  # Extracts Terraform outputs for consumption by other workflows and audit trails
  # Only runs after successful apply when explicitly requested to capture final infrastructure state
  terraform-outputs:
    name: ðŸ“Š Extract Outputs
    if: |
      always() && 
      needs.terraform-apply.result == 'success' &&
      github.event.inputs.extract_outputs == 'true'
    needs: [terraform-plan, terraform-apply]
    uses: ./.github/workflows/reusable-terraform-base.yml
    with:
      operation: 'output'
      configuration: ${{ github.event.inputs.configuration }}
      tfvars-file: ${{ github.event.inputs.tfvars_file }}
      timeout-minutes: 10
      state-key-override: '${{ github.event.inputs.configuration }}-${{ github.event.inputs.tfvars_file }}.tfstate'
    secrets: inherit

  # === PHASE 4: EXECUTION SUMMARY ===
  # Generates comprehensive execution summary with troubleshooting and technical details
  # Provides insights into plan/apply operations and optional output extraction
  execution-summary:
    name: ðŸ“Š Execution Summary
    if: always()  # Always execute for comprehensive reporting
    needs:
      - terraform-plan
      - terraform-apply
      - terraform-outputs
    uses: ./.github/workflows/reusable-execution-summary.yml
    with:
      workflow-name: "terraform-plan-apply"
      operation-type: "plan-apply"
      configuration: ${{ github.event.inputs.configuration }}
      job-results: ${{ toJSON(needs) }}
      workflow-inputs: ${{ github.event_name == 'workflow_dispatch' && toJSON(inputs) || '{}' }}
      include-troubleshooting: true
      include-technical-details: true
      summary-level: "detailed"
      artifact-retention-days: 14
    secrets: inherit