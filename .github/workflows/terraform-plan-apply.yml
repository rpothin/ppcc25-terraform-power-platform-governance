# Terraform Plan and Apply Workflow for Power Platform Governance
# This workflow allows manual deployment of Terraform configurations for Power Platform resources
# It supports both plan-only operations and plan+apply operations based on user input
# Includes comprehensive validation, safety checks, documentation generation, and idempotency testing

name: Terraform Plan and Apply

# Trigger: Manual workflow dispatch only
# Users can select which configuration to deploy and whether to apply changes
on:
  workflow_dispatch:
    inputs:
      configuration:
        description: 'Configuration to plan and apply (resource management configurations)'
        required: true
        type: choice
        options:
          - '02-dlp-policy'
          - '03-environment'
      tfvars_file:
        description: 'tfvars file name without extension (e.g., dlp-finance, env-production)'
        required: true
        type: string
      apply:
        description: 'Apply the configuration after plan'
        required: true
        type: boolean
        default: false
      force_apply:
        description: 'Apply even if plan shows no changes (use with caution)'
        required: false
        type: boolean
        default: false

# Dynamic run name that shows the configuration, tfvars file, and whether apply is enabled
run-name: ðŸ“‹ Terraform Plan${{ github.event.inputs.apply == 'true' && ' and Apply' || '' }} for ${{ github.event.inputs.configuration }} (${{ github.event.inputs.tfvars_file }}) by @${{ github.actor }}

# Required permissions for OIDC authentication with Azure and Power Platform
permissions:
  id-token: write   # Required for GitHub OIDC token generation
  contents: write   # Required for repository checkout and committing generated docs

# Environment variables for Power Platform OIDC authentication
# These are set at workflow level to avoid duplication across jobs
env:
  POWER_PLATFORM_USE_OIDC: true
  POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}
  POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
  # GitHub automatically provides these OIDC variables when id-token permission is granted
  POWER_PLATFORM_OIDC_REQUEST_URI: ${{ env.ACTIONS_ID_TOKEN_REQUEST_URL }}
  POWER_PLATFORM_OIDC_TOKEN: ${{ env.ACTIONS_ID_TOKEN_REQUEST_TOKEN }}

jobs:
  # Job 1: Plan Phase
  # Always runs to validate and plan the Terraform configuration
  # Creates execution plans and uploads them as artifacts for potential apply phase
  terraform-plan:
    runs-on: ubuntu-latest
    
    # Output values that can be used by dependent jobs
    outputs:
      plan-changed: ${{ steps.plan.outputs.changed }}              # Whether the plan has changes
      configuration: ${{ github.event.inputs.configuration }}     # Pass configuration to apply job
    
    steps:
    # Step 1: Validate inputs and configuration
    - name: Validate Inputs
      run: |
        config="${{ github.event.inputs.configuration }}"
        tfvars_file="${{ github.event.inputs.tfvars_file }}"
        apply_requested="${{ github.event.inputs.apply }}"
        force_apply="${{ github.event.inputs.force_apply }}"
        
        echo "::notice title=Validation Starting::Validating inputs for plan/apply operation..."
        
        # Validate configuration directory exists
        if [ ! -d "configurations/$config" ]; then
          echo "::error title=Configuration Not Found::Configuration directory 'configurations/$config' does not exist. Please check the configuration name."
          exit 1
        fi
        
        # Validate this is a resource management configuration
        if [[ "$config" != "02-dlp-policy" && "$config" != "03-environment" ]]; then
          echo "::error title=Invalid Configuration Type::Configuration '$config' is not a resource management configuration. Only resource management configurations should be used for plan/apply operations."
          exit 1
        fi
        
        # Validate tfvars file name format
        if [[ ! "$tfvars_file" =~ ^[a-zA-Z0-9_-]+$ ]]; then
          echo "::error title=Invalid tfvars File Name::tfvars file name '$tfvars_file' contains invalid characters. Use only alphanumeric characters, hyphens, and underscores."
          exit 1
        fi
        
        echo "::notice title=Input Validation Complete::âœ… All inputs validated successfully"
        echo "::notice title=Plan Target::ðŸŽ¯ Target configuration: $config with tfvars: $tfvars_file.tfvars"
        
        if [ "$apply_requested" = "true" ]; then
          echo "::warning title=Apply Requested::âš ï¸ Apply operation will be performed if plan shows changes"
          if [ "$force_apply" = "true" ]; then
            echo "::warning title=Force Apply Enabled::âš ï¸ Force apply is enabled - will apply even if no changes detected"
          fi
        else
          echo "::notice title=Plan Only::Plan-only operation - no resources will be modified"
        fi
    
    # Step 2: Checkout repository code
    - name: Checkout
      uses: actions/checkout@v4
    
    # Step 3: Authenticate with Azure using OIDC for backend state storage
    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    # Step 4: Install and configure Terraform CLI
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false    # Disable wrapper for better output handling
    
    # Step 5: Validate configuration and tfvars file existence
    - name: Validate Configuration Files
      run: |
        config="${{ github.event.inputs.configuration }}"
        tfvars_file="${{ github.event.inputs.tfvars_file }}"
        
        echo "::notice title=File Validation::Validating configuration and tfvars files..."
        
        # Validate configuration directory structure
        if [ ! -f "configurations/$config/main.tf" ] && [ ! -f "configurations/$config/data-sources.tf" ]; then
          echo "::error title=Invalid Configuration::No Terraform files found in configuration '$config'. Expected main.tf or data-sources.tf."
          exit 1
        fi
        
        # Validate tfvars file exists
        tfvars_filename="$tfvars_file.tfvars"
        tfvars_path="configurations/$config/tfvars/$tfvars_filename"
        
        if [ ! -f "$tfvars_path" ]; then
          echo "::error title=tfvars File Not Found::Specified tfvars file '$tfvars_path' does not exist."
          echo "::error title=Available Files::Available tfvars files in configurations/$config/tfvars/:"
          ls -la "configurations/$config/tfvars/" 2>/dev/null || echo "No tfvars directory found"
          exit 1
        fi
        
        echo "::notice title=Files Validated::âœ… Configuration and tfvars files validated successfully"
        echo "::notice title=Using Files::Configuration: configurations/$config/, tfvars: $tfvars_path"
    
    # Step 6: Create backup of current state
    - name: Create State Backup
      run: |
        config="${{ github.event.inputs.configuration }}"
        timestamp=$(date +%Y%m%d-%H%M%S)
        
        cd "configurations/$config"
        
        echo "::notice title=Creating Backup::Creating backup of current Terraform state..."
        
        # Create backups directory if it doesn't exist
        mkdir -p backups
        
        # Initialize Terraform first to access state
        terraform init \
          -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TERRAFORM_CONTAINER }}" \
          -backend-config="key=$config.tfstate" \
          -backend-config="resource_group_name=${{ secrets.TERRAFORM_RESOURCE_GROUP }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
          -backend-config="use_oidc=true"
        
        # Pull current state and create timestamped backup
        backup_filename="backups/terraform.tfstate.backup-$timestamp"
        terraform state pull > "$backup_filename" 2>/dev/null || echo "{}" > "$backup_filename"
        
        # Verify backup was created successfully
        if [ -s "$backup_filename" ] && [ "$(cat "$backup_filename")" != "{}" ]; then
          backup_size=$(du -h "$backup_filename" | cut -f1)
          echo "::notice title=Backup Created::âœ… State backup created successfully"
          echo "::notice title=Backup Details::File: $backup_filename, Size: $backup_size"
          
          # Count resources in backup
          resource_count=$(jq '.resources | length' "$backup_filename" 2>/dev/null || echo "0")
          echo "::notice title=Resources in Backup::Resources: $resource_count"
        else
          echo "::notice title=No Previous State::No existing state to backup - this is normal for new configurations"
          rm -f "$backup_filename"
        fi
        
        cd - > /dev/null
    
    # Step 7: Execute Terraform plan
    # This is the core step that initializes, validates, and plans the configuration
    - name: Terraform Plan
      id: plan
      run: |
        config="${{ github.event.inputs.configuration }}"
        tfvars_file="${{ github.event.inputs.tfvars_file }}"
        
        echo "::notice title=Planning Configuration::Starting Terraform plan for configuration: $config"
        cd "configurations/$config"
        
        # Terraform should already be initialized from backup step, but ensure it's current
        terraform init \
          -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TERRAFORM_CONTAINER }}" \
          -backend-config="key=$config.tfstate" \
          -backend-config="resource_group_name=${{ secrets.TERRAFORM_RESOURCE_GROUP }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
          -backend-config="use_oidc=true"
        
        # Validate Terraform configuration syntax and consistency
        echo "::notice title=Validating Configuration::Validating Terraform configuration syntax..."
        terraform validate
        
        # Prepare tfvars file paths
        tfvars_filename="$tfvars_file.tfvars"
        tfvars_path="tfvars/$tfvars_filename"
        
        echo "::notice title=Generating Plan::Creating execution plan with tfvars file: $tfvars_path"
        
        # Create execution plan with specified tfvars file
        # -detailed-exitcode: Exit 0 for no changes, 1 for error, 2 for changes
        # -out: Save plan to file for later apply
        # Load variables: root terraform.tfvars + selected configuration tfvars
        terraform plan -detailed-exitcode -out=tfplan-$config \
          -var-file="../../terraform.tfvars" \
          -var-file="$tfvars_path" || plan_exit_code=$?
        
        # Handle different exit codes from terraform plan
        if [ $plan_exit_code -eq 1 ]; then
          echo "::error title=Terraform Plan Failed::Terraform plan failed for configuration $config. Check the logs above for detailed error information."
          exit 1
        elif [ $plan_exit_code -eq 2 ]; then
          echo "::notice title=Changes Detected::âœ… Terraform plan detected changes for configuration $config. The plan will be saved for potential apply."
          echo "changed=true" >> $GITHUB_OUTPUT
          
          # Show plan summary
          echo "::group::Plan Changes Summary"
          terraform show tfplan-$config | grep -E "^(#|Plan:|Changes to Outputs:)" | head -20
          echo "::endgroup::"
        else
          echo "::notice title=No Changes::Terraform plan shows no changes for configuration $config. Infrastructure is up to date."
          echo "changed=false" >> $GITHUB_OUTPUT
          
          if [ "${{ github.event.inputs.force_apply }}" = "true" ]; then
            echo "::warning title=Force Apply::âš ï¸ Force apply is enabled - will proceed with apply even though no changes detected"
            echo "changed=true" >> $GITHUB_OUTPUT
          fi
        fi
        
        cd - > /dev/null
    
    # Step 5: Generate/Update Configuration Documentation
    # AVM requires up-to-date documentation generated by terraform-docs
    - name: Generate Configuration Documentation
      run: |
        config="${{ github.event.inputs.configuration }}"
        
        echo "Generating documentation for configuration: $config"
        cd "configurations/$config"
        
        # Install terraform-docs if not available
        if ! command -v terraform-docs &> /dev/null; then
          echo "::notice title=Installing terraform-docs::terraform-docs not found, installing version 0.20.0..."
          curl -sSLo terraform-docs.tar.gz https://github.com/terraform-docs/terraform-docs/releases/download/v0.20.0/terraform-docs-v0.20.0-linux-amd64.tar.gz
          tar -xzf terraform-docs.tar.gz
          sudo mv terraform-docs /usr/local/bin/
          rm terraform-docs.tar.gz
          echo "::notice title=Installation Complete::terraform-docs v0.20.0 installed successfully"
        fi
        
        # Generate documentation
        echo "::notice title=Generating Documentation::Creating README.md for configuration: $config"
        terraform-docs markdown table --output-file README.md .
        
        # Display generated content for verification
        echo "::group::Generated Documentation Preview"
        head -20 README.md
        echo "::endgroup::"
        
        cd - > /dev/null
    
    # Step 6: Commit generated documentation
    # Commit the updated README.md back to the repository
    - name: Commit Generated Documentation
      run: |
        config="${{ github.event.inputs.configuration }}"
        
        # Configure git
        git config user.name "GitHub Actions"
        git config user.email "actions@github.com"
        
        # Check if there are changes to commit
        if git diff --quiet "configurations/$config/README.md"; then
          echo "::notice title=Documentation Unchanged::No changes detected in documentation for $config, skipping commit"
        else
          echo "::notice title=Committing Documentation::Documentation has been updated, committing changes for $config..."
          git add "configurations/$config/README.md"
          git commit -m "docs: update documentation for $config configuration
          
          Auto-generated by terraform-docs via GitHub Actions"
          git push origin main
          echo "::notice title=Documentation Committed::âœ… Documentation committed successfully for $config"
        fi
    
    # Step 8: Upload plan files as artifacts for the apply job
    # Only uploads if there are changes to apply or force apply is enabled
    - name: Upload Plans
      if: steps.plan.outputs.changed == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: tfplans-${{ github.run_number }}
        path: configurations/*/tfplan-*
        retention-days: 7    # Keep plans for 7 days for troubleshooting and audit trail

  # Job 2: Apply Phase
  # Only runs if plan job succeeded, has changes, and user requested apply
  # Applies the previously created plan to make actual infrastructure changes
  terraform-apply:
    runs-on: ubuntu-latest
    needs: terraform-plan    # Depends on successful completion of plan job
    
    # Conditional execution: only run if all conditions are met
    if: |
      always() && 
      needs.terraform-plan.result == 'success' && 
      needs.terraform-plan.outputs.plan-changed == 'true' &&
      github.event.inputs.apply == 'true'
    
    steps:
    # Step 1: Checkout repository code (needed for accessing configuration files)
    - name: Checkout
      uses: actions/checkout@v4
    
    # Step 2: Authenticate with Azure using OIDC for backend state storage
    - name: Azure Login with OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    # Step 3: Install and configure Terraform CLI
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false
    
    # Step 4: Download the plan files created in the plan job
    - name: Download Plans
      uses: actions/download-artifact@v4
      with:
        name: tfplans-${{ github.run_number }}
        path: .
    
    # Step 5: Apply the Terraform plan
    # This step makes actual changes to the Power Platform infrastructure
    - name: Terraform Apply
      run: |
        config="${{ needs.terraform-plan.outputs.configuration }}"
        
        echo "::notice title=Applying Configuration::Starting Terraform apply for configuration: $config"
        cd "configurations/$config"
        
        # Re-initialize Terraform (required after downloading artifacts)
        terraform init \
          -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TERRAFORM_CONTAINER }}" \
          -backend-config="key=$config.tfstate" \
          -backend-config="resource_group_name=${{ secrets.TERRAFORM_RESOURCE_GROUP }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
          -backend-config="use_oidc=true"
        
        # Apply the previously created plan
        # -auto-approve: Skip interactive approval since we're using a pre-approved plan
        terraform apply -auto-approve "tfplan-$config"
        
        # Use the same tfvars file that was used in the plan job
        tfvars_file="${{ github.event.inputs.tfvars_file }}"
        tfvars_filename="$tfvars_file.tfvars"
        tfvars_path="tfvars/$tfvars_filename"
        
        # AVM Best Practice: Test idempotency after apply
        # Run plan again to ensure no changes are detected
        echo "::notice title=Testing Idempotency::Running post-apply plan to verify idempotency..."
        terraform plan -detailed-exitcode \
          -var-file="../../terraform.tfvars" \
          -var-file="$tfvars_path" || idempotency_exit_code=$?
        
        if [ $idempotency_exit_code -eq 2 ]; then
          echo "::error title=Idempotency Test Failed::Plan shows changes after apply - configuration is not idempotent. This indicates a problem with the Terraform configuration."
          exit 1
        elif [ $idempotency_exit_code -eq 0 ]; then
          echo "::notice title=Idempotency Test Passed::âœ… No changes detected in post-apply plan - configuration is idempotent"
        else
          echo "::error title=Idempotency Test Error::Post-apply plan failed with error (exit code: $idempotency_exit_code)"
          exit 1
        fi
        
        cd - > /dev/null
    
    # Step 6: Extract outputs from the applied configuration
    # Terraform outputs often contain important information like resource IDs
    - name: Terraform Output
      run: |
        config="${{ needs.terraform-plan.outputs.configuration }}"
        
        echo "::notice title=Extracting Outputs::Getting Terraform outputs for configuration: $config"
        cd "configurations/$config"
        
        # Re-initialize to ensure we can read outputs from the updated state
        terraform init \
          -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TERRAFORM_CONTAINER }}" \
          -backend-config="key=$config.tfstate" \
          -backend-config="resource_group_name=${{ secrets.TERRAFORM_RESOURCE_GROUP }}" \
          -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
          -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
          -backend-config="use_oidc=true"
        
        # Extract outputs in JSON format, fallback to empty object if no outputs
        terraform output -json > "outputs-$config.json" || echo "{}" > "outputs-$config.json"
        
        # Show a preview of the outputs
        echo "::group::Terraform Outputs Preview"
        cat "outputs-$config.json"
        echo "::endgroup::"
        
        echo "::notice title=Outputs Extracted::Terraform outputs saved to outputs-$config.json"
        
        cd - > /dev/null
    
    # Step 7: Upload outputs as artifacts for later reference
    # These outputs can be used by other workflows or for troubleshooting
    - name: Upload Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs-${{ github.run_number }}
        path: configurations/*/outputs-*.json
        retention-days: 30    # Keep outputs longer than plans for reference