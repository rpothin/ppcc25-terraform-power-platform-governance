# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TERRAFORM SINGLE PATH VALIDATION WORKFLOW FOR POWER PLATFORM GOVERNANCE
# Validates a single Terraform configuration or module directory for Power Platform governance.
#
# ðŸŽ¯ WHY THIS EXISTS:
# - Enables robust, isolated validation of individual configurations or modules
# - Supports parallel, per-path validation for rapid feedback and scalability
# - Automates all quality checks (format, syntax, structure, security, integration) for a given path
#
# ðŸ”’ SECURITY DECISIONS:
# - OIDC authentication required for all cloud and Power Platform connections
# - All jobs requiring secrets run in the 'production' environment for protection
# - Principle of least privilege applied to all permissions
#
# âš™ï¸ OPERATIONAL CONTEXT:
# - Concurrency group ensures only one validation per path/ref at a time
# - Timeout values sized for comprehensive validation without resource waste
# - Manual dispatch only: designed for use by change-detection/dispatch workflows
#
# ðŸ“‹ INTEGRATION REQUIREMENTS:
# - Relies on composite actions for backend init, metadata, and JIT network access
# - Requires Azure OIDC identity federation and GitHub environment protection
# - Generates AVM-compliant artifacts for audit and compliance
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
name: "Terraform Single Path Validation"

concurrency:
  group: terraform-single-path-validation-${{ inputs.target_configuration }}-${{ github.ref }}
  cancel-in-progress: false

on:
  workflow_dispatch:
    inputs:
      target_configuration:
        description: >-
          Configuration to validate under the configurations directory (e.g., 01-dlp-policies).
          Must exist and contain Terraform files.
        required: true
        type: string
        # WHY: Enables per-path validation for robust, parallelized quality checks
        # VALIDATION: Must be a valid configuration/module directory

run-name: "Validate ${{ inputs.target_configuration }} by @${{ github.actor }}"

permissions:
  contents: read          # Required: Repository content access for validation
  actions: read           # Required: Access to workflow metadata and job execution data
  security-events: write  # Required: Upload security findings to GitHub Security tab
  id-token: write         # Required: OIDC authentication with Azure AD for integration

jobs:
  # === FORMAT CHECK ===
  # Ensures consistent code formatting for the target path
  format-check:
    name: ðŸŽ¨ Format Check
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      # === REPOSITORY ACCESS ===
      # WHY: Required to access the repository code for validation
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === TERRAFORM ENVIRONMENT SETUP ===
      # WHY: Ensures consistent Terraform version for formatting and validation
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}

      # === FORMAT CHECK EXECUTION ===
      # WHY: Enforces standardized code style and improves maintainability
      - name: Format Check
        id: format
        run: |
          cd "configurations/${{ inputs.target_configuration }}"
          format_output=$(terraform fmt -recursive -check -diff 2>&1) || format_exit_code=$?
          if [ "${format_exit_code:-0}" -eq 0 ]; then
            echo "::notice title=Format Success::All Terraform files are properly formatted"
            echo "format-issues=false" >> $GITHUB_OUTPUT
          else
            echo "::error title=Format Issues::Terraform formatting issues found"
            echo "format-issues=true" >> $GITHUB_OUTPUT
            echo "$format_output"
            exit 1
          fi

  # === SYNTAX VALIDATION ===
  # Validates Terraform HCL syntax and basic configuration structure for the target path
  syntax-validation:
    name: âœ… Syntax Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: format-check
    steps:
      # === REPOSITORY ACCESS ===
      # WHY: Required to access the repository code for validation
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === TERRAFORM ENVIRONMENT SETUP ===
      # WHY: Ensures consistent Terraform version for syntax validation
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}

      # === SYNTAX VALIDATION EXECUTION ===
      # WHY: Validates HCL syntax and configuration structure for the target path
      - name: Syntax Validation
        id: validate
        run: |
          cd "configurations/${{ inputs.target_configuration }}"
          if ! find . -maxdepth 1 -name "*.tf" -type f | grep -q .; then
            echo "::warning title=No TF Files::No Terraform files found, skipping validation"
            exit 0
          fi
          terraform init -backend=false -input=false
          terraform validate

  # === STRUCTURE VALIDATION ===
  # Advanced validation of configuration structure and tfvars for the target path
  structure-validation:
    name: ðŸ”§ Structure Validation
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: format-check
    steps:
      # === REPOSITORY ACCESS ===
      # WHY: Required to access the repository code for validation
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === TERRAFORM ENVIRONMENT SETUP ===
      # WHY: Ensures consistent Terraform version for structure validation
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}

      # === STRUCTURE VALIDATION EXECUTION ===
      # WHY: Checks for tfvars and standard file structure to ensure best practices
      - name: Structure Validation
        id: structure
        run: |
          cd "configurations/${{ inputs.target_configuration }}"
          if [ -d "tfvars" ]; then
            find tfvars -name "*.tfvars" -type f | while read -r tfvars_file; do
              if [ ! -s "$tfvars_file" ]; then
                echo "::warning title=Empty tfvars::Empty tfvars file detected: $tfvars_file"
              fi
            done
          fi
          for f in main.tf variables.tf outputs.tf; do
            if [ -f "$f" ]; then
              echo "::notice title=Structure::Found $f"
            fi
          done

  # === SECURITY SCAN ===
  # Multi-layer security analysis using Trivy for the target path
  security-scan:
    name: ðŸ›¡ï¸ Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: format-check
    steps:
      # === REPOSITORY ACCESS ===
      # WHY: Required to access the repository code for security scanning
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === SECURITY SCAN EXECUTION ===
      # WHY: Scans Terraform configuration for security vulnerabilities
      - name: Run Trivy Vulnerability Scanner
        uses: aquasecurity/trivy-action@0.32.0
        with:
          scan-type: 'config'
          scan-ref: 'configurations/${{ inputs.target_configuration }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          exit-code: '0'
          severity: 'CRITICAL,HIGH,MEDIUM'

      # === SECURITY RESULTS UPLOAD ===
      # WHY: Publishes security scan results to GitHub Security tab
      - name: Upload Security Results to GitHub
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

  # === INTEGRATION TEST ===
  # Real-world integration testing using OIDC and isolated backend for the target path
  integration-test:
    name: ðŸ§ª Integration Test
    runs-on: ubuntu-latest
    timeout-minutes: 25
    environment: production
    needs: format-check
    if: always()
    
    # === ENVIRONMENT VARIABLES ===
    # These environment variables configure authentication for both Azure and Power Platform
    # All use OIDC (OpenID Connect) for secure, passwordless authentication
    env:
      # Power Platform OIDC Configuration
      # Required for Power Platform Terraform provider authentication
      POWER_PLATFORM_USE_OIDC: true
      POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}
      POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
      
      # Azure OIDC Configuration
      # Required for Azure provider authentication and resource management
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_USE_OIDC: true
      
      # Terraform Backend Configuration
      # Required for Azure Storage backend where Terraform state is stored
      # Used by terraform-init-with-backend composite action
      ARM_STORAGE_ACCOUNT_NAME: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
      ARM_CONTAINER_NAME: ${{ secrets.TERRAFORM_CONTAINER }}
      ARM_RESOURCE_GROUP_NAME: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

    steps:
      # === REPOSITORY ACCESS ===
      # WHY: Required to access the repository code for integration testing
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === AZURE OIDC AUTHENTICATION ===
      # WHY: Secure Azure authentication using OIDC identity federation
      - name: Azure Login (OIDC)
        uses: azure/login@v2.3.0
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # === JIT NETWORK ACCESS ENABLE ===
      # WHY: Enables temporary network access for secure backend operations
      - name: Add JIT Network Access
        id: jit-add
        uses: ./.github/actions/jit-network-access
        with:
          action: 'add'
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

      # === TERRAFORM ENVIRONMENT SETUP ===
      # WHY: Ensures consistent Terraform version for integration testing
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}
          terraform_wrapper: false

      # === BACKEND INITIALIZATION ===
      # WHY: Initializes isolated backend state for the integration test
      - name: Initialize Terraform Backend
        id: terraform-init
        uses: ./.github/actions/terraform-init-with-backend
        with:
          configuration: '${{ inputs.target_configuration }}'
          state-key-override: 'integration-test-${{ inputs.target_configuration }}.tfstate'
          max-retries: '3'
          wait-for-propagation: '15'

      # === INTEGRATION TEST EXECUTION ===
      # WHY: Runs integration tests for the configuration/module if present
      - name: Integration Test
        id: integration-tests
        run: |
          cd "configurations/${{ inputs.target_configuration }}"
          echo "::notice title=Test Start::$(date)"
          
          export TEST_RESULT_FILE="terraform_test_output.log"
          export JUNIT_XML_FILE="terraform_test_results.xml"
          export TEST_STATUS_FILE="terraform_test_status.txt"
          export TEST_FILES_FILE="terraform_test_files.txt"
          
          if find . -name "*.tftest.hcl" -type f | tee "$TEST_FILES_FILE" | grep -q .; then
            echo "::notice title=Test Files Found::$(cat $TEST_FILES_FILE | wc -l) test file(s) discovered"

            # Run tests with JUnit XML output (relative path for GitHub Actions compatibility)
            echo "::debug::Running terraform test with JUnit XML output to $JUNIT_XML_FILE"
            if terraform test -junit-xml="$JUNIT_XML_FILE" 2>&1 | tee "$TEST_RESULT_FILE"; then
              echo "success" > "$TEST_STATUS_FILE"
            else
              echo "failure" > "$TEST_STATUS_FILE"
            fi
            
            # Debug: Check if JUnit XML file was created
            if [ -f "$JUNIT_XML_FILE" ]; then
              echo "::notice title=JUnit XML Created::JUnit XML file created successfully at $(pwd)/$JUNIT_XML_FILE"
              echo "::debug::JUnit XML file size: $(stat -c%s $JUNIT_XML_FILE) bytes"
              # Show first few lines for debugging
              echo "::group::JUnit XML Preview"
              head -10 "$JUNIT_XML_FILE" || echo "Could not preview JUnit XML"
              echo "::endgroup::"
            else
              echo "::warning title=No JUnit XML::JUnit XML file was not created at $(pwd)/$JUNIT_XML_FILE"
              echo "::debug::Current directory contents:"
              ls -la
            fi
          else
            echo "::notice title=No Tests Found::No .tftest.hcl files found, skipping."
            echo "skipped" > "$TEST_STATUS_FILE"
          fi
          
          echo "::notice title=Test End::$(date)"

      # === PUBLISH TEST RESULTS ===
      # WHY: Publishes JUnit XML test results for GitHub UI integration
      - name: Publish Test Results
        uses: dorny/test-reporter@v2
        if: always()
        with:
          name: 'Terraform Integration Test Results'
          path: 'configurations/${{ inputs.target_configuration }}/terraform_test_results.xml'

      # === JIT NETWORK ACCESS CLEANUP ===
      # WHY: Removes temporary network access to maintain security posture
      - name: Remove JIT Network Access
        if: always()
        uses: ./.github/actions/jit-network-access
        with:
          action: 'remove'
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

  # === REUSABLE EXECUTION SUMMARY GENERATION ===
  # Generates a comprehensive summary of all validation steps and results for this path
  execution-summary:
    name: ðŸ“Š Execution Summary Generation
    if: always()  # Always execute for comprehensive reporting
    needs:
      - format-check
      - syntax-validation
      - structure-validation
      - security-scan
      - integration-test
    uses: ./.github/workflows/reusable-execution-summary.yml
    with:
      # === CORE WORKFLOW IDENTIFICATION ===
      workflow-name: "terraform-single-path-validation"
      operation-type: "validation"
      configuration: ${{ inputs.target_configuration }}

      # === EXECUTION CONTEXT ===
      job-results: ${{ toJSON(needs) }}
      workflow-inputs: ${{ github.event_name == 'workflow_dispatch' && toJSON(inputs) || '{}' }}

      # === SUMMARY CUSTOMIZATION ===
      include-troubleshooting: true
      include-technical-details: true
      summary-level: "detailed"

      # === ARTIFACT CONFIGURATION ===
      artifact-retention-days: 14