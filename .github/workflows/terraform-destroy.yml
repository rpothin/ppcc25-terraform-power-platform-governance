# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘                      TERRAFORM DESTROY WORKFLOW FOR POWER PLATFORM GOVERNANCE                       â•‘
# â•‘                          Secure Infrastructure Destruction Pipeline                                  â•‘
# â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
# â•‘ This workflow provides a secure, auditable, and reversible mechanism for destroying                 â•‘
# â•‘ Terraform-managed Power Platform resources with comprehensive safety measures and audit trails.     â•‘
# â•‘                                                                                                      â•‘
# â•‘ SECURITY AND SAFETY ARCHITECTURE:                                                                   â•‘
# â•‘ ğŸ”’ Multi-Layer Confirmation - Explicit user confirmation with case-sensitive validation            â•‘
# â•‘ ğŸ’¾ Automated State Backup - Comprehensive backup system with commit-based persistence              â•‘
# â•‘ ğŸ›¡ï¸ OIDC Authentication - Secure identity federation eliminating stored credentials                 â•‘
# â•‘ ğŸ” Pre-Destroy Validation - Comprehensive resource analysis and safety checks                      â•‘
# â•‘ ğŸ“Š Comprehensive Audit Trail - Detailed execution metadata and artifact retention                  â•‘
# â•‘                                                                                                      â•‘
# â•‘ EXECUTION WORKFLOW:                                                                                  â•‘
# â•‘ 1. INPUT VALIDATION: Rigorous validation of configuration, tfvars, and confirmation                â•‘
# â•‘ 2. SAFETY CHECKS: State analysis, resource counting, and backup creation                           â•‘
# â•‘ 3. DESTROY PLANNING: Comprehensive destroy plan generation with detailed review                     â•‘
# â•‘ 4. SECURE EXECUTION: OIDC-authenticated destruction with real-time monitoring                      â•‘
# â•‘ 5. VERIFICATION: Post-destroy validation and clean state confirmation                              â•‘
# â•‘ 6. AUDIT DOCUMENTATION: Complete metadata generation and artifact preservation                     â•‘
# â•‘                                                                                                      â•‘
# â•‘ SAFETY FEATURES:                                                                                     â•‘
# â•‘ â€¢ Manual-only trigger with explicit confirmation requirement                                        â•‘
# â•‘ â€¢ Automatic state backup with version control integration                                           â•‘
# â•‘ â€¢ Comprehensive validation before any destructive operations                                        â•‘
# â•‘ â€¢ Force-destroy option for edge cases with additional safety warnings                              â•‘
# â•‘ â€¢ Post-operation verification and cleanup validation                                                â•‘
# â•‘ â€¢ Complete audit trail with metadata preservation for compliance                                    â•‘
# â•‘                                                                                                      â•‘
# â•‘ RECOVERY CAPABILITIES:                                                                               â•‘
# â•‘ â€¢ State backup restoration with terraform state push commands                                       â•‘
# â•‘ â€¢ Configuration preservation for rapid resource recreation                                          â•‘
# â•‘ â€¢ Comprehensive metadata for detailed impact analysis and recovery planning                        â•‘
# â•‘ â€¢ Artifact retention with configurable retention policies                                          â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Terraform Destroy

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONCURRENCY CONTROL CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Sophisticated concurrency management to prevent conflicting Terraform operations and ensure safe execution

concurrency:
  # === GRANULAR CONCURRENCY GROUPING ===
  # Create unique concurrency groups based on configuration and tfvars combination to prevent conflicts
  # while allowing parallel operations on different configurations
  group: terraform-${{ github.event.inputs.configuration || 'default' }}-${{ github.event.inputs.tfvars_file || 'default' }}-${{ github.ref }}
  
  # === CONSERVATIVE CANCELLATION POLICY ===
  # Never cancel running Terraform operations to prevent state corruption and partial resource destruction
  cancel-in-progress: false
  # Rationale: Terraform destroy operations are critical and potentially destructive
  # Canceling mid-operation could leave resources in an inconsistent state

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WORKFLOW TRIGGER CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Manual-only trigger with comprehensive input validation and explicit confirmation requirements

on:
  workflow_dispatch:
    inputs:
      # === PRIMARY CONFIGURATION SELECTION ===
      # Restrict to resource management configurations that support safe destruction
      configuration:
        description: 'Configuration to destroy (resource management configurations only)'
        required: true
        type: choice
        options:
          - '02-dlp-policy'    # Data Loss Prevention Policy Management
          - '03-environment'   # Power Platform Environment Management
        # Note: Core configurations like '01-dlp-policies' excluded for safety
        # These contain foundational policies that should not be destroyed

      # === TFVARS FILE SPECIFICATION ===
      # Specific tfvars file selection for targeted resource destruction
      tfvars_file:
        description: 'tfvars file name without extension (e.g., dlp-finance, env-production)'
        required: true
        type: string
        # Examples: dlp-finance, dlp-hr, env-development, env-production
        # This targets specific resource instances within configurations

      # === EXPLICIT DESTRUCTION CONFIRMATION ===
      # Case-sensitive confirmation to prevent accidental resource destruction
      confirmation:
        description: 'Type "DESTROY" to confirm resource destruction (case sensitive)'
        required: true
        type: string
        # Security measure: Requires exact case-sensitive match to "DESTROY"
        # Prevents accidental destruction through typos or automation

      # === STATE BACKUP CONFIGURATION ===
      # Comprehensive backup system for disaster recovery and audit compliance
      backup_state:
        description: 'Create state backup before destroy (recommended for production)'
        required: true
        type: boolean
        default: true
        # Default: true for safety - creates versioned backups before destruction
        # Backups are committed to version control for persistence

      # === FORCE DESTRUCTION OPTION ===
      # Edge case handling for empty states or special circumstances
      force_destroy:
        description: 'Force destroy even if plan shows no resources (use with caution)'
        required: false
        type: boolean
        default: false
        # Use case: Clean up state entries for manually removed resources
        # Requires additional safety warnings and explicit user intent

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DYNAMIC RUN NAMING CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Comprehensive run identification for audit trails and immediate visual recognition

run-name: ğŸš¨ Terraform DESTROY ${{ github.event.inputs.configuration }} (${{ github.event.inputs.tfvars_file }}) by @${{ github.actor }}
# Pattern: Clear destruction indicator + configuration + tfvars + actor identification
# Benefits: Immediate visual recognition, audit trail, accountability tracking

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WORKFLOW PERMISSIONS CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Minimal but comprehensive permissions for secure operations with OIDC authentication

permissions:
  id-token: write   # Required: GitHub OIDC token generation for Azure and Power Platform authentication
  contents: write   # Required: Repository operations for backup commits and artifact management
# Note: No workflow-level environment variables for enhanced security
# Secrets are only accessible within jobs that explicitly specify the production environment

jobs:
  # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  # â•‘                             VALIDATION AND SAFETY CHECKS JOB                                        â•‘
  # â•‘                         Comprehensive Pre-Destruction Validation Pipeline                           â•‘
  # â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  # â•‘ This job acts as a comprehensive safety gate before any destructive operations are performed.       â•‘
  # â•‘ It validates inputs, analyzes current state, creates backups, and generates destruction plans.      â•‘
  # â•‘                                                                                                      â•‘
  # â•‘ VALIDATION ARCHITECTURE:                                                                             â•‘
  # â•‘ ğŸ” Input Validation - Rigorous confirmation and parameter verification                              â•‘
  # â•‘ ğŸ“Š State Analysis - Comprehensive resource inventory and dependency checking                        â•‘
  # â•‘ ğŸ’¾ Backup Creation - Automated state backup with version control integration                        â•‘
  # â•‘ ğŸ“‹ Destroy Planning - Detailed destruction plan generation for review and approval                 â•‘
  # â•‘ ğŸ”’ Security Integration - OIDC authentication with JIT network access                              â•‘
  # â•‘                                                                                                      â•‘
  # â•‘ SAFETY MEASURES:                                                                                     â•‘
  # â•‘ â€¢ Case-sensitive confirmation validation to prevent typos                                           â•‘
  # â•‘ â€¢ Configuration and tfvars file existence verification                                              â•‘
  # â•‘ â€¢ Current state analysis with resource counting and impact assessment                              â•‘
  # â•‘ â€¢ Automated backup creation with persistent storage                                                 â•‘
  # â•‘ â€¢ Comprehensive destroy plan generation for audit and review                                        â•‘
  # â•‘ â€¢ Artifact preservation for compliance and rollback capabilities                                    â•‘
  # â•‘                                                                                                      â•‘
  # â•‘ OUTPUT GENERATION:                                                                                   â•‘
  # â•‘ â€¢ Resource existence flags for conditional execution control                                        â•‘
  # â•‘ â€¢ Resource count for impact assessment and user notification                                        â•‘
  # â•‘ â€¢ Backup status confirmation for recovery planning                                                  â•‘
  # â•‘ â€¢ Comprehensive metadata for audit trails and compliance documentation                             â•‘
  # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  terraform-validate:
    name: ğŸ” Validation and Safety Checks
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: production                           # Production environment protection for sensitive operations
    
    # === COMPREHENSIVE AUTHENTICATION CONFIGURATION ===
    # Secure OIDC-based authentication for Azure and Power Platform services
    env:
      # === POWER PLATFORM AUTHENTICATION ===
      # Configure Power Platform provider for secure OIDC authentication
      POWER_PLATFORM_USE_OIDC: true                  # Enable OIDC authentication for Power Platform provider
      POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}      # Power Platform client identity
      POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}      # Power Platform tenant context
      
      # === AZURE RESOURCE MANAGER AUTHENTICATION ===
      # Configure ARM provider for secure backend state management
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}              # Target Azure subscription
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}                          # Azure AD tenant context
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}                          # Azure client identity
      ARM_USE_OIDC: true                              # Enable OIDC authentication for ARM provider
    
    # === COMPREHENSIVE OUTPUT CONFIGURATION ===
    # Generate outputs for conditional execution control and downstream job coordination
    outputs:
      resources-exist: ${{ steps.analyze-state.outputs.resources-exist }}    # Boolean: Resource presence flag
      resource-count: ${{ steps.analyze-state.outputs.resource-count }}      # Number: Count of resources to destroy
      configuration: ${{ github.event.inputs.configuration }}                # String: Configuration identifier
      backup-created: ${{ steps.backup.outputs.backup-created }}             # Boolean: Backup creation status
      validation-metadata: ${{ steps.analyze-state.outputs.validation-metadata }}  # JSON: Comprehensive execution metadata
    
    steps:
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 1: CRITICAL INPUT VALIDATION AND CONFIRMATION VERIFICATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Rigorous validation of user input to prevent accidental destruction and ensure proper authorization
      
      - name: Validate Destroy Confirmation Input
        run: |
          echo "::notice title=Input Validation::ğŸ” Starting comprehensive input validation and confirmation verification"
          
          # === CONFIRMATION STRING VALIDATION ===
          # Critical security check: Verify exact case-sensitive confirmation
          confirmation="${{ github.event.inputs.confirmation }}"
          
          echo "::notice title=Confirmation Check::Validating destruction confirmation input..."
          echo "::notice title=Security Measure::Confirmation must be exactly 'DESTROY' (case sensitive)"
          
          if [ "$confirmation" != "DESTROY" ]; then
            echo "::error title=Invalid Confirmation::âŒ Confirmation validation failed"
            echo "::error title=Required Input::You must type 'DESTROY' (case sensitive) to confirm resource destruction"
            echo "::error title=Provided Input::Received: '$confirmation'"
            echo "::error title=Security Notice::This safety measure prevents accidental resource destruction"
            echo "::notice title=Correction::Please re-run the workflow with the exact confirmation string 'DESTROY'"
            exit 1
          fi
          
          echo "::warning title=Destruction Confirmed::âš ï¸ User has provided valid destruction confirmation"
          echo "::notice title=Authorization::âœ… Confirmation validation passed - proceeding with safety checks"
          echo "::notice title=Actor::ğŸ§‘â€ğŸ’¼ Destruction authorized by: @${{ github.actor }}"
          echo "::notice title=Timestamp::â° Confirmation validated at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "::notice title=Actor::ğŸ§‘â€ğŸ’¼ Destruction authorized by: @${{ github.actor }}"
          echo "::notice title=Timestamp::â° Confirmation validated at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 2: REPOSITORY ACCESS AND ENVIRONMENT PREPARATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Standard repository checkout for comprehensive validation operations
      
      - name: Checkout Repository for Validation
        uses: actions/checkout@v4
        # Purpose: Access configuration files, tfvars, and validation scripts
        # Required for: File existence checks, configuration validation, backup operations
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 3: AZURE OIDC AUTHENTICATION FOR BACKEND ACCESS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Secure Azure authentication using OIDC identity federation for backend state management
      
      - name: Azure Login with OIDC
        uses: azure/login@v2.3.0
        with:
          # === OIDC AUTHENTICATION CONFIGURATION ===
          # Secure authentication using GitHub OIDC identity federation (no stored credentials)
          client-id: ${{ secrets.AZURE_CLIENT_ID }}                   # Azure AD application client ID
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}                   # Azure AD tenant identifier
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}       # Target Azure subscription
        # Purpose: Authenticate with Azure for Terraform backend state access
        # Security: Uses OIDC federation to eliminate credential storage
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 4: JUST-IN-TIME NETWORK ACCESS CONFIGURATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Enable secure network access for Azure Storage backend operations with minimal exposure
      
      - name: Add JIT Network Access
        id: jit-add
        uses: ./.github/actions/jit-network-access
        with:
          action: 'add'                                               # Enable network access
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}    # Backend storage account
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}      # Storage resource group
        # Purpose: Enable just-in-time network access for secure Terraform backend connectivity
        # Security: Minimal exposure window with automatic cleanup
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 5: TERRAFORM ENVIRONMENT SETUP AND CONFIGURATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Install and configure Terraform CLI for consistent validation and planning operations
      
      - name: Setup Terraform CLI for Validation
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          # === TERRAFORM VERSION CONFIGURATION ===
          # Use consistent Terraform version for reliable validation behavior
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}       # Version with intelligent fallback
          terraform_wrapper: false                       # Disable wrapper for enhanced output handling and parsing
        # Purpose: Install consistent Terraform version for reliable validation operations
        # Configuration: Wrapper disabled for better output parsing and error handling
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 6: COMPREHENSIVE INPUT VALIDATION AND FILE VERIFICATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Thorough validation of configuration and tfvars file existence and accessibility
      
      - name: Validate Destroy Inputs
        run: |
          echo "::notice title=File Validation::ğŸ“‹ Starting comprehensive file and configuration validation"
          
          # === INPUT PARAMETER EXTRACTION ===
          # Extract and validate input parameters for comprehensive checking
          config="${{ github.event.inputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          
          echo "::notice title=Validation Starting::ğŸ” Validating inputs for destroy operation..."
          echo "::notice title=Target Configuration::ğŸ“ Configuration: $config"
          echo "::notice title=Target tfvars::ğŸ“„ tfvars file: $tfvars_file"
          
          # === CONFIGURATION DIRECTORY VALIDATION ===
          # Verify that the specified configuration directory exists and is accessible
          config_path="configurations/$config"
          echo "::notice title=Directory Check::Validating configuration directory: $config_path"
          
          if [ ! -d "$config_path" ]; then
            echo "::error title=Configuration Not Found::âŒ Configuration directory '$config_path' does not exist"
            echo "::error title=Available Configurations::ğŸ“ Available configurations:"
            ls -la configurations/ 2>/dev/null || echo "No configurations directory found"
            echo "::notice title=Resolution::ğŸ”§ Please check the configuration name and ensure it exists in the repository"
            exit 1
          fi
          
          echo "::notice title=Directory Found::âœ… Configuration directory exists and is accessible"
          
          # === TFVARS FILE VALIDATION ===
          # Verify that the specified tfvars file exists within the configuration
          tfvars_filename="$tfvars_file.tfvars"
          tfvars_path="$config_path/tfvars/$tfvars_filename"
          
          echo "::notice title=tfvars Check::Validating tfvars file: $tfvars_path"
          
          if [ ! -f "$tfvars_path" ]; then
            echo "::error title=tfvars File Not Found::âŒ Specified tfvars file '$tfvars_path' does not exist"
            echo "::error title=Available tfvars::ğŸ“„ Available tfvars files in $config:"
            ls -la "$config_path/tfvars/" 2>/dev/null || echo "No tfvars directory found"
            echo "::notice title=Resolution::ğŸ”§ Please check the tfvars filename and ensure it exists in the configuration"
            exit 1
          fi
          
          echo "::notice title=tfvars Found::âœ… tfvars file exists and is accessible"
          
          # === VALIDATION SUMMARY ===
          # Provide comprehensive summary of validation results
          echo "::notice title=Input Validation Complete::âœ… All input validation checks passed successfully"
          echo "::warning title=Destroy Target Confirmed::ğŸ¯ Validated destruction target:"
          echo "::warning title=Configuration::ğŸ“ $config"
          echo "::warning title=tfvars File::ğŸ“„ $tfvars_filename"
          echo "::warning title=Full Path::ğŸ“‚ $tfvars_path"
          echo "::notice title=Proceeding::ğŸš€ Moving to state analysis and backup operations"
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 7: TERRAFORM INITIALIZATION AND STATE PREPARATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Initialize Terraform with backend configuration for state analysis and validation
      
      - name: Initialize and Check State
        id: state-check
        run: |
          echo "::notice title=Terraform Initialization::ğŸ”§ Preparing Terraform environment for state analysis"
          
          # === CONFIGURATION CONTEXT SETUP ===
          # Set up working directory and context for Terraform operations
          config="${{ github.event.inputs.configuration }}"
          echo "::notice title=Initializing Terraform::Initializing Terraform for configuration: $config"
          echo "::notice title=Working Directory::ğŸ“ Changing to configuration directory: configurations/$config"
          cd "configurations/$config"
          
          echo "::notice title=Initialization Complete::âœ… Ready for backend initialization and state analysis"

      # === STEP 7A: TERRAFORM BACKEND INITIALIZATION ===
      # Use reusable action for consistent and reliable backend initialization
      - name: Initialize Terraform for State Check
        uses: ./.github/actions/terraform-init-with-backend
        env:
          # === BACKEND CONFIGURATION ENVIRONMENT ===
          # Comprehensive backend configuration for secure state management
          ARM_STORAGE_ACCOUNT_NAME: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}  # Backend storage account
          ARM_CONTAINER_NAME: ${{ secrets.TERRAFORM_CONTAINER }}              # Backend container name
          ARM_RESOURCE_GROUP_NAME: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}    # Backend resource group
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}           # Azure subscription context
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}                       # Azure tenant context
        with:
          # === INITIALIZATION PARAMETERS ===
          # Specific configuration and tfvars targeting for precise state access
          configuration: ${{ github.event.inputs.configuration }}             # Target configuration
          tfvars-file: ${{ github.event.inputs.tfvars_file }}                 # Target tfvars file
        # Purpose: Initialize Terraform with proper backend configuration for state analysis
        # Benefits: Consistent initialization, error handling, retry logic

      # === STEP 7B: WORKFLOW METADATA GENERATION ===
      # Generate comprehensive metadata for audit trails and compliance tracking
      - name: Generate Metadata and Check State
        uses: ./.github/actions/generate-workflow-metadata
        id: validation-metadata
        with:
          # === METADATA CONFIGURATION ===
          # Comprehensive metadata generation for destroy operation tracking
          operation: 'destroy'                         # Operation type for metadata categorization
          configuration: ${{ github.event.inputs.configuration }}    # Configuration context
          tfvars-file: ${{ github.event.inputs.tfvars_file }}        # tfvars context
          phase: 'validation'                          # Current execution phase
        # Purpose: Generate AVM-compliant metadata for audit trails and compliance
        # Output: Structured metadata for downstream consumption and archival

      # === STEP 7C: COMPREHENSIVE STATE ANALYSIS ===
      # Analyze current Terraform state for resource inventory and impact assessment
      - name: Analyze Current State
        id: analyze-state
        run: |
          echo "::notice title=State Analysis::ğŸ“Š Analyzing current Terraform state for resource impact assessment"
          
          # === CONFIGURATION CONTEXT SETUP ===
          # Establish working directory and operational context
          config="${{ github.event.inputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          
          echo "::notice title=State Analysis Starting::ğŸ” Beginning comprehensive state analysis..."
          echo "::notice title=Target Configuration::ğŸ“ Configuration: $config"
          echo "::notice title=Target tfvars::ğŸ“„ tfvars file: $tfvars_file.tfvars"
          
          # === WORKING DIRECTORY SETUP ===
          # Navigate to configuration directory for state operations
          cd "configurations/$config"
          echo "::notice title=Working Directory::ğŸ“‚ Operating in: $(pwd)"
          
          # === STATE EXISTENCE CHECK ===
          # Determine if Terraform state exists and contains resources
          echo "::notice title=State Check::Checking for existing Terraform state..."
          
          # Check if state contains any resources using terraform show
          if terraform show -json > /dev/null 2>&1; then
            # State file exists and is accessible
            echo "::notice title=State Found::âœ… Terraform state file found and accessible"
            
            # === RESOURCE INVENTORY AND ANALYSIS ===
            # Perform comprehensive resource analysis for impact assessment
            echo "::notice title=Resource Analysis::ğŸ“‹ Performing comprehensive resource inventory..."
            
            # Get detailed resource information using terraform show
            terraform show -json > state_output.json 2>/dev/null || {
              echo "::warning title=State Access Issue::âš ï¸ Could not generate JSON state output"
              echo "resources-exist=false" >> $GITHUB_OUTPUT
              echo "resource-count=0" >> $GITHUB_OUTPUT
              exit 0
            }
            
            # === RESOURCE COUNT CALCULATION ===
            # Calculate total number of managed resources for impact assessment
            echo "::notice title=Resource Counting::ğŸ”¢ Calculating resource count for impact assessment..."
            
            # Count resources in the state (filter for managed resources only)
            resource_count=0
            if [ -f "state_output.json" ]; then
              # Use jq to count resources, fallback to alternative methods if jq unavailable
              if command -v jq >/dev/null 2>&1; then
                resource_count=$(jq -r '.values.root_module.resources[]? | select(.mode == "managed") | .address' state_output.json 2>/dev/null | wc -l || echo "0")
              else
                # Fallback: Use terraform state list as alternative counting method
                echo "::notice title=Counting Method::Using terraform state list for resource counting..."
                resource_count=$(terraform state list 2>/dev/null | wc -l || echo "0")
              fi
            fi
            
            # Ensure resource count is a valid number
            if ! [[ "$resource_count" =~ ^[0-9]+$ ]]; then
              echo "::warning title=Count Issue::Could not determine exact resource count, setting to 0"
              resource_count=0
            fi
            
            echo "::notice title=Resource Count::ğŸ“Š Found $resource_count managed resources in current state"
            
            # === RESOURCE EXISTENCE DETERMINATION ===
            # Set existence flag based on resource count analysis
            if [ "$resource_count" -gt 0 ]; then
              # Resources exist - destruction is needed and possible
              echo "::warning title=Resources Found::âš ï¸ $resource_count resources found in state - destruction will be performed"
              echo "::warning title=Impact Assessment::ğŸ“ˆ This operation will attempt to destroy $resource_count resources"
              echo "resources-exist=true" >> $GITHUB_OUTPUT
              echo "resource-count=$resource_count" >> $GITHUB_OUTPUT
              
              # === RESOURCE LISTING FOR TRANSPARENCY ===
              # Provide detailed resource listing for user awareness
              echo "::notice title=Resource Listing::ğŸ“‹ Listing resources that will be destroyed:"
              terraform state list 2>/dev/null || echo "::warning title=Listing Issue::Could not list individual resources"
              
            else
              # No resources exist - nothing to destroy
              echo "::notice title=No Resources::âœ… No managed resources found in state"
              echo "::notice title=No Action Needed::ğŸ“ State is empty - no destruction operations required"
              echo "resources-exist=false" >> $GITHUB_OUTPUT
              echo "resource-count=0" >> $GITHUB_OUTPUT
            fi
            
            # === METADATA GENERATION ===
            # Generate comprehensive metadata for downstream consumption
            echo "::notice title=Metadata Generation::ğŸ“‹ Generating validation metadata for audit trails..."
            
            # Create metadata JSON for workflow tracking and compliance
            metadata=$(cat <<EOF
          {
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "actor": "${{ github.actor }}",
            "configuration": "$config",
            "tfvars_file": "$tfvars_file",
            "resources_exist": $([ "$resource_count" -gt 0 ] && echo "true" || echo "false"),
            "resource_count": $resource_count,
            "state_analysis": {
              "state_accessible": true,
              "analysis_method": "terraform_show_json",
              "validation_phase": "pre_destroy"
            },
            "workflow_context": {
              "run_id": "${{ github.run_id }}",
              "run_number": "${{ github.run_number }}",
              "ref": "${{ github.ref }}",
              "sha": "${{ github.sha }}"
            }
          }
          EOF
            )
            
            echo "validation-metadata=$metadata" >> $GITHUB_OUTPUT
            echo "::notice title=Metadata Complete::âœ… Validation metadata generated successfully"
            
          else
            # === NO STATE SCENARIO ===
            # Handle case where no state file exists or is inaccessible
            echo "::notice title=No State::ğŸ“ No Terraform state found or state is empty"
            echo "::notice title=No Resources::âœ… No resources to destroy - state file does not exist or contains no resources"
            echo "::notice title=Operation Result::ğŸš€ No destruction operations will be performed"
            
            # Set outputs for no-state scenario
            echo "resources-exist=false" >> $GITHUB_OUTPUT
            echo "resource-count=0" >> $GITHUB_OUTPUT
            
            # Generate metadata for no-state scenario
            metadata=$(cat <<EOF
          {
            "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
            "actor": "${{ github.actor }}",
            "configuration": "$config",
            "tfvars_file": "$tfvars_file",
            "resources_exist": false,
            "resource_count": 0,
            "state_analysis": {
              "state_accessible": false,
              "analysis_method": "terraform_show",
              "validation_phase": "pre_destroy",
              "no_state_reason": "State file not found or empty"
            },
            "workflow_context": {
              "run_id": "${{ github.run_id }}",
              "run_number": "${{ github.run_number }}",
              "ref": "${{ github.ref }}",
              "sha": "${{ github.sha }}"
            }
          }
          EOF
            )
            
            echo "validation-metadata=$metadata" >> $GITHUB_OUTPUT
            echo "::notice title=No State Metadata::âœ… No-state scenario metadata generated successfully"
          fi
          
          # === ANALYSIS SUMMARY ===
          # Provide comprehensive summary of state analysis results
          echo "::notice title=Analysis Complete::âœ… State analysis completed successfully"
          echo "::notice title=Summary::ğŸ“Š Analysis Summary:"
          echo "::notice title=Resources Exist::$([ "$resource_count" -gt 0 ] && echo "Yes" || echo "No")"
          echo "::notice title=Resource Count::$resource_count"
          echo "::notice title=Next Phase::ğŸš€ Proceeding to backup and destroy plan generation"
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 8: AUTOMATED STATE BACKUP WITH VERSION CONTROL INTEGRATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Create comprehensive backup of current state for disaster recovery and rollback capabilities
      
      - name: Create State Backup
        id: backup
        run: |
          echo "::notice title=Backup Creation::ğŸ’¾ Creating comprehensive state backup for disaster recovery"
          
          # === BACKUP CONTEXT SETUP ===
          # Establish backup parameters and directory structure
          config="${{ github.event.inputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          timestamp=$(date +"%Y%m%d_%H%M%S")
          backup_dir="backups/destroy_$config_$tfvars_file_$timestamp"
          
          echo "::notice title=Backup Planning::ğŸ“‹ Planning backup operation..."
          echo "::notice title=Configuration::ğŸ“ $config"
          echo "::notice title=tfvars File::ğŸ“„ $tfvars_file"
          echo "::notice title=Timestamp::â° $timestamp"
          echo "::notice title=Backup Directory::ğŸ“‚ $backup_dir"
          
          # === BACKUP DIRECTORY CREATION ===
          # Create structured backup directory for organized storage
          echo "::notice title=Directory Setup::Creating backup directory structure..."
          mkdir -p "$backup_dir"
          
          # === WORKING DIRECTORY SETUP ===
          # Navigate to configuration directory for backup operations
          cd "configurations/$config"
          
          # === STATE BACKUP EXECUTION ===
          # Create comprehensive backup only if resources exist
          resources_exist="${{ steps.analyze-state.outputs.resources-exist }}"
          
          if [ "$resources_exist" = "true" ]; then
            echo "::notice title=State Backup::ğŸ’¾ Creating state backup - resources exist and require protection"
            
            # === TERRAFORM STATE BACKUP ===
            # Export current state in multiple formats for comprehensive backup
            echo "::notice title=State Export::Exporting Terraform state in multiple formats..."
            
            # Export state as JSON for detailed backup
            if terraform show -json > "../../$backup_dir/terraform_state.json" 2>/dev/null; then
              echo "::notice title=JSON Backup::âœ… JSON state backup created successfully"
            else
              echo "::warning title=JSON Backup Issue::âš ï¸ Could not create JSON state backup"
            fi
            
            # Export state in human-readable format
            if terraform show > "../../$backup_dir/terraform_state.txt" 2>/dev/null; then
              echo "::notice title=Text Backup::âœ… Human-readable state backup created successfully"
            else
              echo "::warning title=Text Backup Issue::âš ï¸ Could not create text state backup"
            fi
            
            # === CONFIGURATION BACKUP ===
            # Backup configuration files and tfvars for complete restoration capability
            echo "::notice title=Configuration Backup::ğŸ“‹ Backing up configuration files..."
            
            # Copy main Terraform configuration
            cp -r . "../../$backup_dir/configuration/" 2>/dev/null || {
              echo "::warning title=Config Backup Issue::âš ï¸ Could not backup configuration files"
            }
            
            # === BACKUP METADATA CREATION ===
            # Generate comprehensive metadata for backup management
            echo "::notice title=Metadata Creation::ğŸ“ Creating backup metadata..."
            
            cat > "../../$backup_dir/backup_metadata.json" <<EOF
          {
            "backup_timestamp": "$timestamp",
            "configuration": "$config",
            "tfvars_file": "$tfvars_file",
            "resource_count": "${{ steps.analyze-state.outputs.resource-count }}",
            "backup_trigger": "pre_destroy_safety",
            "github_context": {
              "actor": "${{ github.actor }}",
              "run_id": "${{ github.run_id }}",
              "run_number": "${{ github.run_number }}",
              "ref": "${{ github.ref }}",
              "sha": "${{ github.sha }}"
            },
            "backup_contents": {
              "terraform_state_json": true,
              "terraform_state_text": true,
              "configuration_files": true,
              "tfvars_files": true
            }
          }
          EOF
            
            echo "::notice title=Metadata Complete::âœ… Backup metadata created successfully"
            
            # === GIT INTEGRATION FOR BACKUP PERSISTENCE ===
            # Commit backup to repository for persistent storage and version control
            echo "::notice title=Git Integration::ğŸ”„ Integrating backup with version control..."
            
            cd ../.. # Return to repository root
            
            # Configure git for automated commits
            git config --global user.name "GitHub Actions"
            git config --global user.email "actions@github.com"
            
            # Add backup files to git
            git add "$backup_dir/"
            
            # Commit backup with descriptive message
            if git commit -m "ğŸ”’ Pre-destroy backup: $config ($tfvars_file) - $(date -u +"%Y-%m-%d %H:%M:%S UTC")" 2>/dev/null; then
              echo "::notice title=Git Commit::âœ… Backup committed to version control successfully"
              echo "backup-created=true" >> $GITHUB_OUTPUT
            else
              echo "::warning title=Git Commit Issue::âš ï¸ Could not commit backup to version control"
              echo "backup-created=false" >> $GITHUB_OUTPUT
            fi
            
            # === BACKUP SUCCESS NOTIFICATION ===
            # Provide comprehensive backup completion notification
            echo "::notice title=Backup Complete::âœ… State backup created successfully"
            echo "::notice title=Backup Location::ğŸ“‚ Backup stored in: $backup_dir"
            echo "::notice title=Recovery::ğŸ”„ Backup can be used for state recovery if needed"
            echo "::warning title=Backup Protection::ğŸ”’ Backup includes state and configuration for complete restoration"
            
          else
            # === NO BACKUP NEEDED SCENARIO ===
            # Handle case where no resources exist and backup is unnecessary
            echo "::notice title=No Backup Needed::ğŸ“ No resources exist - backup not required"
            echo "::notice title=Empty State::âœ… State is empty or non-existent - no backup necessary"
            echo "backup-created=false" >> $GITHUB_OUTPUT
          fi
          
          echo "::notice title=Backup Phase Complete::âœ… Backup phase completed successfully"
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 9: COMPREHENSIVE DESTROY PLAN GENERATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Generate detailed destruction plan for review, audit, and execution preparation
      
      - name: Generate Destroy Plan
        id: destroy-plan
        run: |
          echo "::notice title=Destroy Plan::ğŸ“‹ Generating comprehensive destroy plan for review and execution"
          
          # === PLAN CONTEXT SETUP ===
          # Establish planning parameters and working directory
          config="${{ github.event.inputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          resources_exist="${{ steps.analyze-state.outputs.resources-exist }}"
          
          echo "::notice title=Plan Generation::ğŸ“Š Starting destroy plan generation..."
          echo "::notice title=Configuration::ğŸ“ $config"
          echo "::notice title=tfvars File::ğŸ“„ $tfvars_file.tfvars"
          echo "::notice title=Resources Exist::$([ "$resources_exist" = "true" ] && echo "Yes" || echo "No")"
          
          # === WORKING DIRECTORY SETUP ===
          # Navigate to configuration directory for planning operations
          cd "configurations/$config"
          
          # === CONDITIONAL PLAN GENERATION ===
          # Generate destroy plan only if resources exist for destruction
          if [ "$resources_exist" = "true" ]; then
            echo "::notice title=Plan Creation::ğŸ”¨ Creating destroy plan - resources require destruction"
            
            # === TERRAFORM DESTROY PLAN GENERATION ===
            # Generate comprehensive destroy plan with detailed output
            echo "::notice title=Planning Phase::Executing terraform plan -destroy..."
            
            # Create destroy plan with detailed output and error handling
            if terraform plan -destroy \
              -var-file="tfvars/$tfvars_file.tfvars" \
              -out=destroy.tfplan \
              -detailed-exitcode 2>&1 | tee destroy_plan_output.txt; then
              
              # === PLAN SUCCESS HANDLING ===
              # Process successful plan generation
              plan_exit_code=${PIPESTATUS[0]}
              
              echo "::notice title=Plan Generated::âœ… Destroy plan generated successfully"
              echo "::notice title=Exit Code::ğŸ“Š Terraform plan exit code: $plan_exit_code"
              
              # === PLAN ANALYSIS AND SUMMARY ===
              # Analyze plan output for impact assessment
              echo "::notice title=Plan Analysis::ğŸ“Š Analyzing destroy plan for impact assessment..."
              
              # Count resources to be destroyed from plan output
              destroy_count=$(grep -c "will be destroyed" destroy_plan_output.txt 2>/dev/null || echo "0")
              
              echo "::warning title=Destruction Impact::âš ï¸ Plan Summary:"
              echo "::warning title=Resources to Destroy::ğŸ—‘ï¸ $destroy_count resources will be destroyed"
              echo "::warning title=Plan File::ğŸ“„ Destroy plan saved as: destroy.tfplan"
              
              # === PLAN OUTPUT DISPLAY ===
              # Display plan output for user review and confirmation
              echo "::notice title=Plan Output::ğŸ“‹ Destroy Plan Details:"
              echo "::group::Terraform Destroy Plan Output"
              cat destroy_plan_output.txt 2>/dev/null || echo "Could not display plan output"
              echo "::endgroup::"
              
              # === PLAN ARTIFACT PRESERVATION ===
              # Save plan artifacts for downstream job consumption
              echo "::notice title=Artifact Preparation::ğŸ“¦ Preparing plan artifacts for downstream consumption..."
              
              # Ensure plan file exists and is accessible
              if [ -f "destroy.tfplan" ]; then
                echo "::notice title=Plan File::âœ… Destroy plan file created and ready for execution"
              else
                echo "::warning title=Plan File Issue::âš ï¸ Destroy plan file not found - may cause execution issues"
              fi
              
            else
              # === PLAN FAILURE HANDLING ===
              # Handle plan generation failures with detailed error information
              echo "::error title=Plan Generation Failed::âŒ Failed to generate destroy plan"
              echo "::error title=Planning Issue::Terraform plan -destroy command failed"
              echo "::error title=Resolution::ğŸ”§ Check configuration and state for issues"
              
              # Display error output for troubleshooting
              echo "::group::Terraform Plan Error Output"
              cat destroy_plan_output.txt 2>/dev/null || echo "No error output available"
              echo "::endgroup::"
              
              exit 1
            fi
            
          else
            # === NO PLAN NEEDED SCENARIO ===
            # Handle case where no resources exist and planning is unnecessary
            echo "::notice title=No Plan Needed::ğŸ“ No resources exist - destroy plan not required"
            echo "::notice title=Empty State::âœ… State is empty - no planning necessary"
            echo "::notice title=No Action::ğŸš€ No destroy operations will be performed"
          fi
          
          echo "::notice title=Planning Complete::âœ… Destroy plan generation phase completed successfully"
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 10: CLEANUP AND SECURITY FINALIZATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Remove just-in-time network access and finalize validation phase
      
      - name: Remove JIT Network Access
        if: always()                                  # Always execute cleanup regardless of previous step status
        uses: ./.github/actions/jit-network-access
        with:
          action: 'remove'                            # Remove network access for security
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}    # Target storage account
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}      # Target resource group
        # Purpose: Remove just-in-time network access for security compliance
        # Execution: Always runs to ensure cleanup even if previous steps fail
    
      # === VALIDATION SUMMARY AND STATUS REPORTING ===
      # Provide comprehensive summary of validation phase results
      - name: Validation Summary
        if: always()                                  # Always provide summary regardless of status
        run: |
          echo "::notice title=Validation Summary::ğŸ“Š Comprehensive validation phase summary"
          
          # === VALIDATION RESULTS SUMMARY ===
          # Compile and display comprehensive validation results
          resources_exist="${{ steps.analyze-state.outputs.resources-exist }}"
          resource_count="${{ steps.analyze-state.outputs.resource-count }}"
          backup_created="${{ steps.backup.outputs.backup-created }}"
          config="${{ github.event.inputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          
          echo "::notice title=Validation Complete::âœ… All validation checks completed"
          echo "::notice title=Results Summary::ğŸ“‹ Validation Results:"
          echo "::notice title=Configuration::ğŸ“ $config"
          echo "::notice title=tfvars File::ğŸ“„ $tfvars_file.tfvars"
          echo "::notice title=Resources Found::$([ "$resources_exist" = "true" ] && echo "Yes ($resource_count resources)" || echo "No (empty state)")"
          echo "::notice title=Backup Created::$([ "$backup_created" = "true" ] && echo "Yes (state protected)" || echo "No (not needed)")"
          
          # === NEXT PHASE PREPARATION ===
          # Prepare information for destroy execution phase
          if [ "$resources_exist" = "true" ]; then
            echo "::warning title=Destroy Ready::âš ï¸ Validation passed - destroy job will execute"
            echo "::warning title=Impact::ğŸ¯ $resource_count resources are queued for destruction"
            echo "::warning title=Safety::ğŸ”’ State backup created for recovery if needed"
          else
            echo "::notice title=No Action Needed::âœ… No resources to destroy - destroy job will skip execution"
            echo "::notice title=Status::ğŸ“ Configuration state is empty or non-existent"
          fi
          
          echo "::notice title=Validation Phase::âœ… Validation phase completed successfully"
          echo "::notice title=Next Phase::ğŸš€ Proceeding to destroy execution phase (if resources exist)"

  # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  # â•‘                           TERRAFORM DESTROY EXECUTION JOB                                           â•‘
  # â•‘                      Secure Infrastructure Destruction with Safety Controls                         â•‘
  # â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
  # â•‘ This job executes the actual resource destruction after comprehensive validation and safety checks. â•‘
  # â•‘ It operates with multiple layers of security and implements robust recovery mechanisms.             â•‘
  # â•‘                                                                                                      â•‘
  # â•‘ EXECUTION ARCHITECTURE:                                                                              â•‘
  # â•‘ ğŸ” Multi-Layer Security - OIDC authentication with production environment protection                â•‘
  # â•‘ âš¡ Conditional Execution - Runs only after successful validation with resource existence checks     â•‘
  # â•‘ ğŸ”„ Retry Logic - Intelligent retry mechanisms for network-dependent operations                      â•‘
  # â•‘ ğŸ“Š Progress Tracking - Comprehensive progress reporting and status monitoring                       â•‘
  # â•‘ ğŸ›¡ï¸ Recovery Preparation - Post-execution verification and cleanup state analysis                   â•‘
  # â•‘                                                                                                      â•‘
  # â•‘ SAFETY MECHANISMS:                                                                                   â•‘
  # â•‘ â€¢ Final confirmation warnings with mandatory delay for user awareness                              â•‘
  # â•‘ â€¢ Conditional execution preventing unnecessary runs on empty states                                â•‘
  # â•‘ â€¢ Force-destroy capability for emergency scenarios with additional safeguards                      â•‘
  # â•‘ â€¢ Network retry logic for resilient backend connectivity during destruction                        â•‘
  # â•‘ â€¢ Post-destroy verification ensuring complete resource removal                                      â•‘
  # â•‘ â€¢ Comprehensive error handling with troubleshooting guidance                                        â•‘
  # â•‘                                                                                                      â•‘
  # â•‘ EMERGENCY FEATURES:                                                                                  â•‘
  # â•‘ â€¢ Force destroy option bypasses resource existence checks for emergency cleanup                     â•‘
  # â•‘ â€¢ Detailed error diagnostics with Power Platform specific troubleshooting                          â•‘
  # â•‘ â€¢ State snapshot creation for audit trails and compliance verification                             â•‘
  # â•‘ â€¢ Automatic cleanup procedures ensuring secure completion regardless of outcome                     â•‘
  # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  terraform-destroy:
    name: ğŸš¨ Terraform Destroy Execution
    runs-on: ubuntu-latest
    timeout-minutes: 25                              # Extended timeout for complex destroy operations
    environment: production                           # Production environment protection with additional approvals
    needs: terraform-validate                         # Strict dependency on successful validation completion
    
    # === COMPREHENSIVE AUTHENTICATION CONFIGURATION ===
    # Secure OIDC-based authentication for Power Platform and Azure service integration
    env:
      # === POWER PLATFORM AUTHENTICATION ===
      # Configure Power Platform provider for secure OIDC-based resource destruction
      POWER_PLATFORM_USE_OIDC: true                  # Enable OIDC authentication for Power Platform provider
      POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}      # Power Platform client identity
      POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}      # Power Platform tenant context
      
      # === AZURE RESOURCE MANAGER AUTHENTICATION ===
      # Configure ARM provider for secure backend state management during destruction
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}              # Target Azure subscription
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}                          # Azure AD tenant context
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}                          # Azure client identity (same app registration)
      ARM_USE_OIDC: true                              # Enable OIDC authentication for ARM provider
    
    # === INTELLIGENT CONDITIONAL EXECUTION ===
    # Advanced conditional logic ensuring destruction only occurs when appropriate
    if: |
      always() && 
      needs.terraform-validate.result == 'success' && 
      (needs.terraform-validate.outputs.resources-exist == 'true' || github.event.inputs.force_destroy == 'true')
    # Execution Logic:
    # â€¢ always() - Run regardless of other job statuses to handle cleanup scenarios
    # â€¢ Validation Success - Only proceed if validation job completed successfully
    # â€¢ Resource Existence - Execute only if resources exist for destruction
    # â€¢ Force Override - Allow execution in emergency scenarios with force_destroy flag
    # â€¢ This prevents unnecessary execution on empty states while enabling emergency cleanup

    steps:
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 1: FINAL USER CONFIRMATION AND IMPACT WARNING
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Provide final warning with mandatory delay to ensure user awareness of irreversible action
      
      - name: Final Destruction Confirmation Warning
        run: |
          echo "::warning title=FINAL WARNING::ğŸš¨ CRITICAL OPERATION - FINAL CONFIRMATION REQUIRED"
          
          # === IMPACT ASSESSMENT DISPLAY ===
          # Extract and display comprehensive impact information from validation
          resource_count="${{ needs.terraform-validate.outputs.resource-count }}"
          config="${{ needs.terraform-validate.outputs.configuration }}"
          backup_created="${{ needs.terraform-validate.outputs.backup-created }}"
          force_mode="${{ github.event.inputs.force_destroy }}"
          
          echo "::error title=IRREVERSIBLE ACTION::âš ï¸ ABOUT TO PERMANENTLY DESTROY RESOURCES"
          echo "::error title=Target Configuration::ğŸ“ Configuration: $config"
          echo "::error title=Resource Count::ğŸ—‘ï¸ Resources to destroy: $resource_count"
          echo "::error title=Backup Status::ğŸ’¾ State backup created: $([ "$backup_created" = "true" ] && echo "âœ… Yes" || echo "âŒ No")"
          echo "::error title=Force Mode::âš¡ Force destroy enabled: $([ "$force_mode" = "true" ] && echo "âš ï¸ YES" || echo "No")"
          
          # === MANDATORY CONFIRMATION DELAY ===
          # Implement mandatory 5-second delay for user awareness and reflection
          echo "::warning title=Mandatory Delay::â³ Implementing mandatory 5-second confirmation delay..."
          echo "::notice title=Purpose::ğŸ›¡ï¸ This delay ensures awareness of the irreversible nature of this operation"
          echo "::notice title=Consider::ğŸ¤” Use this time to verify this is the intended action"
          
          # Countdown with progress indication
          for i in 5 4 3 2 1; do
            echo "::warning title=Countdown::â° Proceeding in $i seconds... (operation cannot be undone)"
            sleep 1
          done
          
          echo "::error title=DESTRUCTION STARTING::ğŸš¨ BEGINNING IRREVERSIBLE RESOURCE DESTRUCTION"
          echo "::notice title=Execution Context::ğŸ‘¤ Authorized by: @${{ github.actor }}"
          echo "::notice title=Timestamp::ğŸ“… Destruction initiated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          
          # === FORCE MODE ADDITIONAL WARNING ===
          # Provide additional warnings if force mode is enabled
          if [ "$force_mode" = "true" ]; then
            echo "::error title=FORCE MODE ACTIVE::âš¡ FORCE DESTROY MODE IS ENABLED"
            echo "::error title=Emergency Operation::ğŸš¨ This operation may bypass normal safety checks"
            echo "::error title=Use Case::ğŸ†˜ Force mode should only be used for emergency cleanup scenarios"
          fi
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 2: REPOSITORY ACCESS AND EXECUTION ENVIRONMENT PREPARATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Standard repository checkout for destroy execution operations
      
      - name: Checkout Repository for Destroy Execution
        uses: actions/checkout@v4
        # Purpose: Access configuration files, tfvars, and execution scripts for destroy operations
        # Required for: Configuration access, tfvars loading, and metadata operations
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 3: AZURE OIDC AUTHENTICATION FOR SECURE BACKEND ACCESS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Secure Azure authentication using OIDC identity federation for backend state management
      
      - name: Azure Login with OIDC for Destroy
        uses: azure/login@v2.3.0
        with:
          # === OIDC AUTHENTICATION CONFIGURATION ===
          # Secure authentication using GitHub OIDC identity federation (no stored credentials)
          client-id: ${{ secrets.AZURE_CLIENT_ID }}                   # Azure AD application client ID
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}                   # Azure AD tenant identifier
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}       # Target Azure subscription
        # Purpose: Authenticate with Azure for Terraform backend state access during destruction
        # Security: Uses OIDC federation to eliminate credential storage and enhance security
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 4: JUST-IN-TIME NETWORK ACCESS FOR SECURE BACKEND CONNECTIVITY
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Enable secure network access for Azure Storage backend operations during destroy execution
      
      - name: Add JIT Network Access for Destroy
        id: jit-add
        uses: ./.github/actions/jit-network-access
        with:
          action: 'add'                                               # Enable network access for destroy operations
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}    # Backend storage account
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}      # Storage resource group
        # Purpose: Enable just-in-time network access for secure Terraform backend connectivity
        # Security: Minimal exposure window with automatic cleanup ensuring network security
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 5: TERRAFORM ENVIRONMENT SETUP FOR DESTRUCTION OPERATIONS
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Install and configure Terraform CLI for consistent destroy execution operations
      
      - name: Setup Terraform CLI for Destruction
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          # === TERRAFORM VERSION CONFIGURATION ===
          # Use consistent Terraform version for reliable destroy behavior
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}       # Version with intelligent fallback
          terraform_wrapper: false                       # Disable wrapper for enhanced output handling during destruction
        # Purpose: Install consistent Terraform version for reliable destroy operations
        # Configuration: Wrapper disabled for better output parsing and error handling during destruction
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 6: TERRAFORM INITIALIZATION WITH INTELLIGENT RETRY LOGIC
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Initialize Terraform with robust retry mechanisms for reliable backend connectivity
      
      - name: Initialize Terraform for Destroy Execution
        run: |
          echo "::notice title=Terraform Initialization::ğŸ”§ Initializing Terraform environment for destroy execution"
          
          # === EXECUTION CONTEXT SETUP ===
          # Extract execution parameters from validation job outputs
          config="${{ needs.terraform-validate.outputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          
          echo "::notice title=Execution Context::ğŸ“‹ Destroy execution parameters:"
          echo "::notice title=Configuration::ğŸ“ $config"
          echo "::notice title=tfvars File::ğŸ“„ $tfvars_file.tfvars"
          echo "::notice title=Working Directory::ğŸ“‚ Changing to: configurations/$config"
          
          # === WORKING DIRECTORY SETUP ===
          # Navigate to configuration directory for destroy operations
          cd "configurations/$config"
          
          # === NETWORK PROPAGATION DELAY ===
          # Allow time for JIT network access rules to fully propagate across Azure infrastructure
          echo "::notice title=Network Propagation::â³ Waiting for network access rules to propagate..."
          echo "::notice title=Timing::ğŸ• Implementing 10-second delay for network rule propagation"
          sleep 10
          echo "::notice title=Network Ready::âœ… Network propagation delay completed"
          
          # === INTELLIGENT RETRY LOGIC FOR INITIALIZATION ===
          # Implement robust retry mechanisms for network-dependent terraform init operations
          echo "::notice title=Retry Logic::ğŸ”„ Initializing Terraform with intelligent retry mechanisms..."
          
          # Retry configuration parameters
          max_retries=3
          retry_count=0
          init_success=false
          
          # Retry loop with exponential backoff for resilient initialization
          while [ $retry_count -lt $max_retries ] && [ "$init_success" = false ]; do
            retry_count=$((retry_count + 1))
            echo "::notice title=Init Attempt::ğŸ”„ Terraform initialization attempt $retry_count of $max_retries"
            
            # Execute terraform init with comprehensive backend configuration
            if terraform init \
              -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
              -backend-config="container_name=${{ secrets.TERRAFORM_CONTAINER }}" \
              -backend-config="key=$config-${{ github.event.inputs.tfvars_file }}.tfstate" \
              -backend-config="resource_group_name=${{ secrets.TERRAFORM_RESOURCE_GROUP }}" \
              -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
              -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
              -backend-config="use_oidc=true" 2>&1; then
              
              # === INITIALIZATION SUCCESS ===
              # Handle successful terraform initialization
              init_success=true
              echo "::notice title=Init Success::âœ… Terraform initialization completed successfully on attempt $retry_count"
              echo "::notice title=Backend::ğŸ”— Successfully connected to remote state backend"
              echo "::notice title=Ready::ğŸš€ Terraform environment ready for destroy execution"
              
            else
              # === INITIALIZATION FAILURE HANDLING ===
              # Handle failed initialization attempts with intelligent retry logic
              echo "::warning title=Init Failed::âš ï¸ Terraform initialization attempt $retry_count failed"
              echo "::warning title=Retry Context::ğŸ”„ Network-dependent operation - implementing retry logic"
              
              if [ $retry_count -lt $max_retries ]; then
                # Calculate exponential backoff delay
                wait_time=$((retry_count * 10))
                echo "::notice title=Retry Delay::â±ï¸ Waiting ${wait_time} seconds before next attempt..."
                echo "::notice title=Backoff Strategy::ğŸ“ˆ Using exponential backoff for network resilience"
                sleep $wait_time
              fi
            fi
          done
          
          # === FINAL INITIALIZATION STATUS CHECK ===
          # Verify initialization success or fail with comprehensive error information
          if [ "$init_success" = false ]; then
            echo "::error title=Init Failed::âŒ Terraform initialization failed after $max_retries attempts"
            echo "::error title=Context::ğŸ“‹ Initialization failure occurred before destroy execution"
            echo "::error title=Common Causes::ğŸ” Common initialization failure causes:"
            echo "::error title=Cause 1::ğŸŒ Network connectivity issues to Azure Storage backend"
            echo "::error title=Cause 2::ğŸ” Authentication problems with OIDC or storage access"
            echo "::error title=Cause 3::ğŸ—ï¸ Backend configuration mismatch or state corruption"
            echo "::error title=Cause 4::ğŸ”’ Storage account access policies or firewall restrictions"
            echo "::error title=Resolution::ğŸ”§ Verify network connectivity, authentication, and backend configuration"
            exit 1
          fi
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 7: TERRAFORM DESTROY EXECUTION WITH COMPREHENSIVE MONITORING
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Execute the actual resource destruction with detailed progress monitoring and error handling
      
      - name: Execute Terraform Destroy Operation
        run: |
          echo "::warning title=Destroy Execution::ğŸš¨ EXECUTING TERRAFORM DESTROY OPERATION"
          
          # === EXECUTION CONTEXT SETUP ===
          # Extract execution parameters and context information
          config="${{ needs.terraform-validate.outputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          resource_count="${{ needs.terraform-validate.outputs.resource-count }}"
          
          echo "::error title=DESTRUCTION IN PROGRESS::âš ï¸ BEGINNING IRREVERSIBLE RESOURCE DESTRUCTION"
          echo "::warning title=Target Configuration::ğŸ“ Configuration: $config"
          echo "::warning title=Target tfvars::ğŸ“„ tfvars file: $tfvars_file.tfvars"
          echo "::warning title=Resource Count::ğŸ—‘ï¸ Destroying $resource_count resources"
          echo "::warning title=Timestamp::ğŸ“… Destruction started: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          
          # === WORKING DIRECTORY CONFIRMATION ===
          # Ensure proper working directory for destroy execution
          cd "configurations/$config"
          echo "::notice title=Working Directory::ğŸ“‚ Operating in: $(pwd)"
          
          # === TERRAFORM DESTROY EXECUTION ===
          # Execute terraform destroy with comprehensive monitoring and error handling
          echo "::warning title=Terraform Destroy::ğŸ”¨ Executing terraform destroy with comprehensive monitoring..."
          
          # Start destroy operation with detailed output capture
          if terraform destroy \
            -var-file="tfvars/$tfvars_file.tfvars" \
            -auto-approve \
            -detailed-exitcode 2>&1 | tee destroy_execution_output.txt; then
            
            # === DESTROY SUCCESS HANDLING ===
            # Process successful destroy operation
            destroy_exit_code=${PIPESTATUS[0]}
            
            echo "::notice title=Destroy Success::âœ… Terraform destroy operation completed successfully"
            echo "::notice title=Exit Code::ğŸ“Š Terraform destroy exit code: $destroy_exit_code"
            echo "::notice title=Completion::ğŸ Resource destruction completed at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
            
            # === DESTROY OUTPUT ANALYSIS ===
            # Analyze destroy output for comprehensive reporting
            echo "::notice title=Destroy Analysis::ğŸ“Š Analyzing destroy operation results..."
            
            # Count destroyed resources from output
            destroyed_count=$(grep -c "destroyed" destroy_execution_output.txt 2>/dev/null || echo "0")
            
            echo "::notice title=Destruction Summary::ğŸ“‹ Destroy Operation Summary:"
            echo "::notice title=Resources Destroyed::ğŸ—‘ï¸ $destroyed_count resources successfully destroyed"
            echo "::notice title=Operation Status::âœ… All targeted resources removed from infrastructure"
            
            # === DESTROY OUTPUT DISPLAY ===
            # Display comprehensive destroy output for audit and verification
            echo "::notice title=Destroy Output::ğŸ“‹ Complete Destroy Operation Output:"
            echo "::group::Terraform Destroy Execution Output"
            cat destroy_execution_output.txt 2>/dev/null || echo "Could not display destroy output"
            echo "::endgroup::"
            
          else
            # === DESTROY FAILURE HANDLING ===
            # Handle destroy operation failures with comprehensive error analysis and guidance
            destroy_exit_code=$?
            
            echo "::error title=Destroy Failed::âŒ TERRAFORM DESTROY OPERATION FAILED"
            echo "::error title=Operation Failure::ğŸš¨ Resource destruction did not complete successfully"
            echo "::error title=Exit Code::ğŸ”¢ Terraform destroy exited with code: $destroy_exit_code"
            echo "::error title=Failure Timestamp::ğŸ“… Destruction failed at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
            
            # === COMPREHENSIVE ERROR DIAGNOSTICS ===
            # Provide detailed troubleshooting guidance for destroy failures
            echo "::error title=Error Analysis::ğŸ” COMPREHENSIVE DESTROY FAILURE DIAGNOSTICS"
            echo "::error title=Common Causes::ğŸ“‹ Common terraform destroy failure causes:"
            
            echo "::error title=Cause 1::ğŸ”’ Resource Protection Policies"
            echo "::error title=Details 1::Power Platform admin policies preventing resource deletion"
            echo "::error title=Solution 1::Check Power Platform admin center for deletion policies"
            
            echo "::error title=Cause 2::ğŸ”— Resource Dependencies"
            echo "::error title=Details 2::Complex resource dependencies blocking destruction order"
            echo "::error title=Solution 2::Review resource relationships and dependency chains"
            
            echo "::error title=Cause 3::ğŸŒ Network Connectivity"
            echo "::error title=Details 3::Network connectivity issues during resource deletion"
            echo "::error title=Solution 3::Verify network connectivity and retry operation"
            
            echo "::error title=Cause 4::ğŸ’¾ State File Conflicts"
            echo "::error title=Details 4::State file corruption or concurrent access conflicts"
            echo "::error title=Solution 4::Check state file integrity and clear any locks"
            
            echo "::error title=Cause 5::ğŸ—ï¸ Service Limits"
            echo "::error title=Details 5::Power Platform service limits during bulk deletion"
            echo "::error title=Solution 5::Consider destroying resources in smaller batches"
            
            echo "::error title=Cause 6::â±ï¸ Timeout Issues"
            echo "::error title=Details 6::Long-running deletions exceeding timeout limits"
            echo "::error title=Solution 6::Increase timeout or destroy in phases"
            
            # === RECOVERY GUIDANCE ===
            # Provide comprehensive recovery and troubleshooting guidance
            echo "::error title=Recovery Actions::ğŸ”§ RECOMMENDED RECOVERY ACTIONS"
            echo "::error title=Action 1::ğŸ” Review Power Platform Admin Center for resource status"
            echo "::error title=Admin Center::ğŸ“š https://admin.powerplatform.microsoft.com/"
            echo "::error title=Action 2::ğŸ”„ Re-run workflow after addressing identified issues"
            echo "::error title=Action 3::ğŸ’¾ Check state backup created during validation for recovery"
            echo "::error title=Action 4::ğŸ”’ Verify resource protection policies and permissions"
            echo "::error title=Action 5::ğŸ“ Contact Power Platform support for persistent issues"
            
            # === ERROR OUTPUT DISPLAY ===
            # Display detailed error output for troubleshooting
            echo "::group::Terraform Destroy Error Output"
            cat destroy_execution_output.txt 2>/dev/null || echo "No error output available"
            echo "::endgroup::"
            
            exit 1
          fi
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 8: POST-DESTROY STATE VERIFICATION AND CLEANUP VALIDATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Comprehensive verification of destroy operation completeness and state cleanup
      
      - name: Verify Complete State Cleanup
        run: |
          echo "::notice title=State Verification::ğŸ” Verifying complete state cleanup after destroy operation"
          
          # === VERIFICATION CONTEXT SETUP ===
          # Extract verification parameters and context
          config="${{ needs.terraform-validate.outputs.configuration }}"
          original_count="${{ needs.terraform-validate.outputs.resource-count }}"
          
          echo "::notice title=Verification Starting::ğŸ“Š Beginning post-destroy state verification..."
          echo "::notice title=Configuration::ğŸ“ $config"
          echo "::notice title=Original Resources::ğŸ“Š Resources before destroy: $original_count"
          
          # === WORKING DIRECTORY SETUP ===
          # Navigate to configuration directory for verification
          cd "configurations/$config"
          
          # === COMPREHENSIVE STATE ANALYSIS ===
          # Perform detailed analysis of post-destroy state
          echo "::notice title=State Analysis::ğŸ“‹ Analyzing post-destroy Terraform state..."
          
          # Check final state for any remaining resources
          remaining_resources=$(terraform state list 2>/dev/null || echo "")
          remaining_count=$(echo "$remaining_resources" | grep -v '^$' | wc -l || echo "0")
          
          # === VERIFICATION RESULTS DISPLAY ===
          # Display comprehensive verification results
          echo "::notice title=Verification Results::ğŸ“Š Post-Destroy State Verification Results:"
          
          echo "::group::Complete State Verification Report"
          echo "Configuration: $config"
          echo "Resources before destroy: $original_count"
          echo "Resources after destroy: $remaining_count"
          echo "State cleanup status: $([ $remaining_count -eq 0 ] && echo "âœ… Complete" || echo "âš ï¸ Incomplete")"
          
          if [ $remaining_count -gt 0 ]; then
            echo ""
            echo "Remaining resources in state:"
            echo "$remaining_resources"
            echo ""
            echo "âš ï¸ Manual cleanup may be required for remaining resources"
          else
            echo ""
            echo "âœ… State is completely clean - no resources remaining"
            echo "âœ… All targeted resources successfully destroyed"
          fi
          echo "::endgroup::"
          
          # === CONDITIONAL RESULT REPORTING ===
          # Report results based on cleanup completeness
          if [ $remaining_count -gt 0 ]; then
            # === INCOMPLETE CLEANUP HANDLING ===
            # Handle scenarios where some resources remain in state
            echo "::warning title=Incomplete Cleanup::âš ï¸ INCOMPLETE STATE CLEANUP DETECTED"
            echo "::warning title=Remaining Resources::ğŸ—‘ï¸ $remaining_count resource(s) still remain in state"
            echo "::warning title=Manual Action::ğŸ‘¤ Manual cleanup may be required for complete removal"
            
            # === GUIDANCE FOR REMAINING RESOURCES ===
            # Provide guidance for handling remaining resources
            echo "::warning title=Common Causes::ğŸ“‹ Common causes for remaining resources:"
            echo "::warning title=Cause 1::ğŸ”’ Protected resources requiring manual removal"
            echo "::warning title=Cause 2::ğŸ”— Dependency constraints preventing automatic deletion"
            echo "::warning title=Cause 3::ğŸ—ï¸ Power Platform service-managed resources"
            echo "::warning title=Cause 4::âš ï¸ Partial failure during bulk destruction"
            
            echo "::warning title=Recommended Actions::ğŸ”§ Recommended cleanup actions:"
            echo "::warning title=Action 1::ğŸ” Review remaining resources in Power Platform admin center"
            echo "::warning title=Action 2::ğŸ‘¤ Manually remove protected or dependent resources"
            echo "::warning title=Action 3::ğŸ”„ Re-run destroy operation for remaining resources"
            echo "::warning title=Action 4::ğŸ’¾ Update state file if resources were manually removed"
            
          else
            # === COMPLETE CLEANUP SUCCESS ===
            # Celebrate successful complete cleanup
            echo "::notice title=Complete Success::âœ… COMPLETE STATE CLEANUP ACHIEVED"
            echo "::notice title=Clean State::ğŸ§¹ All resources successfully destroyed and removed from state"
            echo "::notice title=Perfect Cleanup::ğŸ¯ State is completely clean with zero remaining resources"
            echo "::notice title=Success Summary::ğŸ“Š Destroyed $original_count resources successfully"
          fi
          
          # === VERIFICATION COMPLETION ===
          # Mark verification phase as complete
          echo "::notice title=Verification Complete::âœ… Post-destroy state verification completed"
          echo "::notice title=Cleanup Status::$([ $remaining_count -eq 0 ] && echo "ğŸ§¹ Complete" || echo "âš ï¸ Partial ($remaining_count remaining)")"
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 9: POST-DESTROY AUDIT TRAIL AND METADATA GENERATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Create comprehensive audit trail and compliance metadata for destroy operation
      
      - name: Create Post-Destroy Audit Trail
        run: |
          echo "::notice title=Audit Trail::ğŸ“‹ Creating comprehensive post-destroy audit trail and compliance metadata"
          
          # === AUDIT CONTEXT SETUP ===
          # Establish audit parameters and metadata context
          config="${{ needs.terraform-validate.outputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          timestamp=$(date +"%Y%m%d_%H%M%S")
          original_count="${{ needs.terraform-validate.outputs.resource-count }}"
          backup_created="${{ needs.terraform-validate.outputs.backup-created }}"
          
          echo "::notice title=Audit Generation::ğŸ“Š Generating comprehensive audit trail..."
          echo "::notice title=Configuration::ğŸ“ $config"
          echo "::notice title=tfvars File::ğŸ“„ $tfvars_file"
          echo "::notice title=Timestamp::â° $timestamp"
          
          # === WORKING DIRECTORY SETUP ===
          # Navigate to configuration directory for audit operations
          cd "configurations/$config"
          
          # === POST-DESTROY STATE ANALYSIS ===
          # Analyze final state for audit trail generation
          remaining_resources=$(terraform state list 2>/dev/null || echo "")
          remaining_count=$(echo "$remaining_resources" | grep -v '^$' | wc -l || echo "0")
          cleanup_complete=$([ $remaining_count -eq 0 ] && echo "true" || echo "false")
          
          # === AUDIT DIRECTORY CREATION ===
          # Create structured audit directory for organized documentation
          audit_dir="../../audit/destroy_$config_$tfvars_file_$timestamp"
          echo "::notice title=Audit Directory::ğŸ“‚ Creating audit directory: $audit_dir"
          mkdir -p "$audit_dir"
          
          # === POST-DESTROY STATE SNAPSHOT ===
          # Create final state snapshot for audit and compliance
          echo "::notice title=State Snapshot::ğŸ’¾ Creating post-destroy state snapshot..."
          
          # Capture final state information
          terraform show -json > "$audit_dir/post_destroy_state.json" 2>/dev/null || echo '{"values": null}' > "$audit_dir/post_destroy_state.json"
          terraform show > "$audit_dir/post_destroy_state.txt" 2>/dev/null || echo "No state" > "$audit_dir/post_destroy_state.txt"
          
          # === COMPREHENSIVE AUDIT METADATA GENERATION ===
          # Generate detailed audit metadata for compliance and tracking
          echo "::notice title=Metadata Generation::ğŸ“‹ Creating comprehensive audit metadata..."
          
          cat > "$audit_dir/destroy_audit_metadata.json" <<EOF
          {
            "operation": {
              "type": "terraform_destroy",
              "timestamp": "$timestamp",
              "completion_time": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "configuration": "$config",
              "tfvars_file": "$tfvars_file",
              "status": "completed"
            },
            "execution_context": {
              "actor": "${{ github.actor }}",
              "run_id": "${{ github.run_id }}",
              "run_number": "${{ github.run_number }}",
              "workflow_ref": "${{ github.ref }}",
              "commit_sha": "${{ github.sha }}",
              "repository": "${{ github.repository }}"
            },
            "resource_impact": {
              "resources_before_destroy": $original_count,
              "resources_after_destroy": $remaining_count,
              "resources_successfully_destroyed": $((original_count - remaining_count)),
              "cleanup_complete": $cleanup_complete,
              "remaining_resources": $([ $remaining_count -gt 0 ] && echo "true" || echo "false")
            },
            "safety_measures": {
              "validation_performed": true,
              "backup_created": $backup_created,
              "final_confirmation_given": true,
              "mandatory_delay_observed": true,
              "force_destroy_used": ${{ github.event.inputs.force_destroy == 'true' }}
            },
            "compliance": {
              "audit_trail_created": true,
              "metadata_generated": true,
              "state_snapshots_captured": true,
              "execution_logs_preserved": true
            }
          }
          EOF
          
          echo "::notice title=Audit Metadata::âœ… Comprehensive audit metadata generated successfully"
          
          # === EXECUTION LOG PRESERVATION ===
          # Preserve execution logs for audit and troubleshooting
          echo "::notice title=Log Preservation::ğŸ“ Preserving execution logs for audit trail..."
          
          # Copy destroy execution output if available
          if [ -f "destroy_execution_output.txt" ]; then
            cp "destroy_execution_output.txt" "$audit_dir/destroy_execution_log.txt"
            echo "::notice title=Execution Log::âœ… Destroy execution log preserved"
          fi
          
          # === REMAINING RESOURCES DOCUMENTATION ===
          # Document any remaining resources for follow-up actions
          if [ $remaining_count -gt 0 ]; then
            echo "::notice title=Remaining Resources::ğŸ“‹ Documenting remaining resources for follow-up..."
            echo "$remaining_resources" > "$audit_dir/remaining_resources.txt"
            echo "::warning title=Follow-up Required::âš ï¸ Remaining resources documented for manual cleanup"
          fi
          
          # === GIT INTEGRATION FOR AUDIT PERSISTENCE ===
          # Commit audit trail to repository for persistent compliance documentation
          echo "::notice title=Git Integration::ğŸ”„ Integrating audit trail with version control..."
          
          cd ../.. # Return to repository root
          
          # Configure git for audit commits
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          
          # Add audit files to git
          git add "$audit_dir/"
          
          # Commit audit trail with comprehensive message
          audit_commit_message="ğŸ” Post-destroy audit trail: $config ($tfvars_file) - $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          if [ $cleanup_complete = "true" ]; then
            audit_commit_message="$audit_commit_message - Complete cleanup âœ…"
          else
            audit_commit_message="$audit_commit_message - Partial cleanup ($remaining_count remaining) âš ï¸"
          fi
          
          if git commit -m "$audit_commit_message" 2>/dev/null; then
            echo "::notice title=Audit Committed::âœ… Audit trail committed to version control successfully"
            echo "::notice title=Compliance::ğŸ“Š Comprehensive audit documentation available for compliance"
          else
            echo "::warning title=Audit Commit Issue::âš ï¸ Could not commit audit trail to version control"
          fi
          
          # === AUDIT COMPLETION SUMMARY ===
          # Provide comprehensive summary of audit trail creation
          echo "::notice title=Audit Complete::âœ… Post-destroy audit trail generation completed"
          echo "::notice title=Audit Location::ğŸ“‚ Audit trail stored in: $audit_dir"
          echo "::notice title=Compliance Ready::ğŸ“Š Comprehensive compliance documentation generated"
          echo "::notice title=Audit Contents::ğŸ“‹ Audit trail includes:"
          echo "::notice title=Content 1::ğŸ“„ Post-destroy state snapshots (JSON and text)"
          echo "::notice title=Content 2::ğŸ“Š Comprehensive operation metadata"
          echo "::notice title=Content 3::ğŸ“ Execution logs and output preservation"
          echo "::notice title=Content 4::ğŸ” Remaining resources documentation (if applicable)"
          echo "::notice title=Content 5::âš¡ Safety measures and compliance verification"

      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 10: COMPREHENSIVE WORKFLOW SUMMARY AND STATUS REPORTING
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Generate comprehensive summary for user awareness and audit documentation
      
      - name: Generate Comprehensive Workflow Summary
        if: always()                                  # Always generate summary regardless of previous step outcomes
        run: |
          echo "::notice title=Summary Generation::ğŸ“Š Generating comprehensive workflow execution summary"
          
          # === SUMMARY CONTEXT SETUP ===
          # Extract comprehensive context for summary generation
          config="${{ needs.terraform-validate.outputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          original_count="${{ needs.terraform-validate.outputs.resource-count }}"
          backup_created="${{ needs.terraform-validate.outputs.backup-created }}"
          force_mode="${{ github.event.inputs.force_destroy }}"
          
          echo "::notice title=Summary Context::ğŸ“‹ Workflow execution context:"
          echo "::notice title=Configuration::ğŸ“ $config"
          echo "::notice title=tfvars File::ğŸ“„ $tfvars_file"
          echo "::notice title=Original Resources::ğŸ“Š $original_count"
          echo "::notice title=Backup Created::ğŸ’¾ $backup_created"
          echo "::notice title=Force Mode::âš¡ $force_mode"
          
          # === GITHUB STEP SUMMARY GENERATION ===
          # Create comprehensive summary for GitHub Actions UI
          echo "::notice title=GitHub Summary::ğŸ“‹ Creating comprehensive GitHub step summary..."
          
          # === SUMMARY HEADER ===
          # Create professional summary header with operation details
          echo "# ğŸš¨ Terraform Destroy Operation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ğŸ“‹ Operation Overview" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| **Parameter** | **Value** |" >> $GITHUB_STEP_SUMMARY
          echo "|---------------|-----------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Configuration** | \`$config\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **tfvars File** | \`$tfvars_file.tfvars\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Original Resource Count** | $original_count |" >> $GITHUB_STEP_SUMMARY
          echo "| **Execution Timestamp** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |" >> $GITHUB_STEP_SUMMARY
          echo "| **Executed By** | @${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Workflow Run** | #${{ github.run_number }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Force Mode** | $([ "$force_mode" = "true" ] && echo "âš¡ **ENABLED**" || echo "Disabled") |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === SAFETY MEASURES SUMMARY ===
          # Document comprehensive safety measures implemented
          echo "## ğŸ›¡ï¸ Safety Measures Implemented" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… **Input Validation**: Rigorous confirmation and parameter verification" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… **State Analysis**: Comprehensive resource inventory and impact assessment" >> $GITHUB_STEP_SUMMARY
          echo "- $([ "$backup_created" = "true" ] && echo "âœ…" || echo "âš ï¸") **State Backup**: $([ "$backup_created" = "true" ] && echo "Automated backup created for recovery" || echo "No backup needed (empty state)")" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… **Final Confirmation**: Mandatory 5-second delay with impact warning" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… **Secure Authentication**: OIDC-based authentication with production environment protection" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… **Network Security**: Just-in-time network access with automatic cleanup" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… **Audit Trail**: Comprehensive execution logging and compliance documentation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === CONDITIONAL RESULT REPORTING ===
          # Report results based on execution outcome (check if we're in destroy job context)
          cd "configurations/$config" 2>/dev/null || {
            echo "## âš ï¸ Execution Status" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Status**: Configuration directory not accessible for final verification" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            return 0
          }
          
          # Check final state if accessible
          remaining_resources=$(terraform state list 2>/dev/null || echo "")
          remaining_count=$(echo "$remaining_resources" | grep -v '^$' | wc -l || echo "0")
          destroyed_count=$((original_count - remaining_count))
          
          # === EXECUTION RESULTS SUMMARY ===
          # Display comprehensive execution results
          echo "## ğŸ“Š Execution Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| **Metric** | **Value** |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|-----------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Resources Before Destroy** | $original_count |" >> $GITHUB_STEP_SUMMARY
          echo "| **Resources After Destroy** | $remaining_count |" >> $GITHUB_STEP_SUMMARY
          echo "| **Resources Successfully Destroyed** | $destroyed_count |" >> $GITHUB_STEP_SUMMARY
          echo "| **Cleanup Status** | $([ $remaining_count -eq 0 ] && echo "âœ… **Complete**" || echo "âš ï¸ **Partial** ($remaining_count remaining)") |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === CONDITIONAL GUIDANCE ===
          # Provide guidance based on cleanup completeness
          if [ $remaining_count -gt 0 ]; then
            echo "## âš ï¸ Manual Cleanup Required" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**$remaining_count resource(s) still remain in Terraform state after destroy operation.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Recommended Actions:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "1. **Review Resources**: Check remaining resources in Power Platform admin center" >> $GITHUB_STEP_SUMMARY
            echo "2. **Manual Removal**: Remove protected or dependent resources manually if needed" >> $GITHUB_STEP_SUMMARY
            echo "3. **State Cleanup**: Run \`terraform state rm\` to clean up orphaned state entries" >> $GITHUB_STEP_SUMMARY
            echo "4. **Re-run Destroy**: Consider re-running destroy after manual cleanup" >> $GITHUB_STEP_SUMMARY
          else
            echo "## âœ… Complete Success" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**All $original_count resources were successfully destroyed and removed from state.**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The infrastructure has been completely cleaned up with zero remaining resources." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === IMPORTANT NOTES SECTION ===
          # Provide comprehensive operational notes and guidance
          echo "## âš ï¸ Important Notes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Irreversible Action**: Resources have been permanently deleted from Power Platform" >> $GITHUB_STEP_SUMMARY
          echo "- **State Management**: Terraform state updated to reflect destroyed resources" >> $GITHUB_STEP_SUMMARY
          echo "- **Network Security**: JIT network access was used for secure backend connectivity" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Recreation**: Use terraform plan/apply with same configuration to recreate" >> $GITHUB_STEP_SUMMARY
          echo "- **Audit Trail**: This destruction operation is logged in workflow history" >> $GITHUB_STEP_SUMMARY
          echo "- **Configuration Preserved**: Configuration files remain unchanged for future use" >> $GITHUB_STEP_SUMMARY
          if [ "$backup_created" = "true" ]; then
            echo "- **Backup Available**: State backup available for emergency recovery within retention period" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # === ADDITIONAL RESOURCES SECTION ===
          # Provide helpful resources and references
          echo "## ğŸ“š Additional Resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ”— [Power Platform Admin Center](https://admin.powerplatform.microsoft.com/)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ“– [Terraform Destroy Documentation](https://www.terraform.io/docs/commands/destroy.html)" >> $GITHUB_STEP_SUMMARY
          echo "- ğŸ”§ [Power Platform Governance Best Practices](https://docs.microsoft.com/en-us/power-platform/guidance/)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          cd - > /dev/null
          echo "::notice title=Summary Complete::âœ… Comprehensive workflow summary generated successfully"
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 11: METADATA ARTIFACT PRESERVATION FOR COMPLIANCE
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Upload comprehensive metadata artifacts for audit trails and compliance documentation
      
      - name: Upload Destroy Metadata Artifacts
        if: always()                                  # Always upload artifacts for audit trail preservation
        uses: actions/upload-artifact@v4
        with:
          # === ARTIFACT CONFIGURATION ===
          # Comprehensive artifact naming and retention for compliance
          name: terraform-destroy-metadata-${{ github.event.inputs.configuration }}-${{ github.run_number }}
          path: |
            audit/destroy_*/*.json
            audit/destroy_*/*.txt
            configurations/*/destroy_*.txt
            configurations/*/post_destroy_*.json
            backups/destroy_*/backup_metadata.json
          retention-days: 30                          # Extended retention for audit and compliance requirements
          description: 'Comprehensive Terraform destroy execution metadata for ${{ github.event.inputs.configuration }} configuration - includes audit trails, state snapshots, and compliance documentation'
        # Purpose: Preserve comprehensive execution metadata for audit trails and compliance
        # Contents: Audit trails, state snapshots, execution logs, and compliance documentation
    
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # STEP 12: SECURITY CLEANUP AND FINALIZATION
      # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      # Remove just-in-time network access and ensure secure completion
      
      - name: Remove JIT Network Access and Security Cleanup
        if: always()                                  # Always execute security cleanup regardless of previous outcomes
        uses: ./.github/actions/jit-network-access
        with:
          action: 'remove'                            # Remove network access for security compliance
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}    # Target storage account
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}      # Target resource group
        # Purpose: Remove just-in-time network access for security compliance and cleanup
        # Execution: Always runs to ensure network security even if destroy operations fail
        # Security: Ensures minimal network exposure and proper cleanup procedures
    
      # === FINAL SECURITY AND COMPLIANCE VERIFICATION ===
      # Provide final security status and compliance confirmation
      - name: Final Security and Compliance Status
        if: always()                                  # Always provide final status regardless of execution outcome
        run: |
          echo "::notice title=Security Cleanup::ğŸ”’ Final security cleanup and compliance verification"
          
          # === SECURITY STATUS SUMMARY ===
          # Comprehensive security status reporting
          echo "::notice title=Security Status::âœ… Security cleanup completed successfully"
          echo "::notice title=Network Access::ğŸ” Just-in-time network access removed"
          echo "::notice title=Authentication::ğŸ”‘ OIDC authentication sessions closed"
          echo "::notice title=Compliance::ğŸ“Š Audit trails and metadata preserved"
          
          # === WORKFLOW COMPLETION CONFIRMATION ===
          # Final workflow status and completion confirmation
          echo "::notice title=Workflow Complete::âœ… TERRAFORM DESTROY WORKFLOW COMPLETED"
          echo "::notice title=Operation::ğŸš¨ Infrastructure destruction operation finalized"
          echo "::notice title=Timestamp::ğŸ“… Workflow completed: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "::notice title=Security::ğŸ”’ All security measures implemented and cleanup completed"
          echo "::notice title=Audit Trail::ğŸ“‹ Comprehensive audit documentation preserved"
          echo "::notice title=Compliance::âœ… Operation completed with full compliance documentation"
