---
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TERRAFORM DESTROY WORKFLOW FOR POWER PLATFORM GOVERNANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Enables secure, auditable destruction of Terraform-managed Power Platform resources.
#
# ðŸŽ¯ WHY THIS EXISTS:
# - Governance requirement: Enforces policy for safe, auditable resource destruction
# - Business problem: Prevents accidental/untracked deletion, ensures audit and recovery
# - Operational benefit: Manual-only trigger, explicit confirmation, backup, and audit trail
#
# ðŸ”’ SECURITY DECISIONS:
# - OIDC authentication eliminates stored credentials for destroy operations
# - Environment protection ensures all destroys are auditable and require production-level secrets
# - State backup prevents data loss before destructive actions
# - Explicit confirmation required to prevent accidental destruction
#
# âš™ï¸ OPERATIONAL CONTEXT:
# - Concurrency control prevents conflicting destroy operations and state corruption
# - Timeout values account for complex resource destruction
# - Never cancel destroys to avoid incomplete state changes
# - Pre-destroy validation ensures resources exist and inputs are valid
#
# ðŸ“‹ INTEGRATION REQUIREMENTS:
# - Depends on reusable-terraform-base for standardized destroy process
# - Requires Power Platform OIDC configuration for resource access
# - Uses validated composite actions for network access and initialization
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Terraform Destroy

# === CONCURRENCY PROTECTION ===
# Prevents conflicting destroy operations and state corruption
concurrency:
  group: terraform-${{ github.event.inputs.configuration || 'default' }}-${{ github.event.inputs.tfvars_file || 'default' }}-destroy-${{ github.ref }}
  cancel-in-progress: false  # Never cancel running Terraform operations to avoid incomplete state changes

# === WORKFLOW TRIGGER AND INPUTS ===
# Manual workflow dispatch with explicit confirmation for destructive operations
on:
  workflow_dispatch:
    inputs:
      configuration:
        description: 'Configuration to destroy (resource management configurations only)'
        required: true
        type: choice
        options:
          - 'res-dlp-policy'
          - 'ptn-environment'
        # WHY: Only allows safe, non-foundational configs to be destroyed
        # SECURITY: Prevents destruction of critical infrastructure components
        # VALIDATION: Must exist in configurations/ and contain .tf files

      tfvars_file:
        description: 'tfvars file name without extension (e.g., dlp-finance, env-production)'
        required: true
        type: string
        # WHY: Targets specific resource instance for precise, auditable destruction
        # GOVERNANCE: Ensures correct context for resource identification
        # VALIDATION: Must match a file in tfvars/ subdirectory

      confirmation:
        description: 'Type "DESTROY" to confirm resource destruction (case sensitive)'
        required: true
        type: string
        # WHY: Explicit, case-sensitive confirmation required for destructive operations
        # SECURITY: Prevents accidental destruction through UI misclicks
        # GOVERNANCE: Creates explicit audit trail of user intent

      backup_state:
        description: 'Create state backup before destroy (recommended for production)'
        required: true
        type: boolean
        default: true
        # WHY: Ensures disaster recovery and auditability before destructive actions
        # GOVERNANCE: Provides rollback capability for audit compliance
        # SECURITY: Protects against accidental state loss

      force_destroy:
        description: 'Force destroy even if plan shows no resources (use with caution)'
        required: false
        type: boolean
        default: false
        # WHY: Allows emergency cleanup of orphaned state or resources
        # SECURITY: Disabled by default to prevent misuse
        # GOVERNANCE: Emergency override with explicit user consent

# Dynamic run name for auditability and traceability
run-name: ðŸš¨ Terraform DESTROY ${{ github.event.inputs.configuration }} (${{ github.event.inputs.tfvars_file }}) by @${{ github.actor }}

# === PERMISSIONS AND SECURITY ===
# Principle of least privilege with backup capability
permissions:
  id-token: write   # Required for GitHub OIDC token generation
  contents: write   # Required for state backup commits and artifact management
  actions: read     # Required for reusable workflow execution summary

jobs:
  # === PRE-DESTROY VALIDATION AND CONFIRMATION ===
  # Critical safety checks before allowing destruction to proceed
  pre-destroy-validation:
    name: ðŸ” Validation and Safety Checks
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment: production  # Production environment protection for sensitive operations

    # Output values for conditional execution control
    outputs:
      validation-passed: ${{ steps.validate-confirmation.outputs.validation-passed }}
      resources-exist: ${{ steps.check-resources.outputs.resources-exist }}
      resource-count: ${{ steps.check-resources.outputs.resource-count }}
      validation-metadata: ${{ steps.generate-metadata.outputs.validation-metadata }}

    steps:
      # === CHECKOUT REPOSITORY ===
      - name: Checkout Repository
        uses: actions/checkout@v4

      # === CRITICAL CONFIRMATION VALIDATION ===
      # Rigorous validation of user input to prevent accidental destruction
      - name: Validate Destroy Confirmation
        id: validate-confirmation
        run: |
          echo "::notice title=Confirmation Validation::ðŸ” Validating destruction confirmation..."

          confirmation="${{ github.event.inputs.confirmation }}"

          if [ "$confirmation" != "DESTROY" ]; then
            echo "::error title=Invalid Confirmation::âŒ Confirmation validation failed"
            echo "::error title=Required Input::You must type 'DESTROY' (case sensitive) to confirm resource destruction"
            echo "::error title=Provided Input::Received: '$confirmation'"
            echo "::error title=Security Notice::This safety measure prevents accidental resource destruction"
            exit 1
          fi

          echo "::warning title=Destruction Confirmed::âš ï¸ User has provided valid destruction confirmation"
          echo "::notice title=Authorization::âœ… Confirmation validation passed - proceeding with safety checks"
          echo "validation-passed=true" >> $GITHUB_OUTPUT

      # === INPUT VALIDATION ===
      # Validate configuration and tfvars file existence
      - name: Validate Inputs
        run: |
          config="${{ github.event.inputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"

          echo "::notice title=Input Validation::ðŸ“‹ Validating destroy inputs..."

          # Validate configuration directory
          config_path="configurations/$config"
          if [ ! -d "$config_path" ]; then
            echo "::error title=Configuration Not Found::âŒ Configuration directory '$config_path' does not exist"
            exit 1
          fi

          # Validate tfvars file
          tfvars_path="$config_path/tfvars/$tfvars_file.tfvars"
          if [ ! -f "$tfvars_path" ]; then
            echo "::error title=tfvars File Not Found::âŒ Specified tfvars file '$tfvars_path' does not exist"
            exit 1
          fi

          echo "::notice title=Input Validation Complete::âœ… All input validation checks passed"

      # === AZURE OIDC AUTHENTICATION ===
      - name: Azure Login with OIDC
        uses: azure/login@v2.3.0
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # === JIT NETWORK ACCESS ===
      - name: Add JIT Network Access
        uses: ./.github/actions/jit-network-access
        with:
          action: 'add'
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

      # === TERRAFORM SETUP ===
      - name: Cache Terraform Providers
        uses: actions/cache@v4
        with:
          path: |
            ~/.terraform.d/plugin-cache
            .terraform/providers
          # WHY: Cache key based on lock file hash for automatic invalidation on version changes
          key: terraform-${{ runner.os }}-${{ hashFiles('.terraform.lock.hcl', '**/configurations/**/.terraform.lock.hcl') }}
          restore-keys: |
            terraform-${{ runner.os }}-

      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}
          terraform_wrapper: false

      # WHY: Configure provider cache for faster initialization during destroy validation
      - name: Configure Provider Cache
        run: |
          mkdir -p ~/.terraform.d/plugin-cache
          echo 'plugin_cache_dir = "$HOME/.terraform.d/plugin-cache"' > ~/.terraform.d/terraformrc
          echo "TF_CLI_CONFIG_FILE=$HOME/.terraform.d/terraformrc" >> $GITHUB_ENV

      # === TERRAFORM INITIALIZATION ===
      - name: Initialize Terraform
        uses: ./.github/actions/terraform-init-with-backend
        env:
          ARM_STORAGE_ACCOUNT_NAME: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          ARM_CONTAINER_NAME: ${{ secrets.TERRAFORM_CONTAINER }}
          ARM_RESOURCE_GROUP_NAME: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true
          POWER_PLATFORM_USE_OIDC: true
          POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}
          POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
        with:
          configuration: ${{ github.event.inputs.configuration }}
          tfvars-file: ${{ github.event.inputs.tfvars_file }}

      # === GENERATE WORKFLOW METADATA ===
      - name: Generate Workflow Metadata
        uses: ./.github/actions/generate-workflow-metadata
        id: generate-metadata
        with:
          operation: 'destroy'
          configuration: ${{ github.event.inputs.configuration }}
          tfvars-file: ${{ github.event.inputs.tfvars_file }}
          phase: 'validation'

      # === RESOURCE EXISTENCE CHECK ===
      # Check if resources exist in state before proceeding
      - name: Check Resource Existence
        id: check-resources
        run: |
          config="${{ github.event.inputs.configuration }}"
          cd "configurations/$config"

          echo "::notice title=Resource Check::ðŸ“Š Checking for resources in Terraform state..."

          # Check if state contains any resources
          if terraform show -json > state_output.json 2>/dev/null; then
            # Count managed resources
            resource_count=0
            if command -v jq >/dev/null 2>&1; then
              resource_count=$(jq -r '.values.root_module.resources[]? | select(.mode == "managed") | .address' state_output.json 2>/dev/null | wc -l || echo "0")
            else
              resource_count=$(terraform state list 2>/dev/null | wc -l || echo "0")
            fi

            if [ "$resource_count" -gt 0 ]; then
              echo "::warning title=Resources Found::âš ï¸ $resource_count resources found in state"
              echo "resources-exist=true" >> $GITHUB_OUTPUT
              echo "resource-count=$resource_count" >> $GITHUB_OUTPUT
            else
              echo "::notice title=No Resources::âœ… No managed resources found in state"
              echo "resources-exist=false" >> $GITHUB_OUTPUT
              echo "resource-count=0" >> $GITHUB_OUTPUT
            fi
          else
            echo "::notice title=No State::ðŸ“ No Terraform state found"
            echo "resources-exist=false" >> $GITHUB_OUTPUT
            echo "resource-count=0" >> $GITHUB_OUTPUT
          fi

      # === CLEANUP JIT ACCESS ===
      - name: Remove JIT Network Access
        if: always()
        uses: ./.github/actions/jit-network-access
        with:
          action: 'remove'
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

  # === TERRAFORM DESTROY EXECUTION ===
  # Uses reusable workflow for consistent destroy operation
  terraform-destroy:
    name: ðŸš¨ Execute Terraform Destroy
    needs: pre-destroy-validation
    # Only run if validation passed and (resources exist OR force destroy is enabled)
    if: |
      needs.pre-destroy-validation.outputs.validation-passed == 'true' &&
      (needs.pre-destroy-validation.outputs.resources-exist == 'true' || github.event.inputs.force_destroy == 'true')
    uses: ./.github/workflows/reusable-terraform-base.yml
    with:
      operation: 'destroy'
      configuration: ${{ github.event.inputs.configuration }}
      tfvars-file: ${{ github.event.inputs.tfvars_file }}
      create-state-backup: ${{ github.event.inputs.backup_state == 'true' }}
      auto-approve: true  # Required for destroy operations
      timeout-minutes: 25
      environment-name: 'production'
    secrets: inherit

  # === EXECUTION SUMMARY ===
  # Generate comprehensive execution summary for governance and audit
  execution-summary:
    name: "ðŸŽ¯ Execution Summary"
    needs: [pre-destroy-validation, terraform-destroy]
    uses: ./.github/workflows/reusable-execution-summary.yml
    if: always()
    with:
      workflow-name: "terraform-destroy"
      operation-type: "destroy"
      configuration: ${{ github.event.inputs.configuration }}
      output-filename: ""
      job-results: ${{ toJSON(needs) }}
      workflow-inputs: ${{ toJSON(github.event.inputs) }}
      include-troubleshooting: true
      include-technical-details: true
      summary-level: "detailed"
      artifact-retention-days: 30
