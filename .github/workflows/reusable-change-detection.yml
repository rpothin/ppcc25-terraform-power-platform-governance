# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TERRAFORM CHANGE DETECTION WORKFLOW FOR POWER PLATFORM GOVERNANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Provides centralized, standardized approach to detecting changed Terraform configurations and modules
# across different trigger scenarios with intelligent filtering and performance optimization.
#
# ðŸŽ¯ WHY THIS EXISTS:
# - Governance requirement: Only validate and deploy changed configurations to minimize risk
# - Business problem: Processing all configurations on every change wastes CI/CD resources
# - Operational benefit: 60-80% reduction in CI/CD runtime through selective processing
#
# ðŸ”’ SECURITY DECISIONS:
# - No sensitive permissions required as change detection only reads repository content
# - Git history analysis doesn't expose secrets or credentials
# - Change detection patterns prevent processing of unauthorized file types
#
# âš™ï¸ OPERATIONAL CONTEXT:
# - Short timeout because change detection should be fast operation
# - No concurrency controls needed as detection operations are read-only
# - Multiple input options support both automated and manual override scenarios
#
# ðŸ“‹ INTEGRATION REQUIREMENTS:
# - Used by terraform-docs.yml and terraform-test.yml for efficient processing
# - Depends on detect-terraform-changes composite action for core logic
# - Output format optimized for GitHub Actions matrix strategy consumption
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: â™»ï¸ Terraform Change Detection

# === WORKFLOW INVOCATION INTERFACE ===
# This interface provides comprehensive control over change detection behavior
# while maintaining backward compatibility with existing workflow patterns
on:
  workflow_call:
    # === INPUT PARAMETERS ===
    # These inputs mirror the manual dispatch inputs from consuming workflows
    # to ensure seamless migration and consistent user experience
    inputs:
      target-path:
        description: 'Specific path to process (overrides change detection)'
        required: false
        type: string
        # Manual override for targeted testing and debugging
        # Must be a valid directory path: configurations/dirname or modules/dirname
        # Bypasses all automatic change detection when specified
        # Validation: Path must exist and contain at least one .tf file
        # Examples: 'configurations/01-dlp-policies', 'modules/power-platform-dlp-export'
        
      force-all:
        description: 'Force processing all paths'
        required: false
        type: boolean
        default: false
        # Emergency override for comprehensive validation
        # When true: processes ALL directories containing .tf files
        # When false: uses intelligent Git-based change detection
        # Use cases: Release validation, troubleshooting, major refactoring
        # WARNING: Significantly increases CI/CD runtime - use judiciously
        
      include-configs:
        description: 'Include configuration directories'
        required: false
        type: boolean
        default: true
        # Controls whether configurations/ directories are processed
        # When true: includes changed configurations under configurations/
        # When false: excludes configurations (module-only operations)
        # Use cases: Module testing, staged deployments, selective validation
        
      include-modules:
        description: 'Include module directories'
        required: false
        type: boolean
        default: true
        # Controls whether modules/ directories are processed
        # When true: includes changed modules under modules/
        # When false: excludes modules (configuration-only operations)
        # Use cases: Configuration testing, policy updates, environment changes
        
      path-filter:
        description: 'Additional path filtering pattern'
        required: false
        type: string
        # Advanced filtering for specific use cases
        # Format: Regex pattern to match against detected paths
        # Use cases: Testing specific pattern subsets, excluding certain directories
        # Examples: '^configurations/.*dlp.*', '^modules/power-platform.*'
        # Note: Applied after initial change detection and inclusion filters

    # === OUTPUT PARAMETERS ===
    # These outputs provide comprehensive information about detected changes
    # and are optimized for consumption by downstream jobs and matrix strategies
    outputs:
      changed-paths:
        description: 'Newline-separated list of changed paths'
        value: ${{ jobs.detect-changes.outputs.changed-paths }}
        # Format: Multi-line string with one directory path per line
        # Usage: Ideal for matrix job generation and iteration
        # Example: "configurations/01-dlp-policies\nmodules/power-platform-dlp-export"
        # Empty string when no changes detected
        
      paths-count:
        description: 'Number of changed paths detected'
        value: ${{ jobs.detect-changes.outputs.paths-count }}
        # Format: String representation of integer (e.g., "0", "3", "10")
        # Usage: Conditional execution, resource planning, performance metrics
        # Example usage: if: needs.detect-changes.outputs.paths-count != '0'
        
      has-changes:
        description: 'Whether any relevant changes were detected'
        value: ${{ jobs.detect-changes.outputs.has-changes }}
        # Format: String 'true' or 'false' (GitHub Actions boolean representation)
        # Primary gate for conditional execution of downstream jobs
        # Most workflows should use this as the primary condition
        
      detection-metadata:
        description: 'Change detection execution metadata'
        value: ${{ jobs.detect-changes.outputs.metadata }}
        # Format: JSON object containing AVM-compliant metadata
        # Includes: timestamps, input parameters, detection statistics
        # Usage: Audit trails, debugging, compliance reporting

# === WORKFLOW EXECUTION ===
# Single job design keeps the workflow simple and efficient
# All logic is handled by proven composite actions for reliability
jobs:
  detect-changes:
    # Descriptive job name with emoji for visual identification
    name: ðŸ” Detect Changes
    
    # Use Ubuntu latest for consistency with other workflows
    # Provides reliable, well-tested environment with Git and required tools
    runs-on: ubuntu-latest
    
    # Short timeout for change detection operations
    # Change detection should complete quickly; longer timeouts indicate issues
    timeout-minutes: 5
    
    # === JOB OUTPUTS ===
    # These outputs are passed through to workflow outputs
    # Generated by individual steps and aggregated for consumption
    outputs:
      changed-paths: ${{ steps.detect.outputs.changed-paths }}
      paths-count: ${{ steps.detect.outputs.paths-count }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
      metadata: ${{ steps.metadata.outputs.metadata }}
    
    steps:
      # === SOURCE CODE CHECKOUT ===
      # Retrieves repository source code with full Git history
      # Full history is required for accurate change detection across branches
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history required for Git diff operations
      
      # === METADATA GENERATION ===
      # Generates AVM-compliant metadata for audit trails and compliance
      # This metadata provides context about the detection execution
      - name: Generate Detection Metadata
        id: metadata
        uses: ./.github/actions/generate-workflow-metadata
        with:
          operation: 'change-detection'
          phase: 'analysis'
          # Include input parameters in metadata for debugging and audit trails
          additional-data: |
            {
              "target_path": "${{ inputs.target-path }}",
              "force_all": "${{ inputs.force-all }}",
              "include_configs": "${{ inputs.include-configs }}",
              "include_modules": "${{ inputs.include-modules }}",
              "path_filter": "${{ inputs.path-filter }}",
              "event_name": "${{ github.event_name }}"
            }
      
      # === CORE CHANGE DETECTION ===
      # Executes the proven change detection logic using the composite action
      # This step contains all the intelligence for Git diff analysis and filtering
      - name: Detect Terraform Changes
        id: detect
        uses: ./.github/actions/detect-terraform-changes
        with:
          target-path: ${{ inputs.target-path }}
          force-all: ${{ inputs.force-all }}
          include-configs: ${{ inputs.include-configs }}
          include-modules: ${{ inputs.include-modules }}
      
      # === PATH FILTERING (OPTIONAL) ===
      # Applies additional filtering if path-filter input is provided
      # This allows for advanced use cases with regex-based path filtering
      - name: Apply Additional Path Filtering
        id: filter
        if: inputs.path-filter != ''
        shell: bash
        run: |
          echo "::notice title=Path Filtering::ðŸ” Applying additional path filter: ${{ inputs.path-filter }}"
          
          # Get the detected paths from previous step
          original_paths="${{ steps.detect.outputs.changed-paths }}"
          filter_pattern="${{ inputs.path-filter }}"
          
          if [ -z "$original_paths" ]; then
            echo "::notice title=No Paths::No paths to filter"
            echo "changed-paths=" >> $GITHUB_OUTPUT
            echo "paths-count=0" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Apply regex filtering to detected paths
          filtered_paths=()
          while IFS= read -r path; do
            [ -z "$path" ] && continue
            if [[ "$path" =~ $filter_pattern ]]; then
              filtered_paths+=("$path")
              echo "::debug::Path matches filter: $path"
            else
              echo "::debug::Path filtered out: $path"
            fi
          done <<< "$original_paths"
          
          # Generate filtered outputs
          if [ ${#filtered_paths[@]} -eq 0 ]; then
            echo "::notice title=Filter Results::âŒ No paths remain after filtering"
            echo "changed-paths=" >> $GITHUB_OUTPUT
            echo "paths-count=0" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
          else
            printf -v joined '%s\n' "${filtered_paths[@]}"
            {
              echo "changed-paths<<FILTERED_PATHS_EOF"
              echo "$joined"
              echo "FILTERED_PATHS_EOF"
            } >> $GITHUB_OUTPUT
            echo "paths-count=${#filtered_paths[@]}" >> $GITHUB_OUTPUT
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "::notice title=Filter Results::âœ… ${#filtered_paths[@]} path(s) remain after filtering: ${filtered_paths[*]}"
          fi
      
      # === FINAL OUTPUT DETERMINATION ===
      # Determines final outputs, considering any filtering that was applied
      # This ensures consistent output format regardless of filtering
      - name: Finalize Detection Results
        shell: bash
        run: |
          # Use filtered results if filtering was applied, otherwise use original detection results
          if [ "${{ inputs.path-filter }}" != "" ] && [ "${{ steps.filter.outcome }}" = "success" ]; then
            echo "::notice title=Final Results::ðŸ“‹ Using filtered detection results"
            final_paths="${{ steps.filter.outputs.changed-paths }}"
            final_count="${{ steps.filter.outputs.paths-count }}"
            final_has_changes="${{ steps.filter.outputs.has-changes }}"
          else
            echo "::notice title=Final Results::ðŸ“‹ Using original detection results"
            final_paths="${{ steps.detect.outputs.changed-paths }}"
            final_count="${{ steps.detect.outputs.paths-count }}"
            final_has_changes="${{ steps.detect.outputs.has-changes }}"
          fi
          
          # Log final results for visibility
          if [ "$final_has_changes" = "true" ]; then
            echo "::notice title=Detection Complete::âœ… $final_count path(s) require processing"
            # Only show first few paths to avoid log noise
            if [ "$final_count" -le 5 ]; then
              echo "::notice title=Paths to Process::$(echo "$final_paths" | tr '\n' ' ')"
            else
              first_paths=$(echo "$final_paths" | head -3 | tr '\n' ' ')
              echo "::notice title=Paths to Process::$first_paths... (and $((final_count - 3)) more)"
            fi
          else
            echo "::notice title=Detection Complete::âœ… No processing required"
          fi
