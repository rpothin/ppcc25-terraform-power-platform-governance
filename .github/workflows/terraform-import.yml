---
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TERRAFORM IMPORT WORKFLOW FOR POWER PLATFORM GOVERNANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Enables importing existing Power Platform resources into Terraform state for governance and automation.
#
# ðŸŽ¯ WHY THIS EXISTS:
# - Governance requirement: Transition ClickOps/manual resources to Infrastructure as Code (IaC)
# - Business problem: Existing resources created outside Terraform need to be governed and managed
# - Operational benefit: Enables consistent policy enforcement, auditability, and automation
#
# ðŸ”’ SECURITY DECISIONS:
# - OIDC authentication eliminates stored credentials for import operations
# - Environment protection ensures all imports are auditable and require production-level secrets
# - State backup prevents data loss during risky import operations
#
# âš™ï¸ OPERATIONAL CONTEXT:
# - Concurrency control prevents state corruption during imports
# - Timeout values account for complex resource import operations
# - Never cancel imports to avoid incomplete state changes
#
# ðŸ“‹ INTEGRATION REQUIREMENTS:
# - Depends on reusable-terraform-base for standardized import process
# - Requires Power Platform OIDC configuration for resource access
# - Uses validated composite actions for network access and initialization
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: Terraform Import

# === CONCURRENCY PROTECTION ===
# Prevents state corruption when multiple imports target the same configuration/tfvars
concurrency:
  group: terraform-${{ github.event.inputs.configuration || 'default' }}-${{ github.event.inputs.tfvars_file || 'default' }}-import-${{ github.ref }}
  cancel-in-progress: false  # Never cancel running Terraform operations to avoid incomplete state changes

# === WORKFLOW TRIGGER AND INPUTS ===
# Manual workflow dispatch for explicit governance control over imports
on:
  workflow_dispatch:
    inputs:
      configuration:
        description: 'Configuration to import the resource into (resource management configurations)'
        required: true
        type: choice
        options:
          - 'res-dlp-policy'
          - 'ptn-environment'
        # WHY: Scopes permissions and isolates blast radius for governance
        # VALIDATION: Must exist in configurations/ and contain .tf files
        # SECURITY: Used in state key generation to prevent cross-configuration access
        # EXAMPLES: 'res-dlp-policy', 'ptn-environment'
      tfvars_file:
        description: 'tfvars file name without extension (e.g., dlp-finance, env-production)'
        required: true
        type: string
        # WHY: Enables environment-specific variable values for import
        # GOVERNANCE: Ensures correct context for imported resource
        # VALIDATION: Must match a file in tfvars/ subdirectory
      resource_type:
        description: 'Terraform resource type for import operation'
        required: true
        type: choice
        options:
          - 'powerplatform_data_loss_prevention_policy'
          - 'powerplatform_environment'
        # WHY: Provides guided selection of supported resource types
        # GOVERNANCE: Prevents typos and ensures only supported resources are imported
        # VALIDATION: GitHub automatically validates against the choice list
      resource_name:
        description: 'Terraform resource name in the configuration (e.g., this, main)'
        required: true
        type: choice
        options:
          - 'this'
          - 'main'
        # WHY: Most configurations use standard resource naming patterns
        # GOVERNANCE: Ensures consistency with established patterns
        # VALIDATION: Matches common resource names in configurations
      resource_id:
        description: 'Power Platform resource ID to import (UUID format)'
        required: true
        type: string
        # WHY: Uniquely identifies existing resource for state integration
        # GOVERNANCE: Enables transition from manual to automated management
        # SECURITY: Must match exact resource to prevent incorrect imports
        # VALIDATION: UUID format ensures proper Power Platform resource reference
      backup_state:
        description: 'Create state backup before import'
        required: true
        type: boolean
        default: true
        # WHY: Protects against accidental state loss during import
        # GOVERNANCE: Provides audit trail and rollback capability
        # SECURITY: Ensures state can be restored if import fails

# Dynamic run name for auditability and traceability
run-name: ðŸ“¥ Terraform Import ${{ github.event.inputs.resource_type }}.${{ github.event.inputs.resource_name }} to ${{ github.event.inputs.configuration }} by @${{ github.actor }}

# === PERMISSIONS AND SECURITY ===
# Principle of least privilege for OIDC authentication and repository access
permissions:
  id-token: write   # Required for GitHub OIDC token generation
  contents: write   # Required for state backup commits and artifact management
  actions: read     # Required for reusable workflow execution summary

jobs:
  # === IMPORT EXECUTION JOB ===
  # Uses the standardized reusable-terraform-base workflow for consistent import operation
  terraform-import:
    name: ðŸ“¥ Execute Terraform Import
    uses: ./.github/workflows/reusable-terraform-base.yml
    with:
      operation: 'import'
      configuration: ${{ github.event.inputs.configuration }}
      tfvars-file: ${{ github.event.inputs.tfvars_file }}
      # Format import arguments: resource_type.resource_name resource_id
      additional-options: '${{ github.event.inputs.resource_type }}.${{ github.event.inputs.resource_name }} ${{ github.event.inputs.resource_id }}'
      create-state-backup: ${{ github.event.inputs.backup_state == 'true' }}
      timeout-minutes: 15
      environment-name: 'production'
    secrets: inherit

  # === POST-IMPORT VALIDATION AND REPORTING JOB ===
  # Validates the import was successful and generates comprehensive reports for governance
  post-import-validation:
    name: âœ… Validate Import Success
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: terraform-import
    if: always()  # Run even if import partially failed to provide diagnostics
    environment: production

    # Output values that can be used by dependent workflows
    outputs:
      import-successful: ${{ steps.validate-import.outputs.import-successful }}
      resource-imported: ${{ steps.validate-import.outputs.resource-imported }}
      configuration: ${{ github.event.inputs.configuration }}
      import-metadata: ${{ steps.validate-import.outputs.import-metadata }}

    steps:
      # === CHECKOUT REPOSITORY FOR VALIDATION ===
      - name: Checkout Repository for Validation
        uses: actions/checkout@v4

      # === SETUP TERRAFORM CLI ===
      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: ${{ vars.TERRAFORM_VERSION || '1.12.2' }}
          terraform_wrapper: false

      # === AZURE OIDC AUTHENTICATION ===
      # Required for backend state access and resource management
      - name: Azure Login with OIDC
        uses: azure/login@v2.3.0
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # === JIT NETWORK ACCESS FOR VALIDATION ===
      # Storage accounts use firewall restrictions for defense-in-depth security
      # Temporary access prevents permanent security holes while enabling automation
      - name: Add JIT Network Access for Validation
        id: jit-add
        uses: ./.github/actions/jit-network-access
        with:
          action: 'add'
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

      # === INITIALIZE TERRAFORM FOR VALIDATION ===
      # Ensures correct backend and OIDC configuration for state access
      - name: Initialize Terraform for Validation
        uses: ./.github/actions/terraform-init-with-backend
        env:
          ARM_STORAGE_ACCOUNT_NAME: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          ARM_CONTAINER_NAME: ${{ secrets.TERRAFORM_CONTAINER }}
          ARM_RESOURCE_GROUP_NAME: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true
          POWER_PLATFORM_USE_OIDC: true
          POWER_PLATFORM_CLIENT_ID: ${{ secrets.POWER_PLATFORM_CLIENT_ID }}
          POWER_PLATFORM_TENANT_ID: ${{ secrets.POWER_PLATFORM_TENANT_ID }}
        with:
          configuration: ${{ github.event.inputs.configuration }}
          tfvars-file: ${{ github.event.inputs.tfvars_file }}

      # === GENERATE WORKFLOW METADATA ===
      # Generate comprehensive metadata for audit trails and compliance tracking
      - name: Generate Workflow Metadata
        uses: ./.github/actions/generate-workflow-metadata
        id: validation-metadata
        with:
          operation: 'import'
          configuration: ${{ github.event.inputs.configuration }}
          tfvars-file: ${{ github.event.inputs.tfvars_file }}
          phase: 'validation'

      # === VALIDATE IMPORT SUCCESS ===
      # Checks if the import operation succeeded and validates state integrity
      - name: Validate Import Results
        id: validate-import
        run: |
          config="${{ github.event.inputs.configuration }}"
          tfvars_file="${{ github.event.inputs.tfvars_file }}"
          resource_type="${{ github.event.inputs.resource_type }}"
          resource_name="${{ github.event.inputs.resource_name }}"
          resource_id="${{ github.event.inputs.resource_id }}"

          cd "configurations/$config"

          # Initialize output variables
          import_successful="false"
          resource_imported=""

          # Check if import operation from reusable workflow was successful
          if [ "${{ needs.terraform-import.outputs.operation-successful }}" = "true" ]; then
            echo "::notice title=Import Operation::âœ… Reusable workflow reported successful import"

            # Validate the imported resource exists in state
            echo "::notice title=State Validation::ðŸ” Validating imported resource in Terraform state"

            resource_address="${resource_type}.${resource_name}"

            if terraform state show "$resource_address" > /dev/null 2>&1; then
              echo "::notice title=Import Verified::âœ… Resource $resource_address found in Terraform state"

              # Get resource details for validation
              resource_details=$(terraform state show "$resource_address")

              echo "::notice title=Resource Details::ðŸ“Š Retrieved resource details from state"
              echo "::group::Imported Resource Details"
              echo "$resource_details"
              echo "::endgroup::"

              # Validate resource ID matches what was imported
              if echo "$resource_details" | grep -q "$resource_id"; then
                echo "::notice title=ID Validation::âœ… Resource ID $resource_id confirmed in state"
                import_successful="true"
                resource_imported="$resource_address"
              else
                echo "::warning title=ID Mismatch::âš ï¸ Expected resource ID $resource_id not found in state details"
                import_successful="false"
                resource_imported=""
              fi
            else
              echo "::error title=Import Failed::âŒ Resource $resource_address not found in Terraform state"
              import_successful="false"
              resource_imported=""
            fi
          else
            echo "::error title=Operation Failed::âŒ Reusable workflow reported failed import operation"
            import_successful="false"
            resource_imported=""
          fi

          # Check for jq dependency
          if ! command -v jq >/dev/null 2>&1; then
            echo "::error title=Missing Dependency::jq is required for metadata generation"
            exit 1
          fi

          # Generate comprehensive metadata for audit and governance
          timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          metadata=$(jq -n \
            --arg timestamp "$timestamp" \
            --arg config "$config" \
            --arg tfvars "$tfvars_file" \
            --arg resource_type "$resource_type" \
            --arg resource_name "$resource_name" \
            --arg resource_id "$resource_id" \
            --arg successful "$import_successful" \
            --arg imported_resource "$resource_imported" \
            --arg workflow_run "${{ github.run_number }}" \
            --arg triggered_by "${{ github.actor }}" \
            --arg operation_metadata "${{ needs.terraform-import.outputs.operation-metadata }}" \
            '{
              "import_validation": {
                "validated_at": $timestamp,
                "import_successful": ($successful == "true"),
                "resource_imported": $imported_resource,
                "configuration": $config,
                "tfvars_file": $tfvars,
                "resource_specification": {
                  "type": $resource_type,
                  "name": $resource_name,
                  "id": $resource_id
                },
                "workflow_context": {
                  "run_number": $workflow_run,
                  "triggered_by": $triggered_by
                }
              },
              "terraform_operation": ($operation_metadata | fromjson? // {})
            }'
          )

          # Set outputs for downstream jobs and reporting
          echo "import-successful=$import_successful" >> $GITHUB_OUTPUT
          echo "resource-imported=$resource_imported" >> $GITHUB_OUTPUT
          {
            echo "import-metadata<<METADATA_EOF"
            echo "$metadata"
            echo "METADATA_EOF"
          } >> $GITHUB_OUTPUT

          cd - > /dev/null

      # === REMOVE JIT NETWORK ACCESS ===
      # Always remove temporary access regardless of workflow outcome
      - name: Remove JIT Network Access
        if: always()
        uses: ./.github/actions/jit-network-access
        with:
          action: 'remove'
          storage-account-name: ${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}
          resource-group-name: ${{ secrets.TERRAFORM_RESOURCE_GROUP }}

  # === Generates a comprehensive execution summary for governance, troubleshooting, and audit trail ===
  # WHY: Provides a clear, actionable summary of the workflow run, including troubleshooting and technical details
  execution-summary:
      name: "ðŸŽ¯ Execution Summary"
      needs: [terraform-import, post-import-validation]
      uses: ./.github/workflows/reusable-execution-summary.yml
      if: always()
      with:
        workflow-name: "terraform-import"
        operation-type: "import"
        configuration: ${{ github.event.inputs.configuration }}
        output-filename: ""
        job-results: ${{ toJSON(needs) }}
        workflow-inputs: ${{ toJSON(github.event.inputs) }}
        include-troubleshooting: true
        include-technical-details: true
        summary-level: "detailed"
        artifact-retention-days: 30
