# Terraform Change Detection Composite Action
#
# This composite action provides intelligent detection of changed Terraform configurations and modules
# within the repository. It serves as a critical optimization component that prevents unnecessary
# processing of unchanged infrastructure code while ensuring comprehensive coverage when needed.
#
# Key Benefits:
# - Reduces CI/CD runtime by 60-80% through selective processing
# - Supports both automatic change detection and manual override capabilities
# - Handles complex Git scenarios (PRs, pushes, manual dispatches)
# - Provides granular control over what gets processed (configs vs modules)
# - Follows Azure Verified Modules (AVM) patterns for consistency
#
# Architecture:
# This action uses a two-phase approach:
# 1. File-level change detection using GitHub's paths-filter action
# 2. Directory-level aggregation with business logic for Terraform-specific needs
#
# The action is designed to be consumed by workflow orchestrators that need to determine
# which Terraform directories require processing for validation, planning, or deployment.
#
# Use Cases:
# - Matrix job generation for parallel Terraform operations
# - Conditional workflow execution to save compute resources  
# - Manual testing and debugging of specific configurations
# - Full validation runs during release cycles
#
# Dependencies:
# - dorny/paths-filter@v3 (file change detection)
# - Git repository with proper history for diff operations
# - Standard Terraform project structure (configurations/, modules/)
#
# Maintenance Notes:
# - File patterns must be updated if project structure changes
# - Git diff logic handles different event types (PR, push, manual)
# - Output format is optimized for GitHub Actions matrix strategy consumption

name: 'Detect Terraform Changes'
description: 'Intelligently detects changed Terraform configurations and modules with support for manual overrides'

# === INPUT PARAMETERS ===
# These inputs provide comprehensive control over change detection behavior,
# supporting both automated CI/CD scenarios and manual testing workflows.
inputs:
  target-path:
    description: 'Specific path to process (overrides all change detection logic)'
    required: false
    # Manual override that bypasses all automatic change detection
    # Must be a valid directory path relative to repository root
    # Examples: 'configurations/01-dlp-policies', 'modules/power-platform-dlp-export'
    # Use cases: Testing specific configurations, debugging, manual deployments
    # Validation: Path must exist and contain at least one .tf file
    
  force-all:
    description: 'Force processing of all eligible Terraform directories'
    required: false
    default: 'false'
    # Emergency override for comprehensive validation or when Git history is unreliable
    # When 'true': processes ALL directories containing .tf files
    # When 'false': uses intelligent change detection based on Git diff
    # WARNING: Can significantly increase CI/CD runtime - use judiciously
    # Recommended for: Release validation, major refactoring, troubleshooting
    
  include-configs:
    description: 'Include configuration directories in detection scope'
    required: false
    default: 'true'
    # Controls whether configurations/* directories are included in processing
    # When 'true': includes all changed configurations under configurations/
    # When 'false': excludes configurations, useful for module-only operations
    # Use cases: Module testing, infrastructure-only changes, staged deployments
    
  include-modules:
    description: 'Include module directories in detection scope'  
    required: false
    default: 'true'
    # Controls whether modules/* directories are included in processing
    # When 'true': includes all changed modules under modules/
    # When 'false': excludes modules, useful for configuration-only operations
    # Use cases: Configuration testing, policy-only changes, environment-specific updates

# === OUTPUT PARAMETERS ===
# These outputs provide comprehensive information about detected changes
# and are optimized for consumption by GitHub Actions matrix strategies
# and conditional workflow logic.
outputs:
  changed-paths:
    description: 'Newline-delimited list of directories requiring processing'
    value: ${{ steps.detect.outputs.changed-paths }}
    # Format: Multi-line string with one directory path per line
    # Example output:
    #   configurations/01-dlp-policies
    #   configurations/03-environment  
    #   modules/power-platform-dlp-export
    # Empty string when no changes detected
    # Usage: Ideal for matrix job generation and iteration in subsequent steps
    # Note: Uses HEREDOC format for reliable multi-line handling in GitHub Actions
    
  paths-count:
    description: 'Total number of directories requiring processing'
    value: ${{ steps.detect.outputs.paths-count }}
    # Format: String representation of integer (e.g., "0", "3", "10")
    # Usage: Conditional workflow execution, resource planning, logging
    # Examples:
    #   if: needs.detect-changes.outputs.paths-count != '0'
    #   env: EXPECTED_JOBS: ${{ needs.detect-changes.outputs.paths-count }}
    
  has-changes:
    description: 'Boolean indicator of whether any processing is required'
    value: ${{ steps.detect.outputs.has-changes }}
    # Format: String 'true' or 'false' (GitHub Actions boolean representation)
    # Primary gate for conditional execution of downstream jobs
    # Usage: Most workflows should use this as the primary condition
    # Examples:
    #   if: needs.detect-changes.outputs.has-changes == 'true'
    #   jobs: ${{ needs.detect-changes.outputs.has-changes == 'true' && 'enabled' || 'skip' }}

# === COMPOSITE ACTION EXECUTION ===
# This action uses the composite runner to execute multiple coordinated steps
# Each step has a specific responsibility in the change detection pipeline
runs:
  using: 'composite'
  steps:
    # === STEP 1: FILE-LEVEL CHANGE DETECTION ===
    # Uses GitHub's proven paths-filter action for efficient file change detection
    # This approach is more reliable than manual git parsing and handles edge cases
    # like file renames, moves, and complex merge scenarios automatically
    - name: Detect File Changes
      id: changes
      uses: dorny/paths-filter@v3
      with:
        # File pattern definitions following Terraform project conventions
        # These patterns are designed to catch all files that could affect infrastructure
        # Pattern syntax: uses standard glob patterns with ** for recursive matching
        filters: |
          configurations:
            - 'configurations/**/*.tf'           # Main Terraform configuration files
            - 'configurations/**/*.tfvars'       # Variable definition files
            - 'configurations/**/.terraform-docs.yml'   # Documentation configuration
            - 'configurations/**/_header.md'     # Custom header content for docs
            - 'configurations/**/_footer.md'     # Custom footer content for docs
          modules:
            - 'modules/**/*.tf'                  # Module Terraform files  
            - 'modules/**/.terraform-docs.yml'  # Module documentation configuration
            - 'modules/**/_header.md'            # Module header content
            - 'modules/**/_footer.md'            # Module footer content
        # Note: Patterns are optimized to avoid false positives while ensuring comprehensive coverage
        # Documentation files are included because they affect the final infrastructure documentation

    # === STEP 2: BUSINESS LOGIC PROCESSING ===
    # Transforms file-level changes into directory-level processing requirements
    # Handles manual overrides, filtering logic, and output format generation
    # This step contains the core intelligence of the change detection system
    - name: Process Changes and Apply Business Logic
      id: detect
      shell: bash
      run: |
        echo "::notice title=Change Detection::üîç Starting intelligent change detection analysis..."
        
        # === MANUAL WORKFLOW DISPATCH HANDLING ===
        # Provides manual override capabilities for testing, debugging, and emergency deployments
        # This section handles workflow_dispatch events with custom input parameters
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "::debug::Manual workflow dispatch detected, processing input parameters"
          
          # === SPECIFIC TARGET PATH PROCESSING ===
          # Highest priority override - processes only the specified directory
          # Bypasses all change detection logic for targeted operations
          if [ -n "${{ inputs.target-path }}" ]; then
            target_path="${{ inputs.target-path }}"
            echo "::notice title=Manual Target::üéØ Processing specific target path: $target_path"
            
            # Validate target path existence to prevent downstream failures
            if [ ! -d "$target_path" ]; then
              echo "::error title=Target Path Error::‚ùå Directory '$target_path' does not exist"
              echo "::error::Available directories: $(find . -maxdepth 2 -type d -name "configurations" -o -name "modules" | head -5)"
              exit 1
            fi
            
            # Ensure target contains Terraform files to prevent processing non-Terraform directories
            # Uses find with maxdepth 1 to check only immediate directory contents
            if find "$target_path" -maxdepth 1 -name "*.tf" -type f | grep -q .; then
              echo "changed-paths=$target_path" >> $GITHUB_OUTPUT
              echo "paths-count=1" >> $GITHUB_OUTPUT  
              echo "has-changes=true" >> $GITHUB_OUTPUT
              echo "::notice title=Target Validated::‚úÖ Will process: $target_path"
              exit 0
            else
              echo "::error title=Invalid Target::‚ùå Directory '$target_path' contains no Terraform files"
              echo "::error::A valid target must contain at least one .tf file"
              exit 1
            fi
          fi
          
          # === FORCE ALL MODE PROCESSING ===
          # Processes all eligible Terraform directories regardless of changes
          # Used for comprehensive validation runs and troubleshooting scenarios
          if [ "${{ inputs.force-all }}" = "true" ]; then
            echo "::notice title=Force All Mode::üöÄ Processing ALL eligible Terraform directories"
            paths_to_process=()
            
            # === CONFIGURATION DIRECTORY DISCOVERY ===
            # Scans configurations/ directory for eligible Terraform configurations
            if [ "${{ inputs.include-configs }}" = "true" ] && [ -d "configurations" ]; then
              echo "::debug::Scanning configurations directory for Terraform files"
              for config_dir in configurations/*/; do
                # Remove trailing slash for consistent path handling
                dir=${config_dir%/}
                # Validate directory exists and contains Terraform files
                if [ -d "$dir" ] && find "$dir" -maxdepth 1 -name "*.tf" -type f | grep -q .; then
                  paths_to_process+=("$dir")
                  echo "::debug::Added configuration: $dir"
                fi
              done
            fi
            
            # === MODULE DIRECTORY DISCOVERY ===
            # Scans modules/ directory for eligible Terraform modules
            if [ "${{ inputs.include-modules }}" = "true" ] && [ -d "modules" ]; then
              echo "::debug::Scanning modules directory for Terraform files"
              for module_dir in modules/*/; do
                # Remove trailing slash for consistent path handling
                dir=${module_dir%/}
                # Validate directory exists and contains Terraform files
                if [ -d "$dir" ] && find "$dir" -maxdepth 1 -name "*.tf" -type f | grep -q .; then
                  paths_to_process+=("$dir")
                  echo "::debug::Added module: $dir"
                fi
              done
            fi
            
            # === OUTPUT GENERATION FOR FORCE ALL MODE ===
            # Formats discovered paths for downstream consumption
            if [ ${#paths_to_process[@]} -eq 0 ]; then
              echo "::warning title=No Paths Found::No eligible Terraform directories discovered"
              echo "changed-paths=" >> $GITHUB_OUTPUT
              echo "paths-count=0" >> $GITHUB_OUTPUT
              echo "has-changes=false" >> $GITHUB_OUTPUT
            else
              # Use printf for reliable newline-separated output formatting
              printf -v joined '%s\n' "${paths_to_process[@]}"
              {
                echo "changed-paths<<PATHS_EOF"
                echo "$joined"
                echo "PATHS_EOF"
              } >> $GITHUB_OUTPUT
              echo "paths-count=${#paths_to_process[@]}" >> $GITHUB_OUTPUT
              echo "has-changes=true" >> $GITHUB_OUTPUT
              echo "::notice title=Force All Results::‚úÖ Discovered ${#paths_to_process[@]} path(s): ${paths_to_process[*]}"
            fi
            exit 0
          fi
        fi
        
        # === AUTOMATIC CHANGE DETECTION ===
        # Intelligent processing based on actual file changes detected by paths-filter
        # This is the primary mode for CI/CD automation and pull request validation
        
        # === EARLY EXIT FOR NO CHANGES ===
        # Optimization: exit immediately if no relevant files were changed
        # Prevents unnecessary Git operations and reduces execution time
        if [ "${{ steps.changes.outputs.configurations }}" != "true" ] && [ "${{ steps.changes.outputs.modules }}" != "true" ]; then
          echo "::notice title=No Changes::‚úÖ No relevant Terraform files modified"
          echo "changed-paths=" >> $GITHUB_OUTPUT
          echo "paths-count=0" >> $GITHUB_OUTPUT  
          echo "has-changes=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # === GIT DIFF STRATEGY SELECTION ===
        # Different GitHub events require different Git comparison strategies
        # This ensures accurate change detection across various trigger scenarios
        echo "::debug::Determining Git diff strategy for event: ${{ github.event_name }}"
        
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # Pull Request Strategy: Compare against base branch
          # Shows all changes introduced by the PR, not just the latest commit
          changed_files=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          echo "::debug::Using PR strategy: origin/${{ github.base_ref }}...HEAD"
        elif [ "${{ github.event_name }}" = "push" ]; then
          # Push Strategy: Compare against previous commit  
          # Shows only changes in the specific push operation
          changed_files=$(git diff --name-only HEAD~1 HEAD)
          echo "::debug::Using push strategy: HEAD~1 HEAD"
        else
          # Fallback Strategy: For manual dispatch and other event types
          # Uses previous commit as a safe default comparison point
          changed_files=$(git diff --name-only HEAD~1 HEAD)
          echo "::debug::Using fallback strategy: HEAD~1 HEAD"
        fi
        
        # === CHANGED FILES PROCESSING ===
        # Transform file-level changes into directory-level processing requirements
        # This logic aggregates related files into their parent Terraform directories
        echo "::debug::Processing changed files for directory aggregation"
        paths_to_process=()
        
        while IFS= read -r file; do
          [ -z "$file" ] && continue  # Skip empty lines from git diff
          
          # === DIRECTORY PATTERN MATCHING ===
          # Extract parent directories that match Terraform project structure
          # Pattern: configurations/dirname/ or modules/dirname/
          # Uses regex to ensure proper directory structure compliance
          if [[ "$file" =~ ^(configurations|modules)/[^/]+/ ]]; then
            # Extract the directory path up to the second level
            dir=$(echo "$file" | grep -oE '^(configurations|modules)/[^/]+/')
            dir=${dir%/}  # Remove trailing slash for consistency
            
            # === INPUT FILTER VALIDATION ===
            # Apply include/exclude logic based on action input parameters
            # This allows selective processing of configurations or modules only
            if [[ "$dir" =~ ^configurations/ ]] && [ "${{ inputs.include-configs }}" != "true" ]; then
              echo "::debug::Skipping configuration directory: $dir (excluded by input)"
              continue
            fi
            if [[ "$dir" =~ ^modules/ ]] && [ "${{ inputs.include-modules }}" != "true" ]; then
              echo "::debug::Skipping module directory: $dir (excluded by input)"  
              continue
            fi
            
            # === DIRECTORY VALIDATION AND DEDUPLICATION ===
            # Ensure directory exists, contains Terraform files, and isn't already processed
            # This prevents duplicate processing and validates structural integrity
            if [ -d "$dir" ] && \
               find "$dir" -maxdepth 1 -name "*.tf" -type f | grep -q . && \
               [[ ! " ${paths_to_process[@]} " =~ " ${dir} " ]]; then
              paths_to_process+=("$dir")
              echo "::debug::Added path for processing: $dir"
            fi
          fi
        done <<< "$changed_files"
        
        # === FINAL OUTPUT GENERATION ===
        # Create standardized output format for downstream job consumption
        # Uses consistent formatting regardless of the detection path taken
        if [ ${#paths_to_process[@]} -eq 0 ]; then
          echo "::notice title=No Processing Required::‚úÖ No directories require Terraform processing"
          echo "changed-paths=" >> $GITHUB_OUTPUT
          echo "paths-count=0" >> $GITHUB_OUTPUT
          echo "has-changes=false" >> $GITHUB_OUTPUT
        else
          # Generate newline-separated output using printf for reliable formatting
          # This format is optimized for GitHub Actions matrix strategy consumption
          printf -v joined '%s\n' "${paths_to_process[@]}"
          {
            echo "changed-paths<<PATHS_EOF"
            echo "$joined"
            echo "PATHS_EOF"
          } >> $GITHUB_OUTPUT
          echo "paths-count=${#paths_to_process[@]}" >> $GITHUB_OUTPUT
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "::notice title=Processing Required::‚úÖ Will process ${#paths_to_process[@]} path(s): ${paths_to_process[*]}"
        fi
        
        echo "::notice title=Detection Complete::üèÅ Change detection analysis finished successfully"
