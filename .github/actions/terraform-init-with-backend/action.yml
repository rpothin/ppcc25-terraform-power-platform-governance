# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# TERRAFORM BACKEND INITIALIZATION COMPOSITE ACTION FOR POWER PLATFORM GOVERNANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Enterprise-grade Terraform initialization with Azure backend implementing standardized state
# management conventions and resilience patterns for reliable Power Platform infrastructure automation.
#
# ðŸŽ¯ WHY THIS EXISTS:
# - Implements standardized state file naming conventions preventing conflicts in multi-environment scenarios
# - Provides built-in retry logic with exponential backoff handling transient Azure API failures gracefully
# - Eliminates manual state management overhead while maintaining audit trails for governance compliance
# - Supports specialized operations like output-only workflows and testing scenarios through flexible naming
#
# ðŸ”’ SECURITY DECISIONS:
# - Uses OIDC authentication by default eliminating stored credential vulnerabilities in CI/CD pipelines
# - Validates all input parameters to prevent state key injection attacks and unauthorized access patterns
# - Supports network-restricted storage accounts through JIT access compatibility with propagation delays
# - Implements environment variable validation preventing exposure of sensitive backend configuration
#
# âš™ï¸ OPERATIONAL CONTEXT:
# - Handles Azure backend temporary unavailability through exponential backoff retry strategy (10s, 20s, 30s)
# - Manages network propagation delays for JIT access scenarios through configurable wait periods
# - Supports both modern ARM_* and legacy environment variable patterns for backward compatibility
# - Creates hierarchical state naming: override â†’ multi-environment â†’ single environment fallback
#
# ðŸ“‹ INTEGRATION REQUIREMENTS:
# - Requires Terraform CLI available in PATH with compatible version for target configurations
# - Depends on Azure authentication configured through OIDC or Azure CLI for backend state operations
# - Needs Azure Storage Account with appropriate RBAC permissions for state file management
# - Integrates with JIT network access actions requiring coordination of access timing and cleanup
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: 'Terraform Init with Backend Configuration'
description: 'Enterprise-grade Terraform initialization with Azure backend, standardized state management, and resilience patterns'

# === INPUT PARAMETERS ===
# These inputs control the initialization behavior and state management strategy,
# supporting various deployment patterns and operational requirements.
inputs:
  configuration:
    description: 'Target configuration directory name for state file identification'
    required: true
    # Format: Directory name under configurations/ (e.g., '01-dlp-policies', '03-environment')
    # Purpose: Primary component of state file naming convention
    # Usage: Must match the actual directory name containing Terraform configuration files
    # Examples: '01-dlp-policies', '02-dlp-policy', '03-environment'
    #
    # State Key Impact: Forms the base of state file naming
    # - With tfvars: configuration-tfvars.tfstate
    # - Without tfvars: configuration.tfstate
    # - With override: Uses override value completely
    #
    # Validation: Action will fail if directory doesn't exist under configurations/

  tfvars-file:
    description: 'Variables file name for multi-environment state differentiation'
    required: false
    # Format: Filename without .tfvars extension (e.g., 'dev', 'prod', 'staging')
    # Purpose: Creates unique state files for different environments/configurations
    # When provided: Generates pattern {configuration}-{tfvars-file}.tfstate
    # When omitted: Falls back to {configuration}.tfstate pattern
    #
    # Examples:
    # - 'dev' â†’ '01-dlp-policies-dev.tfstate'
    # - 'prod' â†’ '01-dlp-policies-prod.tfstate'
    # - 'dlp-finance' â†’ '02-dlp-policy-dlp-finance.tfstate'
    #
    # Best Practices:
    # - Use consistent naming across environments (dev, staging, prod)
    # - Align with tfvars file names in configurations/{config}/tfvars/
    # - Consider using semantic names for specialized configurations

  state-key-override:
    description: 'Complete state key override for specialized operations'
    required: false
    # Format: Full state file name with .tfstate extension
    # Purpose: Bypasses standard naming conventions for special use cases
    # When provided: Uses this value as the complete state key
    # When omitted: Uses standard configuration-based patterns
    #
    # Use Cases:
    # - Output-only operations: 'output-{configuration}.tfstate'
    # - Testing workflows: 'test-{configuration}-{timestamp}.tfstate'
    # - Migration scenarios: Legacy state key patterns
    # - Shared state operations: Cross-configuration dependencies
    #
    # Examples:
    # - 'output-01-dlp-policies.tfstate' (for terraform output operations)
    # - 'test-integration-20250115.tfstate' (for testing)
    # - 'shared-data-layer.tfstate' (for shared resources)
    #
    # Security: Ensure override keys don't conflict with existing state files

  max-retries:
    description: 'Maximum initialization retry attempts for resilience'
    required: false
    default: '3'
    # Range: 1-10 retries (practical limits for CI/CD timing)
    # Purpose: Handles transient failures in Azure backend connectivity
    # Default: 3 retries provides good balance of resilience vs. execution time
    #
    # Common Failure Scenarios:
    # - Azure Storage temporary unavailability
    # - Network connectivity issues
    # - JIT access rule propagation delays
    # - Azure authentication token refresh
    # - Terraform provider download failures
    #
    # Retry Strategy: Exponential backoff (10s, 20s, 30s intervals)
    # Total timeout: ~60 seconds with default 3 retries
    # Adjustment: Increase for unreliable networks, decrease for fast failure

  wait-for-propagation:
    description: 'Network rule propagation wait time in seconds'
    required: false
    default: '10'
    # Range: 5-60 seconds (balance between reliability and speed)
    # Purpose: Ensures JIT network access rules are effective before initialization
    # Default: 10 seconds works for most Azure regions and configurations
    #
    # Network Propagation Timing:
    # - Azure Storage firewall rules: 5-30 seconds typical
    # - Cross-region propagation: Up to 60 seconds in extreme cases
    # - GitHub Actions to Azure: Usually under 10 seconds
    #
    # Tuning Guidelines:
    # - Increase for: Multi-region deployments, network-restricted storage
    # - Decrease for: Direct connectivity, non-JIT scenarios
    # - Monitor: Initialization failure rates to optimize timing

# === OUTPUT PARAMETERS ===
# These outputs provide comprehensive feedback about the initialization process
# and enable downstream conditional logic and troubleshooting capabilities.
outputs:
  initialized:
    description: 'Boolean success indicator for initialization completion'
    value: ${{ steps.init.outputs.initialized }}
    # Format: String 'true' or 'false' (GitHub Actions boolean representation)
    # Usage: Primary gate for conditional execution of subsequent Terraform operations
    #
    # Success Conditions:
    # - Terraform init completed without errors
    # - Backend configuration accepted and validated
    # - State file successfully created or accessed
    # - Provider plugins downloaded and initialized
    #
    # Common Usage Patterns:
    # - if: needs.terraform-init.outputs.initialized == 'true'
    # - Conditional plan/apply execution based on initialization success
    # - Error handling workflows when initialization fails
    #
    # Failure Scenarios:
    # - Network connectivity issues to Azure Storage
    # - Authentication or authorization failures
    # - State file conflicts or corruption
    # - Invalid backend configuration
    # - Terraform version compatibility issues

  state-key:
    description: 'Actual state key used for backend initialization'
    value: ${{ steps.init.outputs.state-key }}
    # Format: String representing the state file name (e.g., '01-dlp-policies-dev.tfstate')
    # Purpose: Provides visibility into state management for debugging and audit trails
    #
    # State Key Patterns:
    # - Standard: '{configuration}-{tfvars-file}.tfstate'
    # - Fallback: '{configuration}.tfstate'
    # - Override: Custom value from state-key-override input
    #
    # Usage Examples:
    # - Debugging: Verify correct state file is being used
    # - Logging: Audit trail for state management operations
    # - Downstream operations: Pass state key to subsequent Terraform commands
    # - Monitoring: Track state file usage across environments
    #
    # Troubleshooting Value:
    # - Confirms expected state naming patterns
    # - Helps identify state conflicts or naming issues
    # - Enables correlation between workflows and state files
    # - Supports automated state management validation

# === COMPOSITE ACTION EXECUTION ===
# This action implements a three-phase initialization strategy with comprehensive
# error handling, retry logic, and enterprise-grade reliability patterns.
runs:
  using: 'composite'
  steps:
    # === STEP 1: NETWORK PROPAGATION WAIT ===
    # Ensures Just-In-Time network access rules are fully effective before initialization
    # This step is critical for security-hardened environments using network restrictions
    - name: Wait for JIT Network Access Propagation
      shell: bash
      run: |
        echo "::notice title=Network Propagation::â±ï¸ Waiting for network access rules to propagate..."
        echo "::debug::Propagation wait time: ${{ inputs.wait-for-propagation }} seconds"

        # === PROPAGATION TIMING EXPLANATION ===
        # Azure Storage Account firewall rules require time to propagate globally
        # This ensures JIT access rules added by previous steps are fully effective
        # Typical propagation times:
        # - Same region: 5-15 seconds
        # - Cross-region: 15-60 seconds
        # - GitHub Actions to Azure: Usually under 10 seconds
        wait_time="${{ inputs.wait-for-propagation }}"

        if [ "$wait_time" -gt 0 ]; then
          echo "::notice title=Propagation Wait::â³ Sleeping for $wait_time seconds to ensure network rules are active..."
          sleep "$wait_time"
          echo "::notice title=Propagation Complete::âœ… Network propagation wait completed"
        else
          echo "::notice title=Propagation Skipped::âš¡ Zero wait time specified, skipping propagation wait"
        fi

    # === STEP 2: STATE KEY GENERATION ===
    # Generates standardized state file names using hierarchical naming conventions
    # This ensures predictable, unique state files for different environments and configurations
    - name: Generate Standardized State Key
      id: state-key
      shell: bash
      run: |
        echo "::notice title=State Key Generation::ðŸ”‘ Generating state file name using standardized conventions..."

        # === INPUT PARAMETER EXTRACTION ===
        config="${{ inputs.configuration }}"
        tfvars_file="${{ inputs.tfvars-file }}"
        override_key="${{ inputs.state-key-override }}"

        echo "::debug::Configuration: '$config'"
        echo "::debug::TFVars file: '$tfvars_file'"
        echo "::debug::Override key: '$override_key'"

        # === STATE KEY GENERATION HIERARCHY ===
        # Implements three-tier naming strategy for maximum flexibility

        if [ -n "$override_key" ]; then
          # === TIER 1: COMPLETE OVERRIDE ===
          # Highest priority - bypasses all standard conventions
          # Used for specialized operations like output-only workflows, testing, or migration
          state_key="$override_key"
          echo "::notice title=Override Pattern::ðŸŽ¯ Using complete state key override: $state_key"
          echo "::notice::This bypasses standard naming conventions for specialized operations"

        elif [ -n "$tfvars_file" ]; then
          # === TIER 2: STANDARD MULTI-ENVIRONMENT PATTERN ===
          # Primary pattern for production multi-environment deployments
          # Format: {configuration}-{tfvars-file}.tfstate
          # Example: "01-dlp-policies-dev.tfstate", "02-dlp-policy-prod.tfstate"
          state_key="${config}-${tfvars_file}.tfstate"
          echo "::notice title=Standard Pattern::âš™ï¸ Generated multi-environment state key: $state_key"
          echo "::notice::Pattern: {configuration}-{environment}.tfstate"

        else
          # === TIER 3: SINGLE ENVIRONMENT FALLBACK ===
          # Legacy compatibility pattern when no environment differentiation is needed
          # Format: {configuration}.tfstate
          # Example: "01-dlp-policies.tfstate"
          state_key="${config}.tfstate"
          echo "::warning title=Fallback Pattern::âš ï¸ Using single-environment state key: $state_key"
          echo "::warning::Consider using tfvars-file parameter for environment differentiation"
        fi

        # === STATE KEY VALIDATION ===
        # Basic validation to ensure state key follows expected patterns
        if [[ ! "$state_key" =~ \.tfstate$ ]]; then
          echo "::error title=Invalid State Key::âŒ Generated state key '$state_key' does not end with .tfstate"
          exit 1
        fi

        # === OUTPUT GENERATION ===
        echo "state-key=$state_key" >> $GITHUB_OUTPUT
        echo "::notice title=State Key Ready::âœ… State key generated and ready for initialization"

    # === STEP 3: TERRAFORM INITIALIZATION WITH RETRY LOGIC ===
    # Executes Terraform init with comprehensive retry logic, error handling, and logging
    # This step implements enterprise-grade resilience patterns for reliable automation
    - name: Execute Terraform Initialization with Resilience Patterns
      id: init
      shell: bash
      run: |
        echo "::notice title=Terraform Initialization::ðŸš€ Starting enterprise-grade Terraform initialization..."

        # === INITIALIZATION CONTEXT SETUP ===
        config="${{ inputs.configuration }}"
        state_key="${{ steps.state-key.outputs.state-key }}"
        max_retries="${{ inputs.max-retries }}"
        retry_count=0
        init_success=false

        echo "::notice title=Initialization Context::ðŸ“‹ Configuration details:"
        echo "::notice::â€¢ Configuration: $config"
        echo "::notice::â€¢ State key: $state_key"
        echo "::notice::â€¢ Max retries: $max_retries"
        echo "::notice::â€¢ Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"

        # === WORKING DIRECTORY SETUP ===
        # Change to the target configuration directory for Terraform operations
        # This ensures Terraform operates in the correct context with proper file access
        target_dir="configurations/$config"

        if [ ! -d "$target_dir" ]; then
          echo "::error title=Directory Not Found::âŒ Configuration directory '$target_dir' does not exist"
          echo "::error::Ensure the configuration parameter matches an existing directory under configurations/"
          echo "initialized=false" >> $GITHUB_OUTPUT
          echo "state-key=$state_key" >> $GITHUB_OUTPUT
          exit 1
        fi

        cd "$target_dir"
        echo "::notice title=Working Directory::ðŸ“ Changed to $(pwd)"

        # === AZURE BACKEND CONFIGURATION VALIDATION ===
        # Verify required backend configuration environment variables for secure state management
        # Supports both modern ARM_* and legacy patterns for maximum compatibility
        storage_account="${ARM_STORAGE_ACCOUNT_NAME:-${TERRAFORM_STORAGE_ACCOUNT:-}}"
        container_name="${ARM_CONTAINER_NAME:-${TERRAFORM_CONTAINER:-}}"
        resource_group="${ARM_RESOURCE_GROUP_NAME:-${TERRAFORM_RESOURCE_GROUP:-}}"
        subscription_id="${ARM_SUBSCRIPTION_ID:-${AZURE_SUBSCRIPTION_ID:-}}"
        tenant_id="${ARM_TENANT_ID:-${AZURE_TENANT_ID:-}}"

        # Validate critical backend parameters
        missing_vars=()
        [ -z "$storage_account" ] && missing_vars+=("storage_account")
        [ -z "$container_name" ] && missing_vars+=("container_name")
        [ -z "$resource_group" ] && missing_vars+=("resource_group")
        [ -z "$subscription_id" ] && missing_vars+=("subscription_id")
        [ -z "$tenant_id" ] && missing_vars+=("tenant_id")

        if [ ${#missing_vars[@]} -gt 0 ]; then
          echo "::error title=Missing Configuration::âŒ Required backend configuration variables missing:"
          printf '::error::â€¢ %s\n' "${missing_vars[@]}"
          echo "::error::Ensure ARM_* or TERRAFORM_* environment variables are properly set"
          echo "initialized=false" >> $GITHUB_OUTPUT
          echo "state-key=$state_key" >> $GITHUB_OUTPUT
          exit 1
        fi

        echo "::debug::Backend configuration validated successfully"

        # === RETRY LOOP WITH EXPONENTIAL BACKOFF ===
        # Implement robust retry logic to handle transient failures
        # Uses exponential backoff to avoid overwhelming Azure services during outages
        while [ $retry_count -lt $max_retries ] && [ "$init_success" = false ]; do
          retry_count=$((retry_count + 1))
          echo "::notice title=Initialization Attempt::ðŸ”„ Attempt $retry_count of $max_retries..."

          # === TERRAFORM INITIALIZATION EXECUTION ===
          # Execute terraform init with comprehensive backend configuration
          # Use OIDC authentication for enhanced security (no stored credentials)
          echo "::debug::Executing terraform init with backend configuration..."

          if terraform init \
            -backend-config="storage_account_name=$storage_account" \
            -backend-config="container_name=$container_name" \
            -backend-config="key=$state_key" \
            -backend-config="resource_group_name=$resource_group" \
            -backend-config="subscription_id=$subscription_id" \
            -backend-config="tenant_id=$tenant_id" \
            -backend-config="use_oidc=true" \
            -no-color 2>&1 | tee /tmp/terraform_init_output.log; then

            # === SUCCESS HANDLING ===
            init_success=true
            echo "::notice title=Initialization Success::âœ… Terraform initialized successfully!"
            echo "::notice title=Attempt Details::ðŸ“Š Succeeded on attempt $retry_count of $max_retries"
            echo "::notice title=Backend Details::ðŸ—ï¸ Using state: $state_key in $storage_account"

            # Validate initialization by checking for .terraform directory
            if [ -d ".terraform" ]; then
              echo "::debug::Terraform working directory created successfully"
            else
              echo "::warning title=Partial Success::âš ï¸ Init succeeded but .terraform directory not found"
            fi

          else
            # === FAILURE HANDLING ===
            echo "::warning title=Initialization Failed::âš ï¸ Attempt $retry_count failed"

            # Log failure details for troubleshooting
            if [ -f /tmp/terraform_init_output.log ]; then
              echo "::debug::Terraform init output:"
              cat /tmp/terraform_init_output.log | head -20
            fi

            # Implement exponential backoff before retry
            if [ $retry_count -lt $max_retries ]; then
              # Calculate wait time: attempt * 10 seconds (10s, 20s, 30s)
              wait_time=$((retry_count * 10))
              echo "::notice title=Retry Backoff::â±ï¸ Waiting ${wait_time} seconds before retry..."
              echo "::debug::Exponential backoff: attempt $retry_count -> ${wait_time}s wait"
              sleep $wait_time
            else
              echo "::error title=Max Retries Reached::âŒ All $max_retries initialization attempts failed"
            fi
          fi
        done

        # === FINAL RESULT PROCESSING ===
        # Clean up temporary files and set appropriate outputs
        rm -f /tmp/terraform_init_output.log

        if [ "$init_success" = false ]; then
          # === COMPREHENSIVE FAILURE REPORTING ===
          echo "::error title=Initialization Failed::âŒ Terraform initialization failed after $max_retries attempts"
          echo "::error title=Configuration Details::ðŸ“‹ Failed configuration:"
          echo "::error::â€¢ Configuration: $config"
          echo "::error::â€¢ State key: $state_key"
          echo "::error::â€¢ Storage account: $storage_account"
          echo "::error::â€¢ Container: $container_name"
          echo "::error::â€¢ Resource group: $resource_group"

          # Provide troubleshooting guidance
          echo "::error title=Troubleshooting::ðŸ”§ Common solutions:"
          echo "::error::â€¢ Verify Azure authentication and permissions"
          echo "::error::â€¢ Check storage account and container exist"
          echo "::error::â€¢ Ensure JIT network access rules have propagated"
          echo "::error::â€¢ Validate RBAC permissions for state management"
          echo "::error::â€¢ Check for state file locks or corruption"

          # Set failure outputs
          echo "initialized=false" >> $GITHUB_OUTPUT
          echo "state-key=$state_key" >> $GITHUB_OUTPUT
          cd - > /dev/null
          exit 1
        else
          # === SUCCESS CONFIRMATION ===
          echo "::notice title=Initialization Complete::ðŸŽ‰ Terraform initialization completed successfully"
          echo "::notice title=Performance::âš¡ Completed in $retry_count attempt(s)"
          echo "::notice title=State Management::ðŸ“‹ State file: $state_key"

          # Set success outputs
          echo "initialized=true" >> $GITHUB_OUTPUT
          echo "state-key=$state_key" >> $GITHUB_OUTPUT
        fi

        # === CLEANUP AND RETURN ===
        # Return to original directory to avoid affecting subsequent steps
        cd - > /dev/null
        echo "::debug::Terraform initialization workflow completed"
