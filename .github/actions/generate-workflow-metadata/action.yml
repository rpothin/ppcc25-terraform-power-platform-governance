---
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WORKFLOW METADATA GENERATION COMPOSITE ACTION FOR POWER PLATFORM GOVERNANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Standardized metadata factory creating comprehensive audit trails and compliance tracking
# for all Terraform operations in Power Platform governance automation workflows.
#
# ðŸŽ¯ WHY THIS EXISTS:
# - Provides comprehensive audit trails required for enterprise governance and compliance reporting
# - Enables operational dashboards and monitoring integration for infrastructure change tracking
# - Supports regulatory requirements for infrastructure change documentation and accountability
# - Facilitates troubleshooting and forensic analysis of Power Platform governance operations
#
# ðŸ”’ SECURITY DECISIONS:
# - Generates metadata in UTC timestamps to prevent timezone-based confusion in audit logs
# - Uses jq for secure JSON construction preventing injection attacks from user inputs
# - Validates additional-data as valid JSON to prevent downstream parsing vulnerabilities
# - Avoids sensitive data exposure through structured logging patterns that exclude secrets
#
# âš™ï¸ OPERATIONAL CONTEXT:
# - Implements AVM-compliant metadata schema v2.0.0 for maximum interoperability with Azure tooling
# - Supports custom metadata extensions through validated JSON input for specialized tracking needs
# - Provides phase-based tracking for workflow progress monitoring and performance analysis
# - Enables correlation between multiple workflow executions through consistent identification patterns
#
# ðŸ“‹ INTEGRATION REQUIREMENTS:
# - Requires jq JSON processor for reliable and secure JSON construction in all runner environments
# - Depends on Terraform CLI availability for version extraction in infrastructure automation workflows
# - Output format designed for consumption by SIEM systems, audit platforms, and monitoring dashboards
# - Metadata schema must remain consistent across action versions to maintain audit trail integrity
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: 'Generate Workflow Metadata'
description: 'Generates comprehensive AVM-compliant metadata for workflow execution tracking and compliance'

# === INPUT PARAMETERS ===
# These inputs define the execution context and operational details that will be
# embedded in the generated metadata for comprehensive tracking and reporting.
inputs:
  operation:
    description: 'Terraform operation type for categorization and filtering'
    required: true
    # Supported values: 'plan', 'apply', 'destroy', 'import', 'output', 'test', 'validate'
    # Used for: Operation categorization, audit filtering, compliance reporting
    # Examples: 'plan' for infrastructure planning, 'apply' for deployment
    # This field is required as it's fundamental for operational tracking
    # Impact: Affects downstream monitoring and alerting logic

  configuration:
    description: 'Target configuration directory name for operation context'
    required: false
    # Format: Directory name without path (e.g., '01-dlp-policies', '03-environment')
    # Used for: Resource grouping, cost allocation, permission scoping
    # When omitted: Indicates operation doesn't target specific configuration (e.g., global operations)
    # Examples: '01-dlp-policies' for DLP policy configurations, '02-dlp-policy' for specific policies
    # Impact: Enables configuration-level reporting and access control

  tfvars-file:
    description: 'Variables file name for environment and context identification'
    required: false
    # Format: Filename without .tfvars extension (e.g., 'dev', 'prod', 'dlp-finance')
    # Used for: Environment tracking, variable audit trails, deployment context
    # When omitted: Indicates operation uses default variables or doesn't require specific variable files
    # Examples: 'dev' for development environment, 'prod' for production deployment
    # Impact: Critical for environment-specific compliance and change tracking

  phase:
    description: 'Current execution phase for workflow progress tracking'
    required: false
    default: 'execution'
    # Supported values: 'validation', 'planning', 'execution', 'post-deployment', 'cleanup'
    # Used for: Progress tracking, error correlation, performance analysis
    # Default: 'execution' covers most standard Terraform operations
    # Examples: 'validation' for syntax checking, 'planning' for change analysis
    # Impact: Enables phase-specific monitoring and troubleshooting

  additional-data:
    description: 'Custom JSON metadata for specialized tracking requirements'
    required: false
    default: '{}'
    # Format: Valid JSON object that will be merged into metadata.additional
    # Used for: Custom tracking, specialized compliance fields, integration data
    # Validation: Must be valid JSON - invalid JSON will cause action failure
    # Examples: '{"cost_center": "IT-001", "project": "governance-v2"}'
    # Impact: Enables custom reporting and specialized audit requirements
    # Security: Avoid sensitive data - metadata may be logged or exported

# === OUTPUT PARAMETERS ===
# The generated metadata provides comprehensive information about the workflow execution
# in a standardized JSON format optimized for consumption by monitoring, audit, and reporting systems.
outputs:
  metadata:
    description: 'Complete AVM-compliant metadata object in JSON format'
    value: ${{ steps.generate.outputs.metadata }}
    # Format: JSON object containing comprehensive execution metadata
    # Structure: Follows AVM metadata schema v2.0.0 for maximum compatibility
    #
    # Schema Overview:
    # {
    #   "generated_at": "2025-01-15T10:30:00Z",           # ISO 8601 UTC timestamp
    #   "workflow": {                                      # GitHub Actions context
    #     "run_number": "123",                             # Sequential workflow run number
    #     "run_id": "1234567890",                         # Unique workflow execution ID
    #     "generated_by": "github-user",                   # Actor who triggered workflow
    #     "version": "2.0.0"                              # Metadata schema version
    #   },
    #   "terraform_version": "1.6.4",                     # Terraform CLI version
    #   "operation": "plan",                              # Terraform operation type
    #   "phase": "execution",                             # Workflow execution phase
    #   "configuration": "01-dlp-policies",               # Target configuration (optional)
    #   "tfvars_file": "dev",                            # Variables file name (optional)
    #   "repository": {                                   # Source control context
    #     "name": "owner/repo",                           # Full repository name
    #     "ref": "refs/heads/main",                       # Git reference
    #     "sha": "abc123...",                             # Commit SHA
    #     "event": "push"                                 # Trigger event type
    #   },
    #   "runner": {                                       # Execution environment
    #     "os": "Linux",                                  # Runner operating system
    #     "architecture": "X64"                          # Runner architecture
    #   },
    #   "additional": {}                                  # Custom metadata object
    # }
    #
    # Usage Examples:
    # - Audit logging: Extract execution context for compliance reports
    # - Monitoring: Track operation performance and success rates
    # - Debugging: Correlate failures with environment and configuration details
    # - Cost allocation: Associate operations with teams and projects
    # - Security: Track who performed what operations when and where
    #
    # Integration Points:
    # - SIEM systems for security monitoring
    # - APM tools for performance tracking
    # - Cost management platforms for allocation
    # - Compliance dashboards for audit reporting
    # - DevOps metrics for operational insights

# === COMPOSITE ACTION EXECUTION ===
# This action uses shell-based metadata generation to ensure maximum compatibility
# and reliability across different runner environments and operating systems.
runs:
  using: 'composite'
  steps:
    # === STEP 1: COMPREHENSIVE METADATA GENERATION ===
    # Collects system information, environment context, and operational details
    # to create a complete, AVM-compliant metadata object for audit and tracking purposes
    - name: Generate Comprehensive AVM-Compliant Metadata
      id: generate
      shell: bash
      run: |
        echo "::notice title=Metadata Generation::ðŸ“Š Starting AVM-compliant metadata generation..."

        # === SYSTEM INFORMATION COLLECTION ===
        # Collect temporal and environmental data with proper error handling
        # This section ensures consistent timestamp formatting and version detection

        # Generate ISO 8601 UTC timestamp for global consistency
        # Format: YYYY-MM-DDTHH:MM:SSZ (e.g., 2025-01-15T10:30:00Z)
        # UTC ensures consistent timestamps regardless of runner timezone
        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        echo "::debug::Generated timestamp: $timestamp"

        # === TERRAFORM VERSION EXTRACTION ===
        # Extract Terraform version with fallback handling for environment compatibility
        # This is critical for audit trails and compatibility tracking
        if command -v terraform >/dev/null 2>&1; then
          # Extract version from Terraform CLI output, removing 'v' prefix for consistency
          # Example: "Terraform v1.6.4" becomes "1.6.4"
          terraform_version=$(terraform --version | head -1 | sed 's/Terraform v//' 2>/dev/null || echo 'unknown')
          echo "::debug::Detected Terraform version: $terraform_version"
        else
          # Fallback when Terraform is not available (e.g., in validation-only workflows)
          terraform_version='not-available'
          echo "::warning title=Terraform Not Available::Terraform CLI not found, using fallback version"
        fi

        # === INPUT VALIDATION ===
        # Validate additional-data input to prevent JSON parsing failures
        # This prevents downstream failures in monitoring and reporting systems
        if ! echo '${{ inputs.additional-data }}' | jq empty 2>/dev/null; then
          echo "::error title=Invalid JSON::additional-data parameter contains invalid JSON"
          echo "::error::Provided value: '${{ inputs.additional-data }}'"
          exit 1
        fi

        # === COMPREHENSIVE METADATA CONSTRUCTION ===
        # Use jq for reliable JSON construction with proper escaping and type handling
        # This approach ensures valid JSON output regardless of input complexity
        echo "::debug::Constructing metadata JSON object..."

        metadata_json=$(jq -n \
          --arg timestamp "$timestamp" \
          --arg workflow_run "${{ github.run_number }}" \
          --arg workflow_id "${{ github.run_id }}" \
          --arg generated_by "${{ github.actor }}" \
          --arg tf_version "$terraform_version" \
          --arg workflow_version "2.0.0" \
          --arg operation "${{ inputs.operation }}" \
          --arg phase "${{ inputs.phase }}" \
          --arg configuration "${{ inputs.configuration }}" \
          --arg tfvars_file "${{ inputs.tfvars-file }}" \
          --arg repository "${{ github.repository }}" \
          --arg ref "${{ github.ref }}" \
          --arg sha "${{ github.sha }}" \
          --arg event "${{ github.event_name }}" \
          --arg runner_os "${{ runner.os }}" \
          --arg runner_arch "${{ runner.arch }}" \
          --argjson additional '${{ inputs.additional-data }}' \
          '{
            "generated_at": $timestamp,
            "workflow": {
              "run_number": ($workflow_run | tonumber),
              "run_id": $workflow_id,
              "generated_by": $generated_by,
              "version": $workflow_version
            },
            "terraform_version": $tf_version,
            "operation": $operation,
            "phase": $phase,
            "configuration": ($configuration // null),
            "tfvars_file": ($tfvars_file // null),
            "repository": {
              "name": $repository,
              "ref": $ref,
              "sha": $sha,
              "event": $event
            },
            "runner": {
              "os": $runner_os,
              "architecture": $runner_arch
            },
            "additional": $additional
          }'
        )

        # === METADATA VALIDATION ===
        # Verify the generated JSON is valid before output
        # This prevents downstream failures in consuming systems
        if ! echo "$metadata_json" | jq empty 2>/dev/null; then
          echo "::error title=Metadata Generation Failed::Generated metadata is not valid JSON"
          exit 1
        fi

        # === SECURE OUTPUT GENERATION ===
        # Use GitHub Actions multiline output format to safely handle JSON content
        # This prevents issues with special characters and ensures reliable transmission
        {
          echo "metadata<<METADATA_EOF"
          echo "$metadata_json"
          echo "METADATA_EOF"
        } >> $GITHUB_OUTPUT

        # === SUCCESS CONFIRMATION ===
        # Provide confirmation and summary of generated metadata
        echo "::notice title=Metadata Generated::âœ… AVM-compliant metadata successfully created"
        echo "::notice title=Operation Context::Operation: ${{ inputs.operation }}, Phase: ${{ inputs.phase }}"
        if [ -n "${{ inputs.configuration }}" ]; then
          echo "::notice title=Configuration::Processing configuration: ${{ inputs.configuration }}"
        fi
        if [ -n "${{ inputs.tfvars-file }}" ]; then
          echo "::notice title=Variables::Using tfvars file: ${{ inputs.tfvars-file }}"
        fi

        echo "::debug::Metadata generation completed successfully"
