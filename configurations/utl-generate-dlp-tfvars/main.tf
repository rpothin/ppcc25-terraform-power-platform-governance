# Smart DLP tfvars Generator: Data Processing Logic (Onboarding Only)
#
# This file implements the core logic for generating tfvars files from exported DLP policy data.
# Focuses only on onboarding existing policies to IaC (no template generation).
# Follows AVM and project standards: clear separation of concerns, security-first, and anti-corruption outputs.

# Load exported DLP policy data (from JSON files generated by export utilities)
locals {
  dlp_policies_json = fileexists("${path.module}/terraform-output-utl-export-dlp-policies.json") ? file("${path.module}/terraform-output-utl-export-dlp-policies.json") : null
  dlp_policies      = local.dlp_policies_json != null ? jsondecode(local.dlp_policies_json) : {}
}

# Policy selection and validation
locals {
  selected_policy = contains(keys(local.dlp_policies), var.source_policy_name) ? local.dlp_policies[var.source_policy_name] : null
  policy_exists   = local.selected_policy != null
}

# Extract connector data from selected policy (with safe defaults)
locals {
  default_connector_object = {
    id                           = ""
    default_action_rule_behavior = ""
    action_rules                 = []
    endpoint_rules               = []
  }

  # Extract and normalize business connectors
  business_connectors = local.policy_exists ? [
    for c in(local.selected_policy["business_connectors"] != null ? local.selected_policy["business_connectors"] : []) :
    can(c.id) ? c : merge(local.default_connector_object, { id = tostring(c) })
  ] : []

  # Extract and normalize non-business connectors
  non_business_connectors = local.policy_exists ? [
    for c in(local.selected_policy["non_business_connectors"] != null ? local.selected_policy["non_business_connectors"] : []) :
    can(c.id) ? c : merge(local.default_connector_object, { id = tostring(c) })
  ] : []

  # Extract and normalize blocked connectors
  blocked_connectors = local.policy_exists ? [
    for c in(local.selected_policy["blocked_connectors"] != null ? local.selected_policy["blocked_connectors"] : []) :
    can(c.id) ? c : merge(local.default_connector_object, { id = tostring(c) })
  ] : []

  # Extract environment and custom connector settings from policy
  environments = local.policy_exists && local.selected_policy["environments"] != null ? local.selected_policy["environments"] : []
  custom_connectors_patterns = local.policy_exists && local.selected_policy["custom_connectors_patterns"] != null ? local.selected_policy["custom_connectors_patterns"] : [
    {
      order            = 1
      host_url_pattern = "*"
      data_group       = "Blocked"
    }
  ]
}

# Generate tfvars content in HCL format (not JSON) for direct use
locals {
  tfvars_content = <<-TFVARS
# Generated tfvars for DLP policy: ${var.source_policy_name}
# Generated on: ${timestamp()}
# Source: utl-generate-dlp-tfvars

policy_name = "${var.source_policy_name}"

business_connectors = ${jsonencode(local.business_connectors)}

non_business_connectors = ${jsonencode(local.non_business_connectors)}

blocked_connectors = ${jsonencode(local.blocked_connectors)}

environments = ${jsonencode(local.environments)}

custom_connectors_patterns = ${jsonencode(local.custom_connectors_patterns)}
TFVARS
}

# Validate that we found the policy and generated valid content
locals {
  tfvars_valid = local.policy_exists && (
    length(local.business_connectors) +
    length(local.non_business_connectors) +
    length(local.blocked_connectors)
  ) > 0
}

# Outputs are defined in outputs.tf (see anti-corruption layer pattern)